/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// int __fastcall _cxa_finalize(void *);
// void __fastcall _aeabi_memclr8(void *, size_t); idb
// int ZTH11g_lastStack(void); weak
// int __fastcall _emutls_get_address(_DWORD); weak
// void free(void *p);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// size_t strlen(const char *);
// int sprintf(char *s, const char *format, ...);
// void __fastcall _aeabi_memclr4(void *, size_t); idb
// char *strdup(const char *);
// void *malloc(size_t byte_count);
// void *calloc(size_t item_count, size_t item_size);
// void __fastcall _aeabi_memclr(void *, size_t); idb
// void __fastcall _aeabi_memcpy(void *, const void *, size_t); idb
// _DWORD __fastcall std::__call_once(std::__ndk1 *__hidden this, volatile unsigned int *, void *, void (__fastcall *)(void *)); idb
// void __fastcall operator delete(void *); idb
// _DWORD __fastcall operator new(unsigned int); idb
// FILE *fopen(const char *filename, const char *modes);
// int fseek(FILE *stream, int off, int whence);
// int ftell(FILE *stream);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// int fclose(FILE *stream);
// uLong adler32(uLong adler, const Bytef *buf, uInt len);
// int uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// int __fastcall _cxa_guard_acquire(__guard *);
// void __fastcall _cxa_guard_release(__guard *);
// int open(const char *file, int oflag, ...);
// int _errno(void); weak
// void *memcpy(void *, const void *, size_t);
// int mkstemp(char *);
// int unlink(const char *name);
// char *getenv(const char *);
// void *memset(void *, int, size_t);
// ssize_t write(int fd, const void *buf, size_t n);
// int sysconf(int name);
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
// int close(int fd);
// int ftruncate(int fd, __off_t length);
// int munmap(void *addr, size_t len);
// void abort(void);
// int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
// int fprintf(FILE *stream, const char *format, ...);
// int fflush(FILE *stream);
// int __fastcall dladdr(_DWORD, _DWORD); weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD); weak
int sub_1698();
int __fastcall sub_16A8(int a1, int a2, int **a3, int a4);
__int64 __fastcall Java_com_xunmeng_nvwavm_NvwaVM_nwvmLoad(int a1, int a2, int a3, int a4, int a5);
int __fastcall sub_1940(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void __fastcall Java_com_xunmeng_nvwavm_NvwaVM_nwvmDestory(int a1, int a2, void *a3);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callV(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callZ(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callC(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callB(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callS(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callI(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callF(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
__int64 __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callJ(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
__int64 __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callD(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callL(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_prepareClass(int a1, int a2, int a3, int a4, int a5);
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callVM(int a1, int a2, _DWORD *a3, int a4, int a5, int a6);
_DWORD *__fastcall sub_2160(int a1, int a2);
int __fastcall sub_21D4(int a1);
int __fastcall sub_2224(int a1);
int __fastcall sub_2274(int a1);
int __fastcall sub_22C4(int a1);
int __fastcall sub_2314(int a1);
int __fastcall sub_2364(int a1);
int __fastcall sub_23B4(int a1);
int __fastcall sub_2404(int a1);
int __fastcall sub_2454(int a1, int a2);
int __fastcall sub_2482(int *a1, unsigned int **a2);
_DWORD *__fastcall sub_26DE(_DWORD *result);
_DWORD *__fastcall sub_273E(_DWORD *result);
int __fastcall sub_2792(int a1, int a2);
int __fastcall sub_28E0(int a1, int a2);
int __fastcall sub_2984(int a1, int a2);
_DWORD *__fastcall sub_29B8(_DWORD *a1);
int __fastcall sub_29FA(int a1, int a2, unsigned int **a3);
int __fastcall sub_2BD0(int a1, int a2);
int __fastcall sub_2C2A(int result, int a2, char *a3, int a4);
int __fastcall sub_2C7C(int a1, int a2, int a3, void (__fastcall *a4)(void *));
int __fastcall sub_2CD0(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, unsigned int a7);
void sub_5F3E();
void sub_5F7C();
void sub_5FBA();
int sub_6590(); // weak
int sub_684A(); // weak
void sub_6888();
void sub_68A2();
void sub_68B0();
void sub_68BE();
void sub_68CC();
void sub_68DA();
void sub_68E8();
void sub_695A();
void sub_697C();
void sub_69A0();
void sub_69C4();
void sub_69E8();
void sub_69F6();
void sub_6A04();
void sub_6A12();
void sub_6A20();
void sub_6A2E();
void sub_6A52();
void sub_6A76();
void sub_6ADA();
void sub_6B1A();
void sub_6B3A();
void sub_6B48();
void sub_6B56();
void sub_6B64();
void sub_6B72();
void sub_6B80();
void sub_6BA0();
void __noreturn sub_6BC4();
int sub_6C10();
int sub_6CBE();
void sub_6CFC();
void sub_6D24();
void __noreturn sub_6F0C();
int sub_6F4E();
int sub_6F86();
int sub_6FBE();
int sub_7050();
void __fastcall sub_70A4(int a1, int a2, int a3, int a4, int a5);
int sub_726C();
int sub_72CC();
int sub_7314();
int sub_7354();
int sub_7388();
int sub_73FC();
void sub_7468();
_DWORD *__fastcall sub_751C(_DWORD *result, int a2);
_DWORD *__fastcall sub_7556(_DWORD *result, int a2);
int __fastcall sub_7592(_DWORD *a1, int a2);
int __fastcall sub_75E8(int a1, int a2, char *a3, int *a4, int a5);
int __fastcall sub_776C(_DWORD *a1);
int __fastcall sub_77C0(int a1, int a2);
void *__fastcall sub_7994(void *a1);
void __fastcall sub_7A2E(int a1, _DWORD *a2);
int __fastcall sub_7A54(int ***a1);
int __fastcall sub_7F7C(int a1, int a2, int *a3, _QWORD *a4);
int __fastcall sub_7FF0(int a1, int a2, int **a3, int *a4);
int *__fastcall sub_801C(int *result, int *a2);
_DWORD *__fastcall sub_8152(int a1, int *a2);
_DWORD *__fastcall sub_818C(int *a1, int a2, const char *a3);
int __fastcall sub_82F8(const void *a1, int a2, _DWORD *a3, int a4);
int sub_8590(int a1, int a2, int a3, const char *a4, ...);
int __fastcall sub_8634(int result, int a2);
int __fastcall sub_86C0(int a1, int a2, unsigned int a3);
int __fastcall sub_8738(int a1, int a2, unsigned int *a3, int a4);
bool __fastcall sub_8CE4(_DWORD *a1);
int sub_8D18(int a1, int a2, const char *a3, ...);
int __fastcall sub_8D94(int a1, int a2);
int __fastcall sub_8DE8(int a1);
_DWORD *__fastcall sub_8E38(int *a1);
int __fastcall sub_8E98(int, int, char *); // idb
int __fastcall sub_8F50(int a1);
_DWORD *__fastcall sub_8FA0(_DWORD *a1);
_DWORD *__fastcall sub_9068(_DWORD *a1, int *a2);
int __fastcall sub_928C(int a1, int a2, int a3, _DWORD *a4, int a5, int a6);
int __fastcall sub_92F2(int a1, int *a2, int a3, int a4, int a5);
int __fastcall sub_9346(int result, int a2, _DWORD *a3);
int __fastcall sub_9380(int a1, int a2, int a3, void (__fastcall *a4)(void *));
int __fastcall sub_93DC(int result, int a2);
int __fastcall sub_93F4(int ***a1);
int __fastcall sub_946C(int a1, int a2, unsigned int **a3);
int __fastcall sub_9514(int a1, int a2);
int __fastcall sub_9570(int a1, int a2);
int __fastcall sub_97D4(int a1);
bool __fastcall sub_9824(int a1, int *a2);
int __fastcall sub_A100(int *a1, int a2, int a3, int a4, int **a5);
int __fastcall sub_A48C(const char *a1, int a2, int a3, int a4);
int __fastcall sub_A548(const char *a1, int a2, int a3, int a4);
int __fastcall sub_A568(signed int a1, int a2);
unsigned int __fastcall sub_A870(unsigned int a1, unsigned int a2, int a3);
int *__fastcall sub_C388(int *result);
int __fastcall sub_D2B8(_DWORD *a1);
int __fastcall sub_D564(_DWORD *a1, int a2);
void *__fastcall sub_D7F8(_DWORD *a1, __int64 (__fastcall *a2)(), void *a3, int a4, int a5);
int __fastcall sub_E184(int *a1);
int __fastcall sub_E6EC(int *a1);
int __fastcall sub_E720(int a1, void (__fastcall *a2)(int, int, _DWORD *, int, _DWORD), int a3, int a4);
int __fastcall sub_E7E8(int a1, void (__fastcall *a2)(int, int, unsigned int *, int), int a3, int a4);
char *__fastcall sub_EB98(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5);
int __fastcall sub_ECA0(int a1);
int __fastcall sub_ECB0(int a1, _DWORD *a2, __int64 (__fastcall *a3)());
int sub_ECE0(); // weak
void sub_ED18();
void __fastcall sub_ED30(int a1, int a2, int a3, int a4);
void sub_ED60();
void __fastcall sub_ED78(int a1, int a2, int a3, int a4);
void __fastcall sub_EDB0(int a1, int a2, int a3, int a4, int a5, int a6);
unsigned int *__fastcall sub_EDF4(unsigned int *result, int *a2, int *a3);
int __fastcall sub_EE48(int a1, int a2, unsigned int a3, unsigned int a4);
int __fastcall sub_F104(int a1, int a2, unsigned int a3, int a4, int *a5);
int __fastcall sub_F1E4(int a1, unsigned int a2, unsigned int a3, unsigned int a4);
int sub_F354(); // weak
int sub_F3B8(); // weak
int sub_F3C0(); // weak
int __fastcall sub_F3C8(const void *a1, int *a2, char a3);
void __fastcall __noreturn sub_F4F8(int *a1, int a2, int a3, int a4);
int __fastcall sub_F580(_DWORD *a1, int a2, int a3, int a4, int a5);
_QWORD *__fastcall sub_F598(_QWORD *result);
_QWORD *__fastcall sub_F5A0(_QWORD *result);
_QWORD *__fastcall sub_F5A8(_QWORD *result);
void sub_F5B0();
void sub_F5F4();
int __fastcall sub_F608(int a1, const void *a2);
int __fastcall sub_F650(int a1, int a2, _DWORD *a3);
int __fastcall sub_F688(int a1, int a2, int a3);
int __fastcall sub_F6D4(int a1, int a2, int a3, int a4);
int __fastcall sub_F710(int a1);
int __fastcall sub_F716(int a1, int a2);
int __fastcall sub_F736(int a1);
int __fastcall sub_F74A(int a1);
int __fastcall sub_F754(int a1, int a2);
int __fastcall sub_F774(int a1, int a2);
int __fastcall sub_F82C(int result, int a2, int a3);
int __fastcall sub_F8EC(int a1, int a2);
__int64 __fastcall sub_F90C(int a1, int a2);
_DWORD *__fastcall sub_F912(int a1, int a2, int a3, int a4);
int __fastcall sub_F918(_DWORD *a1);
_DWORD *__fastcall sub_F96A(int a1, _DWORD *a2);
int __fastcall sub_F984(int a1);
int __fastcall sub_F99C(int a1);
int __fastcall sub_F9A4(int a1, char *a2, size_t a3, _DWORD *a4);
int __fastcall sub_FA14(int *a1, int a2);
int *__fastcall sub_FA84(int a1, int a2);
int __fastcall sub_FA8A(int result);
__int64 __fastcall sub_FA94(int a1, int a2);
_DWORD *__fastcall sub_FB74(int a1, int a2, int a3, int a4);
int __fastcall sub_FC60(int a1);
_DWORD *__fastcall sub_FCB8(int a1);
int __fastcall sub_FD08(int *a1, int a2, _DWORD *a3);
_DWORD *__fastcall sub_FF10(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8);
int __fastcall sub_102F4(int a1);
void sub_10308();
void sub_10310();
void sub_10318();
_DWORD *__fastcall sub_10320(int *a1);
_DWORD *__fastcall sub_10364(int *a1);
int __fastcall sub_10380(__int64 a1, __int64 a2);
int __fastcall sub_105FC(int result);
int __fastcall sub_10640(int a1, int a2, int a3, unsigned int a4);
int __fastcall sub_1068C(__int64 a1);
int __fastcall sub_10888(__int64 a1);
int __fastcall sub_10904(void *a1, void *a2, int a3, void *a4);
unsigned int __fastcall sub_10918(int a1);
unsigned int __fastcall sub_1093E(unsigned int a1, unsigned int a2);
unsigned int __fastcall sub_10970(int a1, int a2, int a3, unsigned int a4);
unsigned int __fastcall sub_109BC(__int64 a1);
unsigned int __fastcall sub_10A04(__int64 a1, int a2, unsigned int a3);
int __fastcall sub_10BE0(int result, unsigned int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8);
int __fastcall sub_10DC6(int result, int a2, int a3, unsigned int a4);
int __fastcall sub_10E38(unsigned int a1, unsigned int a2, unsigned int a3, int a4);
unsigned int __fastcall sub_10EB4(unsigned int a1, int a2, unsigned int a3, unsigned int a4);
unsigned int __fastcall sub_10EC4(unsigned int a1, unsigned int a2, unsigned int a3, int a4);
int __fastcall sub_10EE8(unsigned int a1, unsigned int a2, unsigned int a3, int a4);
unsigned int __fastcall sub_10F38(unsigned int a1, int a2);
int __fastcall sub_10F88(int result, int a2);
int __fastcall sub_10FE8(int a1, int a2);
void __fastcall __spoils<R2,R3,R12> sub_10FF0(int a1, int a2);
int __fastcall sub_11014(int a1, int a2);
void j_free(void *p);
int __fastcall j_pthread_mutex_unlock(pthread_mutex_t *mutex);
void __fastcall operator delete(void *); // idb
int __fastcall sub_11094(int a1);
_DWORD *__fastcall sub_110A4(int *a1);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
char byte_4 = '\x01'; // weak
char byte_8[] = { '\0' }; // weak
int dword_20 = 78340; // weak
int dword_138 = 132; // weak
_UNKNOWN loc_477A; // weak
_UNKNOWN loc_47E6; // weak
_UNKNOWN loc_4800; // weak
_UNKNOWN loc_4820; // weak
_UNKNOWN loc_4842; // weak
_UNKNOWN loc_488E; // weak
_UNKNOWN loc_48D6; // weak
_UNKNOWN loc_48FE; // weak
_UNKNOWN loc_4942; // weak
_UNKNOWN loc_4970; // weak
_UNKNOWN loc_49AE; // weak
_UNKNOWN loc_49D4; // weak
_UNKNOWN loc_49FA; // weak
_UNKNOWN loc_4A20; // weak
_UNKNOWN loc_4A72; // weak
_UNKNOWN loc_4ADC; // weak
_UNKNOWN loc_4B30; // weak
_UNKNOWN loc_4B8C; // weak
_UNKNOWN loc_4BD2; // weak
_UNKNOWN loc_4C42; // weak
_UNKNOWN loc_4C90; // weak
_UNKNOWN loc_4CD4; // weak
_UNKNOWN loc_4CFA; // weak
_UNKNOWN loc_4D20; // weak
_UNKNOWN loc_4D44; // weak
_UNKNOWN loc_4D7A; // weak
_UNKNOWN loc_4DE2; // weak
_UNKNOWN loc_4E04; // weak
_UNKNOWN loc_4E3A; // weak
_UNKNOWN loc_4E66; // weak
_UNKNOWN loc_4EC8; // weak
_UNKNOWN loc_4F02; // weak
_UNKNOWN loc_4F48; // weak
_UNKNOWN loc_4F9A; // weak
_UNKNOWN loc_500C; // weak
_UNKNOWN loc_5086; // weak
_UNKNOWN loc_512E; // weak
_UNKNOWN loc_5154; // weak
_UNKNOWN loc_517C; // weak
_UNKNOWN loc_51AA; // weak
_UNKNOWN loc_51D6; // weak
_UNKNOWN loc_5202; // weak
_UNKNOWN loc_522A; // weak
_UNKNOWN loc_5258; // weak
_UNKNOWN loc_5284; // weak
_UNKNOWN loc_52B0; // weak
_UNKNOWN loc_52D8; // weak
_UNKNOWN loc_5310; // weak
_UNKNOWN loc_533C; // weak
_UNKNOWN loc_5368; // weak
_UNKNOWN loc_53A2; // weak
_UNKNOWN loc_53DE; // weak
_UNKNOWN loc_540A; // weak
_UNKNOWN loc_5436; // weak
_UNKNOWN loc_546C; // weak
_UNKNOWN loc_54B0; // weak
_UNKNOWN loc_54DA; // weak
_UNKNOWN loc_5512; // weak
_UNKNOWN loc_5536; // weak
_UNKNOWN loc_5560; // weak
_UNKNOWN loc_5586; // weak
_UNKNOWN loc_55AC; // weak
_UNKNOWN loc_55DA; // weak
_UNKNOWN loc_562C; // weak
_UNKNOWN loc_565A; // weak
_UNKNOWN loc_56B2; // weak
_UNKNOWN loc_56E0; // weak
_UNKNOWN loc_5738; // weak
_UNKNOWN loc_5760; // weak
_UNKNOWN loc_578E; // weak
_UNKNOWN loc_57B6; // weak
_UNKNOWN loc_57E4; // weak
_UNKNOWN loc_580C; // weak
_UNKNOWN loc_583A; // weak
_UNKNOWN loc_5866; // weak
_UNKNOWN loc_588A; // weak
_UNKNOWN loc_58B0; // weak
_UNKNOWN loc_58D6; // weak
_UNKNOWN loc_58F0; // weak
_UNKNOWN loc_5916; // weak
_UNKNOWN loc_5940; // weak
_UNKNOWN loc_5966; // weak
_UNKNOWN loc_598C; // weak
_UNKNOWN loc_59B2; // weak
_UNKNOWN loc_59D8; // weak
_UNKNOWN loc_5A02; // weak
_UNKNOWN loc_5A28; // weak
_UNKNOWN loc_5A4A; // weak
_UNKNOWN loc_5A6C; // weak
_UNKNOWN loc_5A8E; // weak
_UNKNOWN loc_5AE0; // weak
_UNKNOWN loc_5B56; // weak
_UNKNOWN loc_5BE8; // weak
_UNKNOWN loc_5C08; // weak
_UNKNOWN loc_5C28; // weak
_UNKNOWN loc_5C4A; // weak
_UNKNOWN loc_5C6A; // weak
_UNKNOWN loc_5C8A; // weak
_UNKNOWN loc_5CAA; // weak
_UNKNOWN loc_5CCC; // weak
_UNKNOWN loc_5CEE; // weak
_UNKNOWN loc_5D10; // weak
_UNKNOWN loc_5D32; // weak
_UNKNOWN loc_5D54; // weak
_UNKNOWN loc_5D74; // weak
_UNKNOWN loc_5DC6; // weak
_UNKNOWN loc_5E18; // weak
_UNKNOWN loc_5E2C; // weak
_UNKNOWN loc_5E94; // weak
_UNKNOWN loc_5ED4; // weak
_UNKNOWN sub_61A4; // weak
_UNKNOWN sub_61E4; // weak
_UNKNOWN sub_6212; // weak
_UNKNOWN sub_6240; // weak
_UNKNOWN sub_626E; // weak
_UNKNOWN sub_629C; // weak
_UNKNOWN sub_62CA; // weak
_UNKNOWN sub_62F8; // weak
_UNKNOWN sub_6326; // weak
_UNKNOWN sub_6358; // weak
_UNKNOWN sub_6396; // weak
_UNKNOWN sub_63CC; // weak
_UNKNOWN sub_6402; // weak
_UNKNOWN sub_6438; // weak
_UNKNOWN sub_646E; // weak
_UNKNOWN sub_64A4; // weak
_UNKNOWN sub_64DA; // weak
_UNKNOWN sub_6510; // weak
_UNKNOWN sub_6546; // weak
_UNKNOWN sub_6704; // weak
_UNKNOWN sub_671C; // weak
_UNKNOWN sub_6726; // weak
_UNKNOWN sub_6730; // weak
_UNKNOWN sub_673A; // weak
_UNKNOWN sub_6744; // weak
_UNKNOWN sub_674E; // weak
_UNKNOWN sub_6766; // weak
_UNKNOWN sub_6782; // weak
_UNKNOWN sub_67A8; // weak
_UNKNOWN sub_67C6; // weak
_UNKNOWN sub_67D6; // weak
_UNKNOWN sub_67E8; // weak
_UNKNOWN sub_67FA; // weak
_UNKNOWN sub_680A; // weak
_UNKNOWN sub_681A; // weak
_UNKNOWN loc_682C; // weak
_UNKNOWN loc_6C5A; // weak
_UNKNOWN loc_73B6; // weak
int dword_82A0 = 25202; // weak
int dword_918C = 23131; // weak
int dword_91AC = 6778732; // weak
int dword_91B8 = 5908776; // weak
int dword_91C0 = 4401448; // weak
int dword_91D4 = 4335912; // weak
int dword_EDE8[2] = { -498089976, -450891772 }; // weak
int dword_FA0C = 29477; // weak
__int16 word_FFFE = 164; // weak
int dword_101A0 = 25456; // weak
int dword_101A4 = 3224420; // weak
int dword_101A8 = 3158884; // weak
int dword_101AC = 3748452; // weak
int dword_101B0 = 3682916; // weak
int dword_101B4 = 3617380; // weak
int dword_101B8 = 3551844; // weak
int dword_101BC = 3486308; // weak
int dword_101C0 = 3420772; // weak
int dword_101C4 = 3355236; // weak
int dword_101C8 = 3289700; // weak
int dword_101CC = 3224164; // weak
int dword_101D0 = 3158628; // weak
int dword_101D4 = 3748196; // weak
int dword_101D8 = 3682660; // weak
int dword_101DC = 3617124; // weak
int dword_101E0 = 3551588; // weak
int dword_101E4 = 3486052; // weak
int dword_101E8 = 3420516; // weak
int dword_101EC = 3354980; // weak
int dword_101F0 = 3289444; // weak
int dword_101F4 = 3223908; // weak
int dword_101F8 = 3158372; // weak
int dword_101FC = 14692; // weak
int dword_10200 = 14436; // weak
int dword_10204 = 14180; // weak
int dword_10208 = 13924; // weak
int dword_1020C = 13668; // weak
int dword_10210 = 13412; // weak
int dword_10214 = 13156; // weak
int dword_10218 = 12900; // weak
int dword_1021C = 12644; // weak
int dword_10220 = 12388; // weak
int dword_10224 = 3224435; // weak
int dword_10228 = 3158899; // weak
int dword_1022C = 3748467; // weak
int dword_10230 = 3682931; // weak
int dword_10234 = 3617395; // weak
int dword_10238 = 3551859; // weak
int dword_1023C = 3486323; // weak
int dword_10240 = 3420787; // weak
int dword_10244 = 3355251; // weak
int dword_10248 = 3289715; // weak
int dword_1024C = 3224179; // weak
int dword_10250 = 3158643; // weak
int dword_10254 = 3748211; // weak
int dword_10258 = 3682675; // weak
int dword_1025C = 3617139; // weak
int dword_10260 = 3551603; // weak
int dword_10264 = 3486067; // weak
int dword_10268 = 3420531; // weak
int dword_1026C = 3354995; // weak
int dword_10270 = 3289459; // weak
int dword_10274 = 3223923; // weak
int dword_10278 = 3158387; // weak
int dword_1027C = 14707; // weak
int dword_10280 = 14451; // weak
int dword_10284 = 14195; // weak
int dword_10288 = 13939; // weak
int dword_1028C = 13683; // weak
int dword_10290 = 13427; // weak
int dword_10294 = 13171; // weak
int dword_10298 = 12915; // weak
int dword_1029C = 12659; // weak
int dword_102A0 = 12403; // weak
int dword_102A4 = 3289458; // weak
int dword_102A8 = 3223922; // weak
int dword_102AC = 3158386; // weak
int dword_102B0 = 14706; // weak
int dword_102B4 = 14450; // weak
int dword_102B8 = 14194; // weak
int dword_102BC = 13938; // weak
int dword_102C0 = 13682; // weak
int dword_102C4 = 13426; // weak
int dword_102C8 = 13170; // weak
int dword_102CC = 12914; // weak
int dword_102D0 = 12658; // weak
int dword_102D4 = 12402; // weak
int dword_102D8 = 28787; // weak
int dword_102DC = 29292; // weak
_UNKNOWN unk_120E4; // weak
int (*off_13CA0)() = &sub_A548; // weak
void *off_13CF0 = &unk_12138; // weak
void *off_13D60 = (void *)0xF751; // weak
_UNKNOWN unk_14000; // weak
_UNKNOWN unk_14004; // weak
int dword_14014 = -1; // weak
char byte_14018; // weak
_DWORD dword_1401C[14]; // idb
char byte_14054; // weak
int dword_14058[]; // weak
int dword_1405C; // weak
int dword_14060; // weak
int dword_14064[]; // weak
int dword_14068; // weak
int dword_1406C; // weak
int dword_14070; // weak
int dword_14074; // weak
int dword_14078; // weak
int dword_1407C; // weak
int dword_14080; // weak
int dword_14084; // weak
int dword_14190; // weak
int dword_1420C; // weak
int dword_14210; // weak
int dword_14214; // weak
int dword_14218; // weak
char algn_1421C[4]; // weak
int dword_14220; // weak
int dword_14224; // weak
int dword_14228; // weak
int dword_1422C; // weak
int dword_14230; // weak
int dword_14234; // weak
int dword_14238; // weak
int dword_1423C; // weak
int dword_14240; // weak
int dword_14244; // weak
char algn_14248[8]; // weak
_UNKNOWN unk_14250; // weak
// extern _UNKNOWN _stack_chk_guard; weak
// extern _UNKNOWN _sF; weak
// extern _UNKNOWN _ZTH11g_lastStack; weak


//----- (00001698) --------------------------------------------------------
int sub_1698()
{
  return _cxa_finalize(&unk_14000);
}

//----- (000016A8) --------------------------------------------------------
int __fastcall sub_16A8(int a1, int a2, int **a3, int a4)
{
  int *v6; // r0
  int v7; // r11
  int v8; // r4
  int *v9; // r8
  int *v10; // r10
  int v11; // r4
  _DWORD *v12; // r0
  __int16 v13; // r1
  int v14; // r0
  int **v15; // r4
  _DWORD *v16; // r12
  int v17; // r9
  int *v18; // r2
  int v19; // r5
  int v20; // r1
  int v21; // r8
  _DWORD *v22; // r11
  _DWORD *v23; // r0
  __int16 v24; // r1
  int v25; // r4
  int v27; // [sp+10h] [bp-40h] BYREF
  int *v28; // [sp+14h] [bp-3Ch]
  int v29; // [sp+18h] [bp-38h]
  int v30; // [sp+1Ch] [bp-34h]
  _DWORD v31[5]; // [sp+20h] [bp-30h] BYREF

  v29 = a2;
  v6 = *a3;
  v30 = *(_DWORD *)a4;
  v7 = *v6;
  v8 = *(_DWORD *)(a4 + 52) + *(_DWORD *)(a4 + 56) + 1;
  v9 = &v27 - 2 * v8;
  memset(v9, 0, 8 * v8);
  v31[0] = v7;
  v31[1] = (char *)&v27 - ((12 * v8 + 7) & 0xFFFFFFF8);
  v31[2] = 0;
  v10 = v9;
  if ( !*(_BYTE *)(a4 + 24) )
  {
    v11 = *a3[1];
    if ( v11 )
    {
      v12 = sub_2160((int)v31, v11);
      v13 = *((_WORD *)v12 + 1);
      *((_BYTE *)v12 + 1) = 1;
      *((_WORD *)v12 + 1) = v13 + 1;
    }
    else
    {
      v11 = 0;
    }
    *v9 = v11;
    v10 = v9 + 2;
  }
  v14 = *(_DWORD *)(a4 + 60);
  if ( v14 >= 1 )
  {
    v15 = a3 + 2;
    v16 = v31;
    v17 = 0;
    while ( 1 )
    {
      v18 = v15[v17];
      switch ( *(_BYTE *)(*(_DWORD *)(a4 + 20) + v17) )
      {
        case 'B':
          v10[2 * v17] = *(char *)v18;
          goto LABEL_20;
        case 'C':
          v10[2 * v17] = *(unsigned __int16 *)v18;
          goto LABEL_20;
        case 'D':
        case 'J':
          *(_QWORD *)&v10[2 * v17] = *(_QWORD *)v18;
          goto LABEL_20;
        case 'E':
        case 'G':
        case 'H':
        case 'K':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
          goto LABEL_27;
        case 'F':
        case 'I':
          v10[2 * v17] = *v18;
          goto LABEL_20;
        case 'L':
          v19 = *v18;
          if ( *v18 )
          {
            v20 = *v18;
            v28 = v9;
            v21 = v7;
            v22 = v16;
            v23 = sub_2160((int)v16, v20);
            v16 = v22;
            v7 = v21;
            v9 = v28;
            v24 = *((_WORD *)v23 + 1) + 1;
            *((_BYTE *)v23 + 1) = 1;
            *((_WORD *)v23 + 1) = v24;
            v14 = *(_DWORD *)(a4 + 60);
          }
          else
          {
            v19 = 0;
          }
          v10[2 * v17] = v19;
          goto LABEL_20;
        case 'S':
          v10[2 * v17] = *(__int16 *)v18;
          goto LABEL_20;
        default:
          if ( *(_BYTE *)(*(_DWORD *)(a4 + 20) + v17) != 90 )
          {
LABEL_27:
            sub_8590(
              v30,
              v7,
              3,
              "Unhandled argument type %c of `%s.%s`",
              *(unsigned __int8 *)(*(_DWORD *)(a4 + 20) + v17),
              *(const char **)(*(_DWORD *)(a4 + 8) + 80),
              *(const char **)(a4 + 12));
            return _stack_chk_guard - v31[3];
          }
          v10[2 * v17] = *(unsigned __int8 *)v18;
LABEL_20:
          if ( ++v17 >= v14 )
            goto LABEL_21;
          break;
      }
    }
  }
LABEL_21:
  sub_2CD0((_DWORD *)a4, v7, (int)v9, (int)v31, v29, 0, 0);
  v25 = v30;
  if ( *(_BYTE *)(v30 + 56) )
  {
    if ( &_ZTH11g_lastStack )
      ZTH11g_lastStack();
    if ( !*(_DWORD *)_emutls_get_address(&unk_14004) && (*(int (__fastcall **)(int))(*(_DWORD *)v7 + 912))(v7) )
      sub_8D94(v25, v7);
  }
  return _stack_chk_guard - v31[3];
}
// 13E0: using guessed type int ZTH11g_lastStack(void);
// 13EC: using guessed type int __fastcall _emutls_get_address(_DWORD);

//----- (000018B4) --------------------------------------------------------
__int64 __fastcall Java_com_xunmeng_nvwavm_NvwaVM_nwvmLoad(int a1, int a2, int a3, int a4, int a5)
{
  const char *v8; // r6
  _DWORD *v9; // r0
  int v10; // r4
  char v11; // r1
  int v12; // r0

  v8 = (const char *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)a1 + 676))(a1, a4, 0);
  v9 = sub_818C((int *)a1, a3, v8);
  v10 = (int)v9;
  if ( v9 )
  {
    v11 = a5;
    v12 = v9[1];
    if ( a5 )
      v11 = 1;
    *(_BYTE *)(v10 + 56) = v11;
    if ( v12 >= 0 )
    {
      sub_28E0(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v10 + 44) + 4 * v12) + 8), a1);
      if ( !sub_8D94(v10, a1) )
        sub_1940(a1, 0, v10, 0, *(_DWORD *)(v10 + 4), 0, 0, 0);
    }
  }
  (*(void (__fastcall **)(int, int, const char *))(*(_DWORD *)a1 + 680))(a1, a4, v8);
  return (unsigned int)v10;
}

//----- (00001940) --------------------------------------------------------
int __fastcall sub_1940(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v10; // r8
  int v11; // r5
  int *v12; // r6
  int *v13; // r1
  int v14; // r5
  _DWORD *v15; // r0
  __int16 v16; // r1
  int *v17; // r6
  int v18; // r5
  int v19; // r9
  int v20; // r11
  int v21; // r0
  __int64 v22; // r0
  int v23; // r1
  _DWORD *v24; // r0
  __int16 v25; // r1
  int v27[2]; // [sp+10h] [bp-38h] BYREF
  _DWORD v28[5]; // [sp+18h] [bp-30h] BYREF

  v10 = *(_DWORD *)(*(_DWORD *)(a3 + 44) + 4 * a5);
  v11 = *(_DWORD *)(v10 + 52) + *(_DWORD *)(v10 + 56) + 1;
  v12 = &v27[-2 * v11];
  memset(v12, 0, 8 * v11);
  v28[0] = a1;
  v28[1] = (char *)v27 - ((12 * v11 + 7) & 0xFFFFFFF8);
  v28[2] = 0;
  v13 = v12;
  if ( !*(_BYTE *)(v10 + 24) )
  {
    v14 = a7;
    if ( a7 )
    {
      v15 = sub_2160((int)v28, a7);
      v16 = *((_WORD *)v15 + 1);
      *((_BYTE *)v15 + 1) = 1;
      *((_WORD *)v15 + 1) = v16 + 1;
    }
    else
    {
      v14 = 0;
    }
    *v12 = v14;
    v13 = v12 + 2;
  }
  v27[0] = (int)v12;
  v17 = v13;
  if ( *(int *)(v10 + 60) >= 1 )
  {
    v18 = 0;
    v19 = *(_DWORD *)(v10 + 20);
    v27[1] = *(_DWORD *)(a3 + 52);
    while ( 1 )
    {
      v20 = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)a1 + 692))(a1, a8, v18);
      if ( sub_8D94(a3, a1) )
        return _stack_chk_guard - v28[3];
      switch ( *(_BYTE *)(v19 + v18) )
      {
        case 'B':
          v21 = sub_2274(a1);
          goto LABEL_22;
        case 'C':
          v21 = sub_2224(a1);
          goto LABEL_22;
        case 'D':
          LODWORD(v22) = sub_2404(a1);
          *(_QWORD *)&v17[2 * v18] = v22;
          goto LABEL_23;
        case 'E':
        case 'G':
        case 'H':
        case 'K':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
          goto LABEL_33;
        case 'F':
          v21 = sub_2364(a1);
          goto LABEL_22;
        case 'I':
          v21 = sub_2314(a1);
          goto LABEL_22;
        case 'J':
          v17[2 * v18] = sub_23B4(a1);
          v17[2 * v18 + 1] = v23;
          goto LABEL_23;
        case 'L':
          if ( v20 )
          {
            v24 = sub_2160((int)v28, v20);
            v25 = *((_WORD *)v24 + 1);
            *((_BYTE *)v24 + 1) = 1;
            *((_WORD *)v24 + 1) = v25 + 1;
            v21 = v20;
          }
          else
          {
            v21 = 0;
          }
          goto LABEL_22;
        case 'S':
          v21 = sub_22C4(a1);
          goto LABEL_22;
        default:
          if ( *(_BYTE *)(v19 + v18) != 90 )
          {
LABEL_33:
            sub_8590(
              a3,
              a1,
              3,
              "Cannot handle argument type %c of `%s.%s`",
              *(unsigned __int8 *)(v19 + v18),
              *(const char **)(*(_DWORD *)(v10 + 8) + 80),
              *(const char **)(v10 + 12));
            return _stack_chk_guard - v28[3];
          }
          v21 = sub_21D4(a1);
LABEL_22:
          v17[2 * v18] = v21;
LABEL_23:
          if ( *(_BYTE *)(v19 + v18) != 76 )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)a1 + 92))(a1, v20);
          if ( sub_8D94(a3, a1) )
            return _stack_chk_guard - v28[3];
          if ( ++v18 >= *(_DWORD *)(v10 + 60) )
            goto LABEL_27;
          break;
      }
    }
  }
LABEL_27:
  sub_2CD0((_DWORD *)v10, a1, v27[0], (int)v28, a6, 0, 0);
  if ( *(_BYTE *)(a3 + 56) )
  {
    if ( &_ZTH11g_lastStack )
      ZTH11g_lastStack();
    if ( !*(_DWORD *)_emutls_get_address(&unk_14004) && (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 912))(a1) )
      sub_8D94(a3, a1);
  }
  return _stack_chk_guard - v28[3];
}
// 1A70: variable 'v22' is possibly undefined
// 1AAC: variable 'v23' is possibly undefined
// 13E0: using guessed type int ZTH11g_lastStack(void);
// 13EC: using guessed type int __fastcall _emutls_get_address(_DWORD);

//----- (00001BDC) --------------------------------------------------------
void __fastcall Java_com_xunmeng_nvwavm_NvwaVM_nwvmDestory(int a1, int a2, void *a3)
{
  if ( a3 )
  {
    sub_8634((int)a3, a1);
    j_free(a3);
  }
}

//----- (00001BF8) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callV(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  return sub_1940(a1, a5, a3, a4, a5, 0, a6, a7);
}

//----- (00001C14) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callZ(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v8[12]; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)v8, a3, a4, a5, (int)v8, a6, a7);
  return (unsigned __int8)v8[0];
}

//----- (00001C5C) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callC(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __int16 v8[6]; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)v8, a3, a4, a5, (int)v8, a6, a7);
  return (unsigned __int16)v8[0];
}

//----- (00001CA4) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callB(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v8[12]; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)v8, a3, a4, a5, (int)v8, a6, a7);
  return v8[0];
}

//----- (00001CEC) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callS(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __int16 v8[6]; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)v8, a3, a4, a5, (int)v8, a6, a7);
  return v8[0];
}

//----- (00001D34) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callI(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8[3]; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)v8, a3, a4, a5, (int)v8, a6, a7);
  return v8[0];
}

//----- (00001D7C) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callF(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8[3]; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)v8, a3, a4, a5, (int)v8, a6, a7);
  return v8[0];
}

//----- (00001DC4) --------------------------------------------------------
__int64 __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callJ(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  __int64 v8; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)&v8, a3, a4, a5, (int)&v8, a6, a7);
  return v8;
}

//----- (00001E0C) --------------------------------------------------------
__int64 __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callD(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  double v8; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)&v8, a3, a4, a5, (int)&v8, a6, a7);
  return *(_QWORD *)&v8;
}

//----- (00001E58) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callL(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int v8[3]; // [sp+10h] [bp-18h] BYREF

  sub_1940(a1, (int)v8, a3, a4, a5, (int)v8, a6, a7);
  return v8[0];
}

//----- (00001EA0) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_prepareClass(int a1, int a2, int a3, int a4, int a5)
{
  return sub_2792(*(_DWORD *)(*(_DWORD *)(a3 + 28) + 4 * a5), a1);
}

//----- (00001EB0) --------------------------------------------------------
int __fastcall Java_com_xunmeng_nvwavm_NvwaVM_callVM(int a1, int a2, _DWORD *a3, int a4, int a5, int a6)
{
  int v9; // r0
  int v10; // r4
  int v11; // r6
  int v12; // r6
  int v14; // r1
  int v15; // r4
  const char *v16; // r10
  int v17; // r9
  char *v18; // r6
  int v19; // r6
  int v20[3]; // [sp+10h] [bp-30h] BYREF

  v9 = a3[10];
  if ( v9 < 1 )
    goto LABEL_10;
  v10 = 0;
  while ( 1 )
  {
    v11 = *(_DWORD *)(a3[11] + 4 * v10);
    if ( *(_DWORD *)(v11 + 48) == a5 )
      break;
    if ( ++v10 >= v9 )
      goto LABEL_10;
  }
  if ( v10 == -1 )
  {
LABEL_10:
    sub_8D18((int)a3, a1, "[%p] callVM failed, method not found", a3);
    sub_8590((int)a3, a1, 2, "invoke method with vm_index %d failed, method not found (%d,%d)", a5, a3[10], a3[6]);
    return 0;
  }
  sub_28E0(*(_DWORD *)(v11 + 8), a1);
  if ( sub_8D94((int)a3, a1) )
    return 0;
  if ( (*(_BYTE *)(v11 + 26) & 0x20) != 0 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 28));
    sub_1940(a1, (int)v20, (int)a3, a4, v10, (int)v20, 0, a6);
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 28));
  }
  else
  {
    sub_1940(a1, (int)v20, (int)a3, a4, v10, (int)v20, 0, a6);
  }
  v14 = *(_DWORD *)(v11 + 60);
  v15 = *(unsigned __int8 *)(*(_DWORD *)(v11 + 20) + v14);
  switch ( *(_BYTE *)(*(_DWORD *)(v11 + 20) + v14) )
  {
    case 'B':
      v16 = "java/lang/Byte";
      goto LABEL_26;
    case 'C':
      v16 = "java/lang/Character";
      goto LABEL_26;
    case 'D':
      v16 = "java/lang/Double";
      goto LABEL_26;
    case 'E':
    case 'G':
    case 'H':
    case 'K':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
      goto LABEL_18;
    case 'F':
      v16 = "java/lang/Float";
      goto LABEL_26;
    case 'I':
      v16 = "java/lang/Integer";
      goto LABEL_26;
    case 'J':
      v16 = "java/lang/Long";
      goto LABEL_26;
    case 'L':
      return v20[0];
    case 'S':
      v16 = "java/lang/Short";
      goto LABEL_26;
    default:
      if ( v15 != 90 )
      {
LABEL_18:
        sub_8590((int)a3, a1, 3, "illegal return argument type %c", v15);
        return 0;
      }
      v16 = "java/lang/Boolean";
LABEL_26:
      v17 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)a1 + 24))(a1, v16);
      if ( sub_8D94((int)a3, a1) )
        return 0;
      v18 = (char *)v20 - ((strlen(v16) + 13) & 0xFFFFFFF8);
      sprintf(v18, "(%c)L%s;", v15, v16);
      v19 = (*(int (__fastcall **)(int, int, const char *, char *))(*(_DWORD *)a1 + 452))(a1, v17, "valueOf", v18);
      if ( sub_8D94((int)a3, a1) )
        return 0;
      v12 = (*(int (__fastcall **)(int, int, int, int *))(*(_DWORD *)a1 + 464))(a1, v17, v19, v20);
      if ( sub_8D94((int)a3, a1) )
        v12 = 0;
      break;
  }
  return v12;
}

//----- (00002160) --------------------------------------------------------
_DWORD *__fastcall sub_2160(int a1, int a2)
{
  _DWORD *result; // r0
  int v4; // lr
  int v5; // r4
  int v6; // r2
  int v7; // r4
  int v8; // r3
  int v9; // r5
  int v10; // r2
  bool v11; // zf

  result = 0;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = v4;
LABEL_2:
  v6 = 3 * v5;
  v7 = v5 + 1;
  v8 = 4 * v6 - 12;
  while ( v7 - 1 >= 1 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    if ( !*(_BYTE *)(v9 + v8) )
    {
      result = (_DWORD *)(v9 + v8);
      v5 = v7 - 2;
      goto LABEL_2;
    }
    v10 = v8 - 12;
    --v7;
    v11 = *(_DWORD *)(v8 + v9 + 8) == a2;
    v8 -= 12;
    if ( v11 )
      return (_DWORD *)(v9 + v10 + 12);
  }
  if ( !result )
  {
    *(_DWORD *)(a1 + 8) = v4 + 1;
    result = (_DWORD *)(*(_DWORD *)(a1 + 4) + 12 * v4);
  }
  *result = 1;
  result[1] = 0;
  result[2] = a2;
  return result;
}

//----- (000021D4) --------------------------------------------------------
int __fastcall sub_21D4(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 152))(a1);
}

//----- (00002224) --------------------------------------------------------
int __fastcall sub_2224(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 176))(a1);
}

//----- (00002274) --------------------------------------------------------
int __fastcall sub_2274(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 164))(a1);
}

//----- (000022C4) --------------------------------------------------------
int __fastcall sub_22C4(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 188))(a1);
}

//----- (00002314) --------------------------------------------------------
int __fastcall sub_2314(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 200))(a1);
}

//----- (00002364) --------------------------------------------------------
int __fastcall sub_2364(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 224))(a1);
}

//----- (000023B4) --------------------------------------------------------
int __fastcall sub_23B4(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 212))(a1);
}

//----- (00002404) --------------------------------------------------------
int __fastcall sub_2404(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 236))(a1);
}

//----- (00002454) --------------------------------------------------------
int __fastcall sub_2454(int a1, int a2)
{
  int result; // r0

  *(_WORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 12) = 0x4000;
  *(_WORD *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 28) = 1;
  memset((void *)(a1 + 32), 0, 0x38u);
  result = a1;
  *(_DWORD *)a1 = a2;
  return result;
}

//----- (00002482) --------------------------------------------------------
int __fastcall sub_2482(int *a1, unsigned int **a2)
{
  unsigned int *v4; // r0
  int v5; // r2
  unsigned int *v6; // r1
  char v7; // r8
  int v8; // r2
  unsigned int v9; // r0
  const char *v10; // r0
  char *v11; // r0
  const char *v12; // r6
  char v13; // r0
  size_t i; // r4
  unsigned int v15; // r2
  int v16; // r0
  unsigned int *v17; // r0
  int v18; // r1
  unsigned int v19; // r2
  unsigned int v20; // r6
  signed int v21; // r4
  void *v22; // r0
  signed int v23; // r0
  unsigned int v24; // r3
  int v25; // r1
  unsigned int v26; // r6
  signed int v27; // r4
  void *v28; // r0
  signed int v29; // r0
  unsigned int v30; // r3
  int v31; // r1
  unsigned int v32; // r6
  signed int v33; // r4
  void *v34; // r0
  unsigned int *v35; // r0
  signed int v36; // r1
  unsigned int v37; // t1
  unsigned int v38; // r6
  signed int v39; // r4
  void *v40; // r0
  unsigned int *v41; // r0
  signed int v42; // r1
  unsigned int v43; // t1
  unsigned int v44; // r6
  signed int v45; // r4
  void *v46; // r0
  unsigned int *v47; // r0
  signed int v48; // r1
  unsigned int v49; // t1
  unsigned int v50; // r6
  signed int v51; // r4
  void *v52; // r0
  signed int v53; // r0
  unsigned int v54; // r2

  v4 = *a2;
  *a2 = (unsigned int *)((char *)*a2 + 1);
  v5 = *a1;
  v6 = (unsigned int *)((char *)v4 + 5);
  v7 = *(_BYTE *)v4;
  *((_BYTE *)a1 + 28) = (*(_BYTE *)v4 & 2) != 0;
  *((_BYTE *)a1 + 17) = (v7 & 2) != 0;
  v8 = *(_DWORD *)(v5 + 12);
  v9 = bswap32(*(unsigned int *)((char *)v4 + 1));
  *a2 = v6;
  v10 = *(const char **)(v8 + 4 * v9);
  a1[20] = (int)v10;
  v11 = strdup(v10);
  v12 = v11;
  a1[21] = (int)v11;
  if ( v11 )
  {
    v13 = *v11;
    if ( *v12 )
    {
      for ( i = 1; ; ++i )
      {
        if ( v13 == 47 )
        {
          v12[i - 1] = 46;
          v12 = (const char *)a1[21];
        }
        if ( i >= strlen(v12) )
          break;
        v13 = v12[i];
      }
    }
  }
  if ( (v7 & 4) != 0 )
    *a2 = (unsigned int *)((char *)*a2 + bswap32(**a2) + 4);
  if ( !*((_BYTE *)a1 + 17) )
    return 1;
  v15 = **a2;
  v16 = *(_DWORD *)(*a1 + 28);
  ++*a2;
  a1[1] = *(_DWORD *)(v16 + 4 * bswap32(v15));
  v17 = *a2;
  v18 = (int)(*a2 + 1);
  v19 = *(unsigned __int16 *)*a2;
  *a2 = (unsigned int *)((char *)*a2 + 2);
  *((_WORD *)a1 + 4) = bswap32(v19) >> 16;
  v20 = *((unsigned __int16 *)v17 + 1);
  *a2 = (unsigned int *)v18;
  v21 = bswap32(v20) >> 16;
  a1[8] = v21;
  v22 = malloc(4 * v21);
  a1[9] = (int)v22;
  if ( v22 )
  {
    if ( v20 << 16 )
    {
      v23 = 0;
      do
      {
        v24 = **a2;
        v25 = *(_DWORD *)(*a1 + 28);
        ++*a2;
        *(_DWORD *)(a1[9] + 4 * v23++) = *(_DWORD *)(v25 + 4 * bswap32(v24));
      }
      while ( v23 < v21 );
    }
    v26 = *(unsigned __int16 *)*a2;
    *a2 = (unsigned int *)((char *)*a2 + 2);
    v27 = bswap32(v26) >> 16;
    a1[10] = v27;
    v28 = malloc(4 * v27);
    a1[11] = (int)v28;
    if ( v28 )
    {
      if ( v26 << 16 )
      {
        v29 = 0;
        do
        {
          v30 = **a2;
          v31 = *(_DWORD *)(*a1 + 28);
          ++*a2;
          *(_DWORD *)(a1[11] + 4 * v29++) = *(_DWORD *)(v31 + 4 * bswap32(v30));
        }
        while ( v29 < v27 );
      }
      v32 = *(unsigned __int16 *)*a2;
      *a2 = (unsigned int *)((char *)*a2 + 2);
      v33 = bswap32(v32) >> 16;
      a1[12] = v33;
      v34 = malloc(4 * v33);
      a1[13] = (int)v34;
      if ( v34 )
      {
        v35 = *a2;
        if ( v32 << 16 )
        {
          v36 = 0;
          do
          {
            v37 = *v35;
            *a2 = v35 + 1;
            *(_DWORD *)(a1[13] + 4 * v36++) = bswap32(v37);
            v35 = *a2;
          }
          while ( v36 < v33 );
        }
        v38 = *(unsigned __int16 *)v35;
        *a2 = (unsigned int *)((char *)v35 + 2);
        v39 = bswap32(v38) >> 16;
        a1[14] = v39;
        v40 = malloc(4 * v39);
        a1[15] = (int)v40;
        if ( v40 )
        {
          v41 = *a2;
          if ( v38 << 16 )
          {
            v42 = 0;
            do
            {
              v43 = *v41;
              *a2 = v41 + 1;
              *(_DWORD *)(a1[15] + 4 * v42++) = bswap32(v43);
              v41 = *a2;
            }
            while ( v42 < v39 );
          }
          v44 = *(unsigned __int16 *)v41;
          *a2 = (unsigned int *)((char *)v41 + 2);
          v45 = bswap32(v44) >> 16;
          a1[16] = v45;
          v46 = malloc(4 * v45);
          a1[17] = (int)v46;
          if ( v46 )
          {
            v47 = *a2;
            if ( v44 << 16 )
            {
              v48 = 0;
              do
              {
                v49 = *v47;
                *a2 = v47 + 1;
                *(_DWORD *)(a1[17] + 4 * v48++) = bswap32(v49);
                v47 = *a2;
              }
              while ( v48 < v45 );
            }
            v50 = *(unsigned __int16 *)v47;
            *a2 = (unsigned int *)((char *)v47 + 2);
            v51 = bswap32(v50) >> 16;
            a1[18] = v51;
            v52 = malloc(4 * v51);
            a1[19] = (int)v52;
            if ( v52 )
            {
              if ( v50 << 16 )
              {
                v53 = 0;
                do
                {
                  v54 = *(*a2)++;
                  *(_DWORD *)(a1[19] + 4 * v53++) = bswap32(v54);
                }
                while ( v53 < v51 );
              }
              if ( (v7 & 8) != 0 )
                *a2 = (unsigned int *)((char *)*a2 + bswap32(**a2) + 4);
              return 1;
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (000026DE) --------------------------------------------------------
_DWORD *__fastcall sub_26DE(_DWORD *result)
{
  int v1; // r12
  int v2; // r2
  int i; // r3
  int v4; // r12
  int v5; // r2
  int j; // r3

  v1 = result[12];
  if ( v1 >= 1 )
  {
    v2 = result[13];
    for ( i = 0; i < v1; ++i )
    {
      *(_DWORD *)(v2 + 4 * i) = *(_DWORD *)(*(_DWORD *)(*result + 36) + 4 * *(_DWORD *)(v2 + 4 * i));
      v2 = result[13];
      *(_DWORD *)(*(_DWORD *)(v2 + 4 * i) + 24) = i;
    }
  }
  v4 = result[14];
  if ( v4 >= 1 )
  {
    v5 = result[15];
    for ( j = 0; j < v4; ++j )
    {
      *(_DWORD *)(v5 + 4 * j) = *(_DWORD *)(*(_DWORD *)(*result + 36) + 4 * *(_DWORD *)(v5 + 4 * j));
      v5 = result[15];
      *(_DWORD *)(*(_DWORD *)(v5 + 4 * j) + 24) = j;
    }
  }
  return result;
}

//----- (0000273E) --------------------------------------------------------
_DWORD *__fastcall sub_273E(_DWORD *result)
{
  int v1; // r12
  int i; // r2
  int v3; // r12
  int j; // r2

  v1 = result[16];
  if ( v1 >= 1 )
  {
    for ( i = 0; i < v1; ++i )
      *(_DWORD *)(result[17] + 4 * i) = *(_DWORD *)(*(_DWORD *)(*result + 44) + 4 * *(_DWORD *)(result[17] + 4 * i));
  }
  v3 = result[18];
  if ( v3 >= 1 )
  {
    for ( j = 0; j < v3; ++j )
      *(_DWORD *)(result[19] + 4 * j) = *(_DWORD *)(*(_DWORD *)(*result + 44) + 4 * *(_DWORD *)(result[19] + 4 * j));
  }
  return result;
}

//----- (00002792) --------------------------------------------------------
int __fastcall sub_2792(int a1, int a2)
{
  pthread_mutex_t *v3; // r8
  int v5; // r4
  size_t v6; // r0
  int i; // r2
  int v8; // r3
  int v9; // r5
  int j; // r2
  int v11; // r3
  _DWORD *v12; // r10
  int v13; // r11
  int v14; // r5
  int v15; // r4
  int v16; // r0
  int v17; // r1
  char *v18; // r1
  int v19; // r5
  int v20; // r4
  int v21; // r0
  int v22; // r1
  char *v23; // r1
  int v24; // r4

  v3 = (pthread_mutex_t *)(a1 + 12);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  if ( *(_BYTE *)(a1 + 28) )
  {
    v5 = *(_DWORD *)(a1 + 64);
    if ( v5 < 1 )
    {
      v6 = 0;
    }
    else
    {
      v6 = 0;
      for ( i = 0; i < v5; ++i )
      {
        v8 = *(_DWORD *)(*(_DWORD *)(a1 + 68) + 4 * i);
        v6 += *(unsigned __int8 *)(v8 + 80);
      }
    }
    v9 = *(_DWORD *)(a1 + 72);
    if ( v9 >= 1 )
    {
      for ( j = 0; j < v9; ++j )
      {
        v11 = *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4 * j);
        v6 += *(unsigned __int8 *)(v11 + 80);
      }
    }
    if ( v6 )
    {
      v12 = calloc(v6, 0xCu);
      v13 = 0;
      if ( v5 >= 1 )
      {
        v14 = 0;
        do
        {
          v15 = *(_DWORD *)(*(_DWORD *)(a1 + 68) + 4 * v14);
          if ( *(_BYTE *)(v15 + 80) )
          {
            v16 = sub_77C0(*(_DWORD *)(*(_DWORD *)(a1 + 68) + 4 * v14), a2);
            if ( v16 )
            {
              v17 = 3 * v13++;
              v12[v17] = *(_DWORD *)(v15 + 12);
              v18 = (char *)&v12[v17];
              *((_DWORD *)v18 + 2) = v16;
              *((_DWORD *)v18 + 1) = *(_DWORD *)(v15 + 16);
            }
          }
          ++v14;
        }
        while ( v14 < *(_DWORD *)(a1 + 64) );
        v9 = *(_DWORD *)(a1 + 72);
      }
      if ( v9 >= 1 )
      {
        v19 = 0;
        do
        {
          v20 = *(_DWORD *)(*(_DWORD *)(a1 + 76) + 4 * v19);
          if ( *(_BYTE *)(v20 + 80) )
          {
            v21 = sub_77C0(*(_DWORD *)(*(_DWORD *)(a1 + 76) + 4 * v19), a2);
            if ( v21 )
            {
              v22 = 3 * v13++;
              v12[v22] = *(_DWORD *)(v20 + 12);
              v23 = (char *)&v12[v22];
              *((_DWORD *)v23 + 2) = v21;
              *((_DWORD *)v23 + 1) = *(_DWORD *)(v20 + 16);
            }
          }
          ++v19;
        }
        while ( v19 < *(_DWORD *)(a1 + 72) );
      }
      if ( v13 > 0 )
      {
        v24 = sub_28E0(a1, a2);
        if ( !(*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
        {
          (*(void (__fastcall **)(int, int, _DWORD *, int))(*(_DWORD *)a2 + 860))(a2, v24, v12, v13);
          if ( (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
            (*(void (__fastcall **)(int))(*(_DWORD *)a2 + 68))(a2);
          else
            *(_BYTE *)(a1 + 28) = 0;
        }
      }
      free(v12);
    }
    else
    {
      *(_BYTE *)(a1 + 28) = 0;
    }
  }
  return j_pthread_mutex_unlock(v3);
}

//----- (000028E0) --------------------------------------------------------
int __fastcall sub_28E0(int a1, int a2)
{
  int *v4; // r5
  int v5; // r6
  int *v6; // r10
  int *v7; // r0
  int v8; // r11
  int v9; // r0

  v4 = (int *)(a1 + 20);
  v5 = *(_DWORD *)(a1 + 20);
  if ( !v5 )
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
    v6 = (int *)(a1 + 24);
    v7 = (int *)(a1 + 24);
    if ( *(_DWORD *)(a1 + 20) )
      v7 = v4;
    v5 = *v7;
    if ( !*v7 )
    {
      v8 = *(unsigned __int8 *)(a1 + 16);
      if ( *(_BYTE *)(a1 + 16) )
        *(_BYTE *)(a1 + 16) = 0;
      v5 = sub_8E98(*(_DWORD *)a1, a2, *(char **)(a1 + 80));
      v9 = (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2);
      if ( v5 && !v9 )
      {
        if ( !*v6 )
        {
          *(_DWORD *)(a1 + 24) = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 84))(a2, v5);
          sub_2792(a1, a2);
        }
        (*(void (__fastcall **)(int, int))(*(_DWORD *)a2 + 92))(a2, v5);
        v5 = *v6;
      }
      if ( v8 )
        *v4 = v5;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 12));
  }
  return v5;
}

//----- (00002984) --------------------------------------------------------
int __fastcall sub_2984(int a1, int a2)
{
  pthread_mutex_t *v3; // r4

  v3 = (pthread_mutex_t *)(a1 + 12);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 12));
  if ( *(_DWORD *)(a1 + 20) )
  {
    *(_DWORD *)(a1 + 20) = 0;
    (*(void (__fastcall **)(int))(*(_DWORD *)a2 + 88))(a2);
  }
  return j_pthread_mutex_unlock(v3);
}

//----- (000029B8) --------------------------------------------------------
_DWORD *__fastcall sub_29B8(_DWORD *a1)
{
  void *v2; // r0
  void *v3; // r0
  void *v4; // r0
  void *v5; // r0
  void *v6; // r0
  void *v7; // r0
  void *v8; // r0

  v2 = (void *)a1[9];
  if ( v2 )
    free(v2);
  v3 = (void *)a1[11];
  if ( v3 )
    free(v3);
  v4 = (void *)a1[13];
  if ( v4 )
    free(v4);
  v5 = (void *)a1[15];
  if ( v5 )
    free(v5);
  v6 = (void *)a1[17];
  if ( v6 )
    free(v6);
  v7 = (void *)a1[19];
  if ( v7 )
    free(v7);
  v8 = (void *)a1[21];
  if ( v8 )
    free(v8);
  return a1;
}

//----- (000029FA) --------------------------------------------------------
int __fastcall sub_29FA(int a1, int a2, unsigned int **a3)
{
  size_t v5; // r6
  unsigned int *v7; // r0
  unsigned int *v8; // r1
  unsigned int v9; // r9
  unsigned int v10; // r0
  int v11; // r2
  unsigned int v12; // r1
  int v13; // r2
  unsigned int v14; // r1
  int v15; // r1
  unsigned int v16; // r2
  const char *v17; // r0
  unsigned int *v18; // r0
  int v19; // r1
  unsigned int v20; // r2
  unsigned int v21; // r2
  unsigned int v22; // r2
  unsigned int v23; // r2
  unsigned int v24; // r0
  signed int v25; // r6
  char *v26; // r0
  int v27; // r1
  int v28; // r2
  unsigned int v29; // r4
  char *v30; // r0
  unsigned int v31; // r4
  unsigned int v32; // r4
  unsigned int v33; // r3
  int v34; // r3
  unsigned int v35; // r1
  size_t v36; // r6
  unsigned int *v37; // r0
  unsigned int *v38; // r8

  v5 = 0;
  *(_BYTE *)(a1 + 4) = 0;
  memset((void *)(a1 + 8), 0, 0x11u);
  memset((void *)(a1 + 26), 0, 0x16u);
  *(_DWORD *)(a1 + 48) = -1;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 92) = 0;
  memset((void *)(a1 + 52), 0, 0x1Du);
  *(_DWORD *)a1 = a2;
  v7 = *a3;
  *a3 = (unsigned int *)((char *)*a3 + 1);
  v8 = (unsigned int *)((char *)v7 + 5);
  v9 = *(unsigned __int8 *)v7;
  *(_BYTE *)(a1 + 24) = v9 & 1;
  *(_BYTE *)(a1 + 80) = (v9 & 0x10) != 0;
  *(_BYTE *)(a1 + 4) = (v9 & 2) != 0;
  v10 = *(unsigned int *)((char *)v7 + 1);
  *a3 = v8;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4 * bswap32(v10));
  v11 = *(_DWORD *)(a2 + 12);
  v12 = *(*a3)++;
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(v11 + 4 * bswap32(v12));
  v13 = *(_DWORD *)(a2 + 12);
  v14 = *(*a3)++;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v13 + 4 * bswap32(v14));
  v15 = *(_DWORD *)(a2 + 12);
  v16 = *(*a3)++;
  v17 = *(const char **)(v15 + 4 * bswap32(v16));
  *(_DWORD *)(a1 + 20) = v17;
  if ( v17 )
    v5 = strlen(v17) - 1;
  *(_DWORD *)(a1 + 60) = v5;
  if ( (v9 & 4) != 0 )
    *a3 = (unsigned int *)((char *)*a3 + bswap32(**a3) + 4);
  if ( ((v9 >> 1) & 1) != 0 )
  {
    v18 = *a3;
    v19 = (int)(*a3 + 4);
    v20 = *(unsigned __int16 *)*a3;
    *a3 = (unsigned int *)((char *)*a3 + 2);
    *(_WORD *)(a1 + 26) = bswap32(v20) >> 16;
    v21 = *(unsigned int *)((char *)v18 + 2);
    *a3 = (unsigned int *)((char *)v18 + 6);
    *(_DWORD *)(a1 + 52) = bswap32(v21);
    v22 = *(unsigned int *)((char *)v18 + 6);
    *a3 = (unsigned int *)((char *)v18 + 10);
    *(_DWORD *)(a1 + 56) = bswap32(v22);
    v23 = *(unsigned int *)((char *)v18 + 10);
    *a3 = (unsigned int *)((char *)v18 + 14);
    *(_DWORD *)(a1 + 48) = bswap32(v23);
    v24 = *((unsigned __int16 *)v18 + 7);
    *a3 = (unsigned int *)v19;
    v25 = __rev16(v24);
    *(_DWORD *)(a1 + 64) = v25;
    if ( v24 )
    {
      v26 = (char *)calloc(v25, 0x10u);
      v27 = 1;
      v28 = 0;
      *(_DWORD *)(a1 + 68) = v26;
      while ( 1 )
      {
        v29 = *(*a3)++;
        *(_DWORD *)&v26[v28] = bswap32(v29);
        v30 = &v26[v28];
        v31 = *(*a3)++;
        *((_DWORD *)v30 + 1) = bswap32(v31);
        v32 = *(*a3)++;
        *((_DWORD *)v30 + 2) = bswap32(v32);
        v33 = *(*a3)++;
        v34 = v33 == -1 ? 0 : *(_DWORD *)(*(_DWORD *)(a2 + 28) + 4 * bswap32(v33));
        *((_DWORD *)v30 + 3) = v34;
        if ( v27 >= v25 )
          break;
        v28 += 16;
        v26 = *(char **)(a1 + 68);
        ++v27;
      }
    }
    v35 = *(*a3)++;
    v36 = bswap32(v35);
    v37 = (unsigned int *)malloc(v36);
    *(_DWORD *)(a1 + 72) = v37;
    v38 = *a3;
    qmemcpy(v37, *a3, v36);
    *a3 = (unsigned int *)((char *)v38 + v36);
    if ( (v9 & 8) != 0 )
      *a3 = (unsigned int *)((char *)v38 + v36 + bswap32(*(unsigned int *)((char *)v38 + v36)) + 4);
  }
  return a1;
}

//----- (00002BD0) --------------------------------------------------------
int __fastcall sub_2BD0(int a1, int a2)
{
  int result; // r0
  int v5; // r6
  __int64 v6; // r2
  int v7; // r0
  int v8; // r0

  result = *(_DWORD *)(a1 + 76);
  if ( !result )
  {
    v5 = sub_28E0(*(_DWORD *)(a1 + 8), a2);
    if ( (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2)
      || ((v6 = *(_QWORD *)(a1 + 12), v7 = *(_DWORD *)a2, *(_BYTE *)(a1 + 24)) ? (v8 = (*(int (__fastcall **)(int, int, _DWORD, _DWORD))(v7 + 452))(
                                                                                         a2,
                                                                                         v5,
                                                                                         v6,
                                                                                         HIDWORD(v6))) : (v8 = (*(int (__fastcall **)(int, int, _DWORD, _DWORD))(v7 + 132))(a2, v5, v6, HIDWORD(v6))),
          *(_DWORD *)(a1 + 76) = v8,
          (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2)) )
    {
      result = 0;
    }
    else
    {
      result = *(_DWORD *)(a1 + 76);
    }
  }
  return result;
}

//----- (00002C2A) --------------------------------------------------------
int __fastcall sub_2C2A(int result, int a2, char *a3, int a4)
{
  int *v7; // r4
  int v8; // r6

  v7 = (int *)result;
  if ( a3 )
  {
    result = (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2);
    if ( !result )
    {
      v8 = sub_8E98(*v7, a2, a3);
      result = (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2);
      if ( !result )
        result = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)a2 + 56))(a2, v8, a4);
    }
  }
  return result;
}

//----- (00002C7C) --------------------------------------------------------
int __fastcall sub_2C7C(int a1, int a2, int a3, void (__fastcall *a4)(void *))
{
  int v4; // r1
  _DWORD v6[2]; // [sp+4h] [bp-1Ch] BYREF
  unsigned int v7; // [sp+Ch] [bp-14h] BYREF
  int v8[4]; // [sp+10h] [bp-10h] BYREF

  v6[0] = a1;
  v6[1] = a2;
  v4 = *(_DWORD *)(a1 + 32);
  __dmb(0xBu);
  if ( v4 != -1 )
  {
    v8[0] = (int)v6;
    v7 = (unsigned int)v8;
    std::__call_once((std::__ndk1 *)(a1 + 32), &v7, sub_7A54, a4);
  }
  return _stack_chk_guard - v8[1];
}
// 7A54: using guessed type int sub_7A54();

//----- (00002CD0) --------------------------------------------------------
int __fastcall sub_2CD0(_DWORD *a1, int a2, int a3, int a4, int a5, char a6, unsigned int a7)
{
  int v10; // r2
  void (__fastcall *v11)(void *); // r3
  int v12; // r0
  int v13; // r0
  int v14; // r6
  int v15; // r5
  size_t v16; // r4
  int v17; // r0
  int (*v18)(); // r1
  int (*v19)(); // r1
  int (*v20)(); // r2
  __int64 v21; // r0
  int v23; // [sp+8h] [bp-A8h] BYREF
  char *v24; // [sp+10h] [bp-A0h]
  int v25; // [sp+18h] [bp-98h]
  size_t v26; // [sp+1Ch] [bp-94h]
  _DWORD *v27; // [sp+20h] [bp-90h]
  void *v28; // [sp+24h] [bp-8Ch]
  void *v29; // [sp+28h] [bp-88h]
  void *v30; // [sp+2Ch] [bp-84h]
  void *v31; // [sp+30h] [bp-80h]
  bool v32; // [sp+58h] [bp-58h] BYREF
  _DWORD *v33; // [sp+5Ch] [bp-54h]
  int *v34; // [sp+60h] [bp-50h]
  int v35; // [sp+64h] [bp-4Ch]
  int v36[3]; // [sp+74h] [bp-3Ch] BYREF

  v34 = v36;
  v33 = a1;
  v32 = (a6 & 1) == 0;
  if ( &_ZTH11g_lastStack )
    ZTH11g_lastStack();
  v35 = *(_DWORD *)_emutls_get_address(&unk_14004);
  if ( a7 <= 1 )
  {
    v13 = a1[9];
    if ( v13 == 1 )
      goto LABEL_10;
    if ( !v13 )
    {
      sub_2C7C((int)a1, a2, v10, v11);
      v13 = a1[9];
    }
    if ( v13 != 2 )
    {
LABEL_10:
      v14 = a3;
      v15 = a1[11];
      v36[0] = v15;
      v16 = a1[14];
      v24 = (char *)&v23 - ((v16 + 7) & 0xFFFFFFF8);
      memset(v24, 0, v16);
      v25 = v14;
      v26 = v14 + 8 * v16;
      if ( &_ZTH11g_lastStack )
      {
        ZTH11g_lastStack();
        v15 = v36[0];
      }
      *(_DWORD *)_emutls_get_address(&unk_14004) = &v32;
      v17 = *(_DWORD *)(v15 + 24);
      v27 = a1;
      v30 = &loc_47E6;
      v28 = &loc_47E6;
      v31 = &loc_47E6;
      v29 = &loc_47E6;
      __asm { MOV             PC, R0 }
    }
  }
  else
  {
    switch ( *(_DWORD *)a7 )
    {
      case 0:
        v12 = 0;
        break;
      case 1:
        v18 = (int (*)())&loc_4800;
        goto LABEL_231;
      case 2:
        v18 = (int (*)())&loc_4820;
        goto LABEL_231;
      case 3:
        v18 = (int (*)())&loc_4820;
        goto LABEL_231;
      case 4:
        v18 = (int (*)())&loc_4820;
        goto LABEL_231;
      case 5:
        v18 = (int (*)())&loc_4820;
        goto LABEL_231;
      case 6:
        v18 = (int (*)())&loc_4820;
        goto LABEL_231;
      case 7:
        v18 = (int (*)())&loc_4820;
        goto LABEL_231;
      case 8:
        v18 = (int (*)())&loc_488E;
        goto LABEL_231;
      case 9:
        v19 = (int (*)())&loc_4842;
        v20 = sub_7354;
        goto LABEL_221;
      case 0xA:
        v18 = (int (*)())&loc_48D6;
        goto LABEL_231;
      case 0xB:
        v18 = (int (*)())&loc_4942;
        goto LABEL_231;
      case 0xC:
        v18 = (int (*)())&loc_48D6;
        goto LABEL_231;
      case 0xD:
        v18 = (int (*)())&loc_4942;
        goto LABEL_231;
      case 0xE:
        v18 = (int (*)())&loc_48FE;
        goto LABEL_231;
      case 0xF:
        v18 = (int (*)())&loc_4970;
        goto LABEL_231;
      case 0x10:
        v18 = (int (*)())&loc_49AE;
        goto LABEL_231;
      case 0x11:
        v18 = (int (*)())&loc_49D4;
        goto LABEL_231;
      case 0x12:
        v18 = (int (*)())&loc_49FA;
        goto LABEL_231;
      case 0x13:
        v18 = (int (*)())&loc_4A20;
        goto LABEL_231;
      case 0x14:
        v18 = (int (*)())&loc_4A72;
        goto LABEL_231;
      case 0x15:
        v18 = (int (*)())&loc_4ADC;
        goto LABEL_231;
      case 0x16:
        v18 = (int (*)())&loc_4B30;
        goto LABEL_231;
      case 0x17:
        v18 = (int (*)())&loc_4B8C;
        goto LABEL_231;
      case 0x18:
        v18 = (int (*)())&loc_4C42;
        goto LABEL_231;
      case 0x19:
        v18 = (int (*)())&loc_4B8C;
        goto LABEL_231;
      case 0x1A:
        v18 = (int (*)())&loc_4C42;
        goto LABEL_231;
      case 0x1B:
        v18 = (int (*)())&loc_4BD2;
        goto LABEL_231;
      case 0x1C:
        v18 = (int (*)())&loc_4C90;
        goto LABEL_231;
      case 0x1D:
        v18 = (int (*)())&loc_4CD4;
        goto LABEL_231;
      case 0x1E:
        v18 = (int (*)())&loc_4CFA;
        goto LABEL_231;
      case 0x1F:
        v18 = (int (*)())&loc_4D20;
        goto LABEL_231;
      case 0x20:
        v18 = (int (*)())&loc_4D44;
        goto LABEL_231;
      case 0x21:
        v18 = (int (*)())&loc_4D7A;
        goto LABEL_231;
      case 0x22:
        v18 = (int (*)())&loc_4DE2;
        goto LABEL_231;
      case 0x23:
        v18 = (int (*)())&loc_4E04;
        goto LABEL_231;
      case 0x24:
        v18 = (int (*)())&loc_4E3A;
        goto LABEL_231;
      case 0x25:
        v18 = (int (*)())&loc_4E66;
        goto LABEL_231;
      case 0x26:
        v18 = (int (*)())&loc_4EC8;
        goto LABEL_231;
      case 0x27:
        v18 = (int (*)())&loc_4F02;
        goto LABEL_231;
      case 0x28:
        v18 = (int (*)())&loc_4F48;
        goto LABEL_231;
      case 0x29:
        v18 = (int (*)())&loc_4F9A;
        goto LABEL_231;
      case 0x2A:
        v18 = (int (*)())&loc_500C;
        goto LABEL_231;
      case 0x2B:
        v18 = (int (*)())&loc_5086;
        goto LABEL_231;
      case 0x2C:
        v18 = (int (*)())&loc_512E;
        goto LABEL_231;
      case 0x2D:
        v18 = (int (*)())&loc_5154;
        goto LABEL_231;
      case 0x2E:
        v18 = (int (*)())&loc_517C;
        goto LABEL_231;
      case 0x2F:
        v18 = (int (*)())&loc_51AA;
        goto LABEL_231;
      case 0x30:
        v18 = (int (*)())&loc_51D6;
        goto LABEL_231;
      case 0x31:
        v18 = (int (*)())&loc_5202;
        goto LABEL_231;
      case 0x32:
        v18 = (int (*)())&loc_522A;
        goto LABEL_231;
      case 0x33:
        v18 = (int (*)())&loc_5258;
        goto LABEL_231;
      case 0x34:
        v18 = (int (*)())&loc_5284;
        goto LABEL_231;
      case 0x35:
        v18 = (int (*)())&loc_52B0;
        goto LABEL_231;
      case 0x36:
        v18 = (int (*)())&loc_52D8;
        goto LABEL_231;
      case 0x37:
        v18 = (int (*)())&loc_5310;
        goto LABEL_231;
      case 0x38:
        v18 = (int (*)())&loc_533C;
        goto LABEL_231;
      case 0x39:
        v18 = (int (*)())&loc_5368;
        goto LABEL_231;
      case 0x3A:
        v18 = (int (*)())&loc_53A2;
        goto LABEL_231;
      case 0x3B:
        v18 = (int (*)())&loc_53DE;
        goto LABEL_231;
      case 0x3C:
        v18 = (int (*)())&loc_540A;
        goto LABEL_231;
      case 0x3D:
        v18 = (int (*)())&loc_5436;
        goto LABEL_231;
      case 0x3E:
        v18 = (int (*)())&loc_546C;
        goto LABEL_231;
      case 0x3F:
        v18 = (int (*)())&loc_54B0;
        goto LABEL_231;
      case 0x40:
        v18 = (int (*)())&loc_54DA;
        goto LABEL_231;
      case 0x41:
        v18 = (int (*)())&loc_5512;
        goto LABEL_231;
      case 0x42:
        v18 = (int (*)())&loc_5536;
        goto LABEL_231;
      case 0x43:
        v18 = (int (*)())&loc_5560;
        goto LABEL_231;
      case 0x44:
        v18 = (int (*)())&loc_5586;
        goto LABEL_231;
      case 0x45:
        v18 = (int (*)())&loc_55AC;
        goto LABEL_231;
      case 0x46:
        v18 = (int (*)())&loc_55DA;
        goto LABEL_231;
      case 0x47:
        v18 = (int (*)())&loc_562C;
        goto LABEL_231;
      case 0x48:
        v18 = (int (*)())&loc_565A;
        goto LABEL_231;
      case 0x49:
        v18 = (int (*)())&loc_56B2;
        goto LABEL_231;
      case 0x4A:
        v18 = (int (*)())&loc_56E0;
        goto LABEL_231;
      case 0x4B:
        v18 = (int (*)())&loc_5738;
        goto LABEL_231;
      case 0x4C:
        v18 = (int (*)())&loc_5760;
        goto LABEL_231;
      case 0x4D:
        v18 = (int (*)())&loc_578E;
        goto LABEL_231;
      case 0x4E:
        v18 = (int (*)())&loc_57B6;
        goto LABEL_231;
      case 0x4F:
        v18 = (int (*)())&loc_57E4;
        goto LABEL_231;
      case 0x50:
        v18 = (int (*)())&loc_580C;
        goto LABEL_231;
      case 0x51:
        v18 = (int (*)())&loc_583A;
        goto LABEL_231;
      case 0x52:
        v18 = (int (*)())&loc_5866;
        goto LABEL_231;
      case 0x53:
        v18 = (int (*)())&loc_588A;
        goto LABEL_231;
      case 0x54:
        v18 = (int (*)())&loc_58B0;
        goto LABEL_231;
      case 0x55:
        v18 = (int (*)())&loc_58D6;
        goto LABEL_231;
      case 0x56:
        v18 = (int (*)())&loc_58F0;
        goto LABEL_231;
      case 0x57:
        v18 = (int (*)())&loc_5916;
        goto LABEL_231;
      case 0x58:
        v18 = (int (*)())&loc_5940;
        goto LABEL_231;
      case 0x59:
        v18 = (int (*)())&loc_5966;
        goto LABEL_231;
      case 0x5A:
        v18 = (int (*)())&loc_598C;
        goto LABEL_231;
      case 0x5B:
        v18 = (int (*)())&loc_59B2;
        goto LABEL_231;
      case 0x5C:
        v18 = (int (*)())&loc_59D8;
        goto LABEL_231;
      case 0x5D:
        v18 = (int (*)())&loc_5A02;
        goto LABEL_231;
      case 0x5E:
        v18 = (int (*)())&loc_5A28;
        goto LABEL_231;
      case 0x5F:
        v18 = (int (*)())&loc_5A4A;
        goto LABEL_231;
      case 0x60:
        v18 = (int (*)())&loc_5A6C;
        goto LABEL_231;
      case 0x61:
        v18 = (int (*)())&loc_5A8E;
        goto LABEL_231;
      case 0x62:
        v18 = (int (*)())&loc_5AE0;
        goto LABEL_231;
      case 0x63:
        v18 = (int (*)())&loc_5AE0;
        goto LABEL_231;
      case 0x64:
        v18 = (int (*)())&loc_5B56;
        goto LABEL_231;
      case 0x65:
        v18 = (int (*)())&loc_5B56;
        goto LABEL_231;
      case 0x66:
        v18 = (int (*)())&loc_5BE8;
        goto LABEL_231;
      case 0x67:
        v18 = (int (*)())&loc_5C08;
        goto LABEL_231;
      case 0x68:
        v18 = (int (*)())&loc_5C28;
        goto LABEL_231;
      case 0x69:
        v18 = (int (*)())&loc_5C4A;
        goto LABEL_231;
      case 0x6A:
        v18 = (int (*)())&loc_5C6A;
        goto LABEL_231;
      case 0x6B:
        v18 = (int (*)())&loc_5C8A;
        goto LABEL_231;
      case 0x6C:
        v18 = (int (*)())&loc_5CAA;
        goto LABEL_231;
      case 0x6D:
        v18 = (int (*)())&loc_5CCC;
        goto LABEL_231;
      case 0x6E:
        v18 = (int (*)())&loc_5CEE;
        goto LABEL_231;
      case 0x6F:
        v18 = (int (*)())&loc_5D10;
        goto LABEL_231;
      case 0x70:
        v18 = (int (*)())&loc_5D32;
        goto LABEL_231;
      case 0x71:
        v18 = (int (*)())&loc_5D54;
        goto LABEL_231;
      case 0x72:
        v18 = (int (*)())&loc_5D74;
        goto LABEL_231;
      case 0x73:
        v18 = (int (*)())&loc_5DC6;
        goto LABEL_231;
      case 0x74:
        v18 = (int (*)())&loc_5E18;
        goto LABEL_231;
      case 0x75:
        v18 = (int (*)())&loc_5E2C;
        goto LABEL_231;
      case 0x76:
        v18 = (int (*)())&loc_5E94;
        goto LABEL_231;
      case 0x77:
        v18 = (int (*)())&loc_5ED4;
        goto LABEL_231;
      case 0x78:
        v18 = (int (*)())sub_5F3E;
        goto LABEL_231;
      case 0x79:
        v18 = (int (*)())&loc_5ED4;
        goto LABEL_231;
      case 0x7A:
        v18 = (int (*)())sub_5F3E;
        goto LABEL_231;
      case 0x7B:
        v18 = (int (*)())sub_5F7C;
        goto LABEL_231;
      case 0x7C:
        v18 = (int (*)())sub_5FBA;
        goto LABEL_231;
      case 0x7D:
        v19 = sub_61A4;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x7E:
        v19 = sub_61E4;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x7F:
        v19 = sub_6212;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x80:
        v19 = sub_6240;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x81:
        v19 = sub_626E;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x82:
        v19 = sub_629C;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x83:
        v19 = sub_62CA;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x84:
        v19 = sub_62F8;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x85:
        v19 = sub_6326;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x86:
        v19 = sub_6358;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x87:
        v19 = sub_6396;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x88:
        v19 = sub_63CC;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x89:
        v19 = sub_6402;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x8A:
        v19 = sub_6438;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x8B:
        v19 = sub_646E;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x8C:
        v19 = sub_64A4;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x8D:
        v19 = sub_64DA;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x8E:
        v19 = sub_6510;
        v20 = sub_726C;
        goto LABEL_221;
      case 0x8F:
        v19 = sub_6546;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x90:
        v19 = sub_6704;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x91:
        v19 = sub_671C;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x92:
        v19 = sub_6726;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x93:
        v19 = sub_6730;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x94:
        v19 = sub_673A;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x95:
        v19 = sub_6744;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x96:
        v19 = sub_674E;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x97:
        v19 = sub_6766;
        v20 = sub_72CC;
        goto LABEL_221;
      case 0x98:
        v19 = sub_6782;
        v20 = sub_7314;
        goto LABEL_221;
      case 0x99:
        v19 = sub_67A8;
        v20 = sub_7314;
        goto LABEL_221;
      case 0x9A:
        v19 = sub_67C6;
        v20 = sub_7314;
        goto LABEL_221;
      case 0x9B:
        v19 = sub_67D6;
        v20 = sub_7314;
        goto LABEL_221;
      case 0x9C:
        v19 = sub_67E8;
        v20 = sub_7314;
        goto LABEL_221;
      case 0x9D:
        v19 = sub_67FA;
        v20 = sub_7314;
        goto LABEL_221;
      case 0x9E:
        v19 = sub_680A;
        v20 = sub_7314;
        goto LABEL_221;
      case 0x9F:
        v19 = sub_681A;
        v20 = sub_7314;
        goto LABEL_221;
      case 0xA0:
        v19 = (int (*)())&loc_682C;
        v20 = sub_7314;
        goto LABEL_221;
      case 0xA1:
        v19 = (int (*)())sub_7468;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA2:
        v19 = sub_684A;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA3:
        v19 = (int (*)())sub_6888;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA4:
        v19 = (int (*)())sub_68A2;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA5:
        v19 = (int (*)())sub_68B0;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA6:
        v19 = (int (*)())sub_68BE;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA7:
        v19 = (int (*)())sub_68CC;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA8:
        v19 = (int (*)())sub_68DA;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xA9:
        v19 = (int (*)())sub_68E8;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xAA:
        v19 = (int (*)())sub_695A;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xAB:
        v19 = (int (*)())sub_697C;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xAC:
        v19 = (int (*)())sub_69A0;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xAD:
        v19 = (int (*)())sub_69C4;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xAE:
        v19 = (int (*)())sub_69E8;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xAF:
        v19 = (int (*)())sub_69F6;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xB0:
        v19 = (int (*)())sub_6A04;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xB1:
        v19 = (int (*)())sub_6A12;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xB2:
        v19 = (int (*)())sub_6A20;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xB3:
        v19 = (int (*)())sub_6A2E;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xB4:
        v19 = (int (*)())sub_6A52;
        v20 = sub_7388;
        goto LABEL_221;
      case 0xB5:
        v19 = (int (*)())sub_6A76;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xB6:
        v19 = (int (*)())sub_6ADA;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xB7:
        v19 = (int (*)())sub_6B1A;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xB8:
        v19 = (int (*)())sub_6B3A;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xB9:
        v19 = (int (*)())sub_6B48;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xBA:
        v19 = (int (*)())sub_6B56;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xBB:
        v19 = (int (*)())sub_6B64;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xBC:
        v19 = (int (*)())sub_6B72;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xBD:
        v19 = (int (*)())sub_6B80;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xBE:
        v19 = (int (*)())sub_6BA0;
        v20 = sub_73FC;
        goto LABEL_221;
      case 0xBF:
        v19 = (int (*)())sub_7468;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC0:
        v19 = sub_684A;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC1:
        v19 = (int (*)())sub_6888;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC2:
        v19 = (int (*)())sub_68A2;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC3:
        v19 = (int (*)())sub_68B0;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC4:
        v19 = (int (*)())sub_68BE;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC5:
        v19 = (int (*)())sub_68CC;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC6:
        v19 = (int (*)())sub_68DA;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC7:
        v19 = (int (*)())sub_68E8;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xC8:
        v19 = (int (*)())sub_695A;
        v20 = (int (*)())&loc_73B6;
        goto LABEL_221;
      case 0xCA:
        v19 = (int (*)())sub_6BC4;
        v20 = sub_7354;
        goto LABEL_221;
      case 0xCB:
        v18 = sub_6C10;
        goto LABEL_231;
      case 0xCC:
        v19 = (int (*)())&loc_6C5A;
        v20 = sub_7354;
        goto LABEL_221;
      case 0xCD:
        v18 = sub_6CBE;
        goto LABEL_231;
      case 0xCE:
        v18 = (int (*)())sub_6CFC;
        goto LABEL_231;
      case 0xCF:
        v19 = (int (*)())sub_6D24;
        v20 = sub_7354;
        goto LABEL_221;
      case 0xD0:
        v19 = (int (*)())sub_6F0C;
        v20 = sub_7354;
LABEL_221:
        HIDWORD(v21) = (char *)v19 - (char *)&loc_47E6;
        LODWORD(v21) = (char *)v20 - (char *)&loc_47E6;
        *(_QWORD *)(a7 + 24) = v21;
        return _stack_chk_guard - v36[1];
      case 0xD1:
        v18 = sub_6F4E;
        goto LABEL_231;
      case 0xD2:
        v18 = sub_6F86;
        goto LABEL_231;
      case 0xD3:
        v18 = sub_6FBE;
        goto LABEL_231;
      case 0xD4:
        v18 = sub_7050;
        goto LABEL_231;
      case 0xD5:
        v18 = (int (*)())&loc_477A;
        goto LABEL_231;
      case 0xD6:
        v18 = (int (*)())sub_70A4;
        goto LABEL_231;
      case 0xD7:
        v18 = (int (*)())sub_70A4;
        goto LABEL_231;
      case 0xD8:
        v18 = sub_6590;
        goto LABEL_231;
      case 0xD9:
        v18 = sub_6590;
LABEL_231:
        v12 = (char *)v18 - (char *)&loc_47E6;
        break;
      default:
        v12 = -1;
        break;
    }
    *(_DWORD *)(a7 + 24) = v12;
  }
  return _stack_chk_guard - v36[1];
}
// 2F0E: variable 'v10' is possibly undefined
// 2F0E: variable 'v11' is possibly undefined
// 13E0: using guessed type int ZTH11g_lastStack(void);
// 13EC: using guessed type int __fastcall _emutls_get_address(_DWORD);
// 61A4: using guessed type int sub_61A4();
// 61E4: using guessed type int sub_61E4();
// 6212: using guessed type int sub_6212();
// 6240: using guessed type int sub_6240();
// 626E: using guessed type int sub_626E();
// 629C: using guessed type int sub_629C();
// 62CA: using guessed type int sub_62CA();
// 62F8: using guessed type int sub_62F8();
// 6326: using guessed type int sub_6326();
// 6358: using guessed type int sub_6358();
// 6396: using guessed type int sub_6396();
// 63CC: using guessed type int sub_63CC();
// 6402: using guessed type int sub_6402();
// 6438: using guessed type int sub_6438();
// 646E: using guessed type int sub_646E();
// 64A4: using guessed type int sub_64A4();
// 64DA: using guessed type int sub_64DA();
// 6510: using guessed type int sub_6510();
// 6546: using guessed type int sub_6546();
// 6590: using guessed type int sub_6590();
// 6704: using guessed type int sub_6704();
// 671C: using guessed type int sub_671C();
// 6726: using guessed type int sub_6726();
// 6730: using guessed type int sub_6730();
// 673A: using guessed type int sub_673A();
// 6744: using guessed type int sub_6744();
// 674E: using guessed type int sub_674E();
// 6766: using guessed type int sub_6766();
// 6782: using guessed type int sub_6782();
// 67A8: using guessed type int sub_67A8();
// 67C6: using guessed type int sub_67C6();
// 67D6: using guessed type int sub_67D6();
// 67E8: using guessed type int sub_67E8();
// 67FA: using guessed type int sub_67FA();
// 680A: using guessed type int sub_680A();
// 681A: using guessed type int sub_681A();
// 684A: using guessed type int sub_684A();

//----- (00005F3E) --------------------------------------------------------
void sub_5F3E()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8

  *(_QWORD *)*(_DWORD *)(v1 + 8) = *(_QWORD *)(v0 - 8);
  sub_7592(v2, 0);
  if ( &_ZTH11g_lastStack )
    ZTH11g_lastStack();
  _emutls_get_address(&unk_14004);
  if ( &_ZTH11g_lastStack )
    ZTH11g_lastStack();
  JUMPOUT(0x5F0E);
}
// 5F7A: control flows out of bounds to 5F0E
// 5F40: variable 'v0' is possibly undefined
// 5F3E: variable 'v1' is possibly undefined
// 5F4C: variable 'v2' is possibly undefined
// 13E0: using guessed type int ZTH11g_lastStack(void);
// 13EC: using guessed type int __fastcall _emutls_get_address(_DWORD);

//----- (00005F7C) --------------------------------------------------------
void sub_5F7C()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8

  **(_DWORD **)(v1 + 8) = *(_DWORD *)(v0 - 8);
  sub_7592(v2, *(_DWORD *)(v0 - 8));
  if ( &_ZTH11g_lastStack )
    ZTH11g_lastStack();
  _emutls_get_address(&unk_14004);
  if ( &_ZTH11g_lastStack )
    ZTH11g_lastStack();
  JUMPOUT(0x5F0E);
}
// 5FB8: control flows out of bounds to 5F0E
// 5F7E: variable 'v0' is possibly undefined
// 5F7C: variable 'v1' is possibly undefined
// 5F8A: variable 'v2' is possibly undefined
// 13E0: using guessed type int ZTH11g_lastStack(void);
// 13EC: using guessed type int __fastcall _emutls_get_address(_DWORD);

//----- (00005FBA) --------------------------------------------------------
void sub_5FBA()
{
  _DWORD *v0; // r8

  sub_7592(v0, 0);
  if ( &_ZTH11g_lastStack )
    ZTH11g_lastStack();
  _emutls_get_address(&unk_14004);
  if ( &_ZTH11g_lastStack )
    ZTH11g_lastStack();
  JUMPOUT(0x5F0E);
}
// 5FEC: control flows out of bounds to 5F0E
// 5FBE: variable 'v0' is possibly undefined
// 13E0: using guessed type int ZTH11g_lastStack(void);
// 13EC: using guessed type int __fastcall _emutls_get_address(_DWORD);

//----- (00006888) --------------------------------------------------------
void sub_6888()
{
  int v0; // r4
  int v1; // r7
  int v2; // r10

  *(_DWORD *)(v1 - 72) = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v2 + 156))(v2, v0, *(_DWORD *)(v1 - 140));
  JUMPOUT(0x6908);
}
// 6904: control flows out of bounds to 6908
// 6888: variable 'v2' is possibly undefined
// 689E: variable 'v0' is possibly undefined
// 6894: variable 'v1' is possibly undefined

//----- (000068A2) --------------------------------------------------------
void sub_68A2()
{
  JUMPOUT(0x6894);
}
// 68AE: control flows out of bounds to 6894

//----- (000068B0) --------------------------------------------------------
void sub_68B0()
{
  JUMPOUT(0x6894);
}
// 68BC: control flows out of bounds to 6894

//----- (000068BE) --------------------------------------------------------
void sub_68BE()
{
  JUMPOUT(0x6894);
}
// 68CA: control flows out of bounds to 6894

//----- (000068CC) --------------------------------------------------------
void sub_68CC()
{
  JUMPOUT(0x6894);
}
// 68D8: control flows out of bounds to 6894

//----- (000068DA) --------------------------------------------------------
void sub_68DA()
{
  JUMPOUT(0x6894);
}
// 68E6: control flows out of bounds to 6894

//----- (000068E8) --------------------------------------------------------
void sub_68E8()
{
  int v0; // r4
  int v1; // r7
  int v2; // r10

  (*(void (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v2 + 216))(v2, v0, *(_DWORD *)(v1 - 140));
  JUMPOUT(0x6900);
}
// 68FE: control flows out of bounds to 6900
// 68E8: variable 'v2' is possibly undefined
// 68FE: variable 'v0' is possibly undefined
// 68EE: variable 'v1' is possibly undefined

//----- (0000695A) --------------------------------------------------------
void sub_695A()
{
  int v0; // r5
  int v1; // r0
  int i; // r4
  int v3; // r4
  int v4; // r6
  int v5; // r7
  int v6; // r8
  int v7; // r10

  *(_QWORD *)(v5 - 72) = ((__int64 (__fastcall *)(int, int, _DWORD))*(_DWORD *)(*(_DWORD *)v7 + 240))(
                           v7,
                           v3,
                           *(_DWORD *)(v5 - 140));
  v0 = *(_DWORD *)(v5 - 128);
  *(_DWORD *)(v5 - 124) = v3;
  sub_751C(v6);
  v1 = *(_DWORD *)(v0 + 60);
  if ( v1 >= 1 )
  {
    for ( i = 0; i < v1; ++i )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v0 + 20) + i) == 76 )
      {
        sub_751C(v6);
        v1 = *(_DWORD *)(v0 + 60);
      }
    }
  }
  if ( *(_DWORD *)(*(_DWORD *)(v5 - 60) + 16) != 1 )
    *(_QWORD *)(v4 - 8) = *(_QWORD *)(v5 - 72);
  JUMPOUT(0x6D54);
}
// 694E: control flows out of bounds to 6D54
// 695A: variable 'v7' is possibly undefined
// 6970: variable 'v3' is possibly undefined
// 6960: variable 'v5' is possibly undefined
// 6914: variable 'v6' is possibly undefined
// 6944: variable 'v4' is possibly undefined
// 751C: using guessed type int __fastcall sub_751C(_DWORD);

//----- (0000697C) --------------------------------------------------------
void sub_697C()
{
  int v0; // r5
  int v1; // r0
  int i; // r4
  int v3; // r4
  int v4; // r6
  int v5; // r7
  int v6; // r8
  int v7; // r10

  (*(void (__fastcall **)(int, int, _DWORD, _DWORD, int))(*(_DWORD *)v7 + 372))(
    v7,
    v3,
    *(_DWORD *)(v5 - 132),
    *(_DWORD *)(v5 - 140),
    v4);
  v0 = *(_DWORD *)(v5 - 128);
  *(_DWORD *)(v5 - 124) = v3;
  sub_751C(v6);
  v1 = *(_DWORD *)(v0 + 60);
  if ( v1 >= 1 )
  {
    for ( i = 0; i < v1; ++i )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v0 + 20) + i) == 76 )
      {
        sub_751C(v6);
        v1 = *(_DWORD *)(v0 + 60);
      }
    }
  }
  if ( *(_DWORD *)(*(_DWORD *)(v5 - 60) + 16) != 1 )
    *(_QWORD *)(v4 - 8) = *(_QWORD *)(v5 - 72);
  JUMPOUT(0x6D54);
}
// 694E: control flows out of bounds to 6D54
// 697C: variable 'v7' is possibly undefined
// 699A: variable 'v3' is possibly undefined
// 698A: variable 'v5' is possibly undefined
// 699A: variable 'v4' is possibly undefined
// 6914: variable 'v6' is possibly undefined
// 751C: using guessed type int __fastcall sub_751C(_DWORD);

//----- (000069A0) --------------------------------------------------------
void sub_69A0()
{
  int v0; // r4
  _DWORD *v1; // r0
  int v2; // r4
  int v3; // r6
  int v4; // r7
  int v5; // r8
  int v6; // r10

  v0 = (*(int (__fastcall **)(int, int, _DWORD, _DWORD, int))(*(_DWORD *)v6 + 264))(
         v6,
         v2,
         *(_DWORD *)(v4 - 132),
         *(_DWORD *)(v4 - 140),
         v3);
  if ( v0 )
  {
    v1 = sub_2160(v5, v0);
    ++v1[1];
  }
  else
  {
    v0 = 0;
  }
  *(_DWORD *)(v4 - 72) = v0;
  JUMPOUT(0x690C);
}
// 6886: control flows out of bounds to 690C
// 69A0: variable 'v6' is possibly undefined
// 69BE: variable 'v2' is possibly undefined
// 69AC: variable 'v4' is possibly undefined
// 69BE: variable 'v3' is possibly undefined
// 686E: variable 'v5' is possibly undefined

//----- (000069C4) --------------------------------------------------------
void sub_69C4()
{
  int v0; // r4
  int v1; // r6
  int v2; // r7
  int v3; // r10

  *(_DWORD *)(v2 - 72) = (*(int (__fastcall **)(int, int, _DWORD, _DWORD, int))(*(_DWORD *)v3 + 276))(
                           v3,
                           v0,
                           *(_DWORD *)(v2 - 132),
                           *(_DWORD *)(v2 - 140),
                           v1);
  JUMPOUT(0x6908);
}
// 6904: control flows out of bounds to 6908
// 69C4: variable 'v3' is possibly undefined
// 69E2: variable 'v0' is possibly undefined
// 69D2: variable 'v2' is possibly undefined
// 69E2: variable 'v1' is possibly undefined

//----- (000069E8) --------------------------------------------------------
void sub_69E8()
{
  JUMPOUT(0x69D0);
}
// 69F4: control flows out of bounds to 69D0

//----- (000069F6) --------------------------------------------------------
void sub_69F6()
{
  JUMPOUT(0x69D0);
}
// 6A02: control flows out of bounds to 69D0

//----- (00006A04) --------------------------------------------------------
void sub_6A04()
{
  JUMPOUT(0x69D0);
}
// 6A10: control flows out of bounds to 69D0

//----- (00006A12) --------------------------------------------------------
void sub_6A12()
{
  JUMPOUT(0x69D0);
}
// 6A1E: control flows out of bounds to 69D0

//----- (00006A20) --------------------------------------------------------
void sub_6A20()
{
  JUMPOUT(0x69D0);
}
// 6A2C: control flows out of bounds to 69D0

//----- (00006A2E) --------------------------------------------------------
void sub_6A2E()
{
  int v0; // r1
  int v1; // r4
  int v2; // r6
  int v3; // r7
  int v4; // r10

  (*(void (__fastcall **)(int, int, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 336))(
    v4,
    v1,
    *(_DWORD *)(v3 - 132),
    *(_DWORD *)(v3 - 140),
    v2);
  *(_DWORD *)(v3 - 68) = v0;
  JUMPOUT(0x6904);
}
// 6900: control flows out of bounds to 6904
// 6A2E: variable 'v4' is possibly undefined
// 6A4C: variable 'v1' is possibly undefined
// 6A3C: variable 'v3' is possibly undefined
// 6A4C: variable 'v2' is possibly undefined
// 6900: variable 'v0' is possibly undefined

//----- (00006A52) --------------------------------------------------------
void sub_6A52()
{
  int v0; // r4
  int v1; // r6
  int v2; // r7
  int v3; // r10

  (*(void (__fastcall **)(int, int, _DWORD, _DWORD, int))(*(_DWORD *)v3 + 360))(
    v3,
    v0,
    *(_DWORD *)(v2 - 132),
    *(_DWORD *)(v2 - 140),
    v1);
  JUMPOUT(0x6972);
}
// 6A74: control flows out of bounds to 6972
// 6A52: variable 'v3' is possibly undefined
// 6A70: variable 'v0' is possibly undefined
// 6A60: variable 'v2' is possibly undefined
// 6A70: variable 'v1' is possibly undefined

//----- (00006A76) --------------------------------------------------------
void sub_6A76()
{
  int v0; // r4
  _QWORD *v1; // r6
  int v2; // r7
  _DWORD *v3; // r8
  int v4; // r10
  int v5; // r5
  int v6; // r0
  int i; // r4

  (*(void (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v4 + 572))(v4, *(_DWORD *)(v2 - 132), *(_DWORD *)(v2 - 140));
  v5 = *(_DWORD *)(v2 - 128);
  *(_DWORD *)(v2 - 124) = v0;
  v6 = *(_DWORD *)(v5 + 60);
  if ( v6 >= 1 )
  {
    for ( i = 0; i < v6; ++i )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v5 + 20) + i) == 76 )
      {
        sub_751C(v3, v1[i]);
        v6 = *(_DWORD *)(v5 + 60);
      }
    }
  }
  if ( *(_DWORD *)(*(_DWORD *)(v2 - 60) + 16) != 1 )
  {
    *v1 = *(_QWORD *)(v2 - 72);
    JUMPOUT(0x6D54);
  }
  JUMPOUT(0x6AC4);
}
// 6AC2: control flows out of bounds to 6AC4
// 6AD8: control flows out of bounds to 6D54
// 6A76: variable 'v4' is possibly undefined
// 6A7C: variable 'v2' is possibly undefined
// 6A94: variable 'v0' is possibly undefined
// 6AAE: variable 'v3' is possibly undefined
// 6AA8: variable 'v1' is possibly undefined

//----- (00006ADA) --------------------------------------------------------
void sub_6ADA()
{
  int v0; // r7
  int v1; // r8
  int v2; // r10
  int v3; // r4
  _DWORD *v4; // r0

  v3 = (*(int (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v2 + 464))(
         v2,
         *(_DWORD *)(v0 - 132),
         *(_DWORD *)(v0 - 140));
  if ( v3 )
  {
    v4 = sub_2160(v1, v3);
    ++v4[1];
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)(v0 - 72) = v3;
  JUMPOUT(0x6A94);
}
// 6B18: control flows out of bounds to 6A94
// 6ADA: variable 'v2' is possibly undefined
// 6AE0: variable 'v0' is possibly undefined
// 6B00: variable 'v1' is possibly undefined

//----- (00006B1A) --------------------------------------------------------
void sub_6B1A()
{
  int v0; // r7
  int v1; // r10

  *(_DWORD *)(v0 - 72) = (*(int (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v1 + 476))(
                           v1,
                           *(_DWORD *)(v0 - 132),
                           *(_DWORD *)(v0 - 140));
  JUMPOUT(0x6A90);
}
// 6B38: control flows out of bounds to 6A90
// 6B1A: variable 'v1' is possibly undefined
// 6B26: variable 'v0' is possibly undefined

//----- (00006B3A) --------------------------------------------------------
void sub_6B3A()
{
  JUMPOUT(0x6B26);
}
// 6B46: control flows out of bounds to 6B26

//----- (00006B48) --------------------------------------------------------
void sub_6B48()
{
  JUMPOUT(0x6B26);
}
// 6B54: control flows out of bounds to 6B26

//----- (00006B56) --------------------------------------------------------
void sub_6B56()
{
  JUMPOUT(0x6B26);
}
// 6B62: control flows out of bounds to 6B26

//----- (00006B64) --------------------------------------------------------
void sub_6B64()
{
  JUMPOUT(0x6B26);
}
// 6B70: control flows out of bounds to 6B26

//----- (00006B72) --------------------------------------------------------
void sub_6B72()
{
  JUMPOUT(0x6B26);
}
// 6B7E: control flows out of bounds to 6B26

//----- (00006B80) --------------------------------------------------------
void sub_6B80()
{
  int v0; // r7
  int v1; // r10
  int v2; // r1

  (*(void (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v1 + 536))(v1, *(_DWORD *)(v0 - 132), *(_DWORD *)(v0 - 140));
  *(_DWORD *)(v0 - 68) = v2;
  JUMPOUT(0x6B34);
}
// 6B9E: control flows out of bounds to 6B34
// 6B80: variable 'v1' is possibly undefined
// 6B86: variable 'v0' is possibly undefined
// 6B9A: variable 'v2' is possibly undefined

//----- (00006BA0) --------------------------------------------------------
void sub_6BA0()
{
  int v0; // r7
  int v1; // r10

  *(_QWORD *)(v0 - 72) = ((__int64 (__fastcall *)(int, _DWORD, _DWORD))*(_DWORD *)(*(_DWORD *)v1 + 560))(
                           v1,
                           *(_DWORD *)(v0 - 132),
                           *(_DWORD *)(v0 - 140));
  JUMPOUT(0x6A90);
}
// 6BC2: control flows out of bounds to 6A90
// 6BA0: variable 'v1' is possibly undefined
// 6BA6: variable 'v0' is possibly undefined

//----- (00006BC4) --------------------------------------------------------
void __noreturn sub_6BC4()
{
  int *v0; // r6
  int v1; // r7
  int v2; // r8
  int v3; // r10
  int v4; // r4
  _DWORD *v5; // r0
  int v6; // r0

  v4 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)v3 + 108))(v3, *(_DWORD *)(v1 - 132));
  if ( v4 )
  {
    v5 = sub_2160(v2, v4);
    ++v5[1];
  }
  else
  {
    v4 = 0;
  }
  *v0 = v4;
  v6 = *(_DWORD *)(v1 - 60);
  *(_DWORD *)(v1 - 60) = v6 + 32;
  ((void (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v6 + 56)))();
}
// 6BC4: variable 'v3' is possibly undefined
// 6BCA: variable 'v1' is possibly undefined
// 6BDE: variable 'v2' is possibly undefined
// 6BF2: variable 'v0' is possibly undefined

//----- (00006C10) --------------------------------------------------------
int sub_6C10()
{
  int v0; // r4
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // r8
  _DWORD *v5; // r9
  int v6; // r10
  int v7; // r4
  _DWORD *v8; // r0
  int v9; // r0
  int v11; // r5
  int v12; // r4
  int v13; // r0
  int v14; // r1
  int v15; // r5
  int v16; // r8
  int v17; // r2
  unsigned int v18; // r1
  int v19; // r0
  int v20; // r11
  int v21; // r9
  int v22; // r0
  int v23; // r10

  *(_DWORD *)(v3 - 124) = v0;
  if ( *(int *)(v2 - 8) < 0 )
  {
    sub_2C2A((int)v5, v6, "java/lang/NegativeArraySizeException", 0);
    v11 = *(_DWORD *)(v3 - 128);
    v12 = (*(int (__fastcall **)(int))(*(_DWORD *)v6 + 60))(v6);
    if ( v12 )
    {
      (*(void (__fastcall **)(int))(*(_DWORD *)v6 + 68))(v6);
      v13 = v5[16];
      if ( v13 >= 1 )
      {
        v14 = *(_DWORD *)(v3 - 148);
        *(_DWORD *)(v3 - 128) = v11;
        v15 = 0;
        *(_DWORD *)(v3 - 168) = v4;
        v16 = 0;
        *(_DWORD *)(v3 - 156) = v6;
        *(_DWORD *)(v3 - 164) = v14 + 8;
        while ( 1 )
        {
          v17 = v5[17];
          v18 = *(_DWORD *)(v3 - 60);
          if ( v18 >= *(_DWORD *)(v17 + v15) && v18 < *(_DWORD *)(v17 + v15 + 4) )
          {
            v19 = *(_DWORD *)(v17 + v15 + 12);
            if ( !v19 )
              goto LABEL_25;
            v20 = *(_DWORD *)(v3 - 156);
            v21 = sub_28E0(v19, v20);
            if ( (*(int (__fastcall **)(int))(*(_DWORD *)v20 + 60))(v20) )
              JUMPOUT(0x6EAC);
            v22 = (*(int (__fastcall **)(int, int, int))(*(_DWORD *)v20 + 128))(v20, v12, v21);
            v5 = *(_DWORD **)(v3 - 144);
            if ( v22 )
LABEL_25:
              JUMPOUT(0x6E5C);
            v13 = v5[16];
          }
          ++v16;
          v15 += 16;
          if ( v16 >= v13 )
          {
            v23 = *(_DWORD *)(v3 - 156);
            sub_9570(v23, v12);
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v23 + 52))(v23, v12);
            switch ( *(_BYTE *)(v5[5] + v5[15]) )
            {
              case 'B':
                JUMPOUT(0x6EBC);
              case 'C':
              case 'S':
                JUMPOUT(0x6E9A);
              case 'D':
              case 'J':
                JUMPOUT(0x6EA2);
              case 'E':
              case 'G':
              case 'H':
              case 'K':
              case 'M':
              case 'N':
              case 'O':
              case 'P':
              case 'Q':
              case 'R':
                JUMPOUT(0x6EC2);
              case 'F':
              case 'I':
              case 'L':
                JUMPOUT(0x6E48);
              default:
                JUMPOUT(0x6EB8);
            }
          }
        }
      }
      JUMPOUT(0x6F08);
    }
    JUMPOUT(0x6E50);
  }
  v7 = (*(int (__fastcall **)(int))(v1 + 8))(v6);
  if ( v7 )
  {
    v8 = sub_2160(v4, v7);
    ++v8[1];
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(v2 - 8) = v7;
  v9 = *(_DWORD *)(v3 - 60);
  *(_DWORD *)(v3 - 60) = v9 + 32;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v9 + 56)))();
}
// 6E32: control flows out of bounds to 6E48
// 6E32: control flows out of bounds to 6E9A
// 6E32: control flows out of bounds to 6EA2
// 6E32: control flows out of bounds to 6EBC
// 6E32: control flows out of bounds to 6EC2
// 6E32: control flows out of bounds to 6EB8
// 6D62: control flows out of bounds to 6E50
// 6D76: control flows out of bounds to 6F08
// 6DB8: control flows out of bounds to 6E5C
// 6DD4: control flows out of bounds to 6EAC
// 6C10: variable 'v0' is possibly undefined
// 6C10: variable 'v3' is possibly undefined
// 6C14: variable 'v2' is possibly undefined
// 6C1C: variable 'v1' is possibly undefined
// 6C20: variable 'v6' is possibly undefined
// 6C2A: variable 'v4' is possibly undefined
// 6D4C: variable 'v5' is possibly undefined

//----- (00006CBE) --------------------------------------------------------
int sub_6CBE()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8
  int v3; // r10
  int v4; // r4
  int v5; // r0

  v4 = *(_DWORD *)(v0 - 8);
  if ( !v4 )
    JUMPOUT(0x4B82);
  *(_DWORD *)(v0 - 8) = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)v3 + 684))(v3, *(_DWORD *)(v0 - 8));
  sub_751C(v2, v4);
  v5 = *(_DWORD *)(v1 - 60);
  *(_DWORD *)(v1 - 60) = v5 + 32;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v5 + 56)))();
}
// 6CC4: control flows out of bounds to 4B82
// 6CBE: variable 'v0' is possibly undefined
// 6CC8: variable 'v3' is possibly undefined
// 6CDE: variable 'v2' is possibly undefined
// 6CE2: variable 'v1' is possibly undefined

//----- (00006CFC) --------------------------------------------------------
void sub_6CFC()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8
  int v3; // r10
  int v4; // r4

  v4 = *(_DWORD *)(v0 - 8);
  *(_DWORD *)(v1 - 124) = v4;
  if ( v4 )
  {
    (*(void (__fastcall **)(int, int))(*(_DWORD *)v3 + 52))(v3, v4);
    sub_751C(v2, v4);
    JUMPOUT(0x6D54);
  }
  JUMPOUT(0x4E28);
}
// 6D0A: control flows out of bounds to 4E28
// 6D22: control flows out of bounds to 6D54
// 6CFC: variable 'v0' is possibly undefined
// 6D06: variable 'v1' is possibly undefined
// 6D0E: variable 'v3' is possibly undefined
// 6D1E: variable 'v2' is possibly undefined

//----- (00006D24) --------------------------------------------------------
void sub_6D24()
{
  int v0; // r4
  int v1; // r6
  int v2; // r7
  int v3; // r10

  if ( !(*(int (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v3 + 128))(
          v3,
          *(_DWORD *)(v1 - 8),
          *(_DWORD *)(v2 - 132)) )
  {
    *(_DWORD *)(v2 - 124) = v0;
    JUMPOUT(0x6D46);
  }
  JUMPOUT(0x5114);
}
// 6D42: control flows out of bounds to 6D46
// 6D3A: control flows out of bounds to 5114
// 6D24: variable 'v3' is possibly undefined
// 6D28: variable 'v1' is possibly undefined
// 6D2C: variable 'v2' is possibly undefined
// 6D3E: variable 'v0' is possibly undefined

//----- (00006F0C) --------------------------------------------------------
void __noreturn sub_6F0C()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8
  int v3; // r10
  int v4; // r4
  int v5; // r0
  int v6; // r0

  v4 = *(_DWORD *)(v0 - 8);
  if ( v4 )
    v5 = (*(int (__fastcall **)(int, _DWORD, _DWORD))(*(_DWORD *)v3 + 128))(
           v3,
           *(_DWORD *)(v0 - 8),
           *(_DWORD *)(v1 - 132));
  else
    v5 = 0;
  *(_DWORD *)(v0 - 8) = v5;
  sub_751C(v2, v4);
  v6 = *(_DWORD *)(v1 - 60);
  *(_DWORD *)(v1 - 60) = v6 + 32;
  ((void (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v6 + 56)))();
}
// 6F0C: variable 'v0' is possibly undefined
// 6F12: variable 'v3' is possibly undefined
// 6F18: variable 'v1' is possibly undefined
// 6F30: variable 'v2' is possibly undefined

//----- (00006F4E) --------------------------------------------------------
int sub_6F4E()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8
  int v3; // r10
  int *v4; // r6
  int v5; // t1
  int v6; // r0

  v5 = *(_DWORD *)(v0 - 8);
  v4 = (int *)(v0 - 8);
  if ( !v5 )
    JUMPOUT(0x4B82);
  (*(void (__fastcall **)(int))(*(_DWORD *)v3 + 868))(v3);
  sub_751C(v2, *v4);
  v6 = *(_DWORD *)(v1 - 60);
  *(_DWORD *)(v1 - 60) = v6 + 32;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v6 + 56)))();
}
// 6F54: control flows out of bounds to 4B82
// 6F4E: variable 'v0' is possibly undefined
// 6F58: variable 'v3' is possibly undefined
// 6F68: variable 'v2' is possibly undefined
// 6F6C: variable 'v1' is possibly undefined

//----- (00006F86) --------------------------------------------------------
int sub_6F86()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8
  int v3; // r10
  int *v4; // r6
  int v5; // t1
  int v6; // r0

  v5 = *(_DWORD *)(v0 - 8);
  v4 = (int *)(v0 - 8);
  if ( !v5 )
    JUMPOUT(0x4B82);
  (*(void (__fastcall **)(int))(*(_DWORD *)v3 + 872))(v3);
  sub_751C(v2, *v4);
  v6 = *(_DWORD *)(v1 - 60);
  *(_DWORD *)(v1 - 60) = v6 + 32;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v6 + 56)))();
}
// 6F8C: control flows out of bounds to 4B82
// 6F86: variable 'v0' is possibly undefined
// 6F90: variable 'v3' is possibly undefined
// 6FA0: variable 'v2' is possibly undefined
// 6FA4: variable 'v1' is possibly undefined

//----- (00006FBE) --------------------------------------------------------
int sub_6FBE()
{
  int v0; // r4
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // r8
  int *v5; // r9
  int v6; // r10
  int *v7; // r11
  int v8; // r1
  int v9; // r6
  int v10; // r9
  int v11; // r0
  int i; // r3
  int *v13; // r4
  int v14; // r6
  _DWORD *v15; // r0
  int v16; // r0

  *(_DWORD *)(v3 - 124) = v0;
  v7 = v5;
  v8 = *(_DWORD *)(v1 + 16);
  v9 = v2 + 8 * (1 - v8);
  v10 = v9;
  if ( v8 >= 1 )
  {
    v11 = v9 - 8;
    for ( i = 0; i < v8; ++i )
    {
      v9 = v10;
      if ( *(int *)(v11 + 8 * i) <= -1 )
        JUMPOUT(0x4E2C);
    }
  }
  v13 = (int *)(v9 - 8);
  v14 = sub_75E8(*v7, v6, (char *)(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 80) + 1), (int *)(v9 - 8), v8);
  if ( v14 )
  {
    v15 = sub_2160(v4, v14);
    ++v15[1];
  }
  else
  {
    v14 = 0;
  }
  *v13 = v14;
  v16 = *(_DWORD *)(v3 - 60);
  *(_DWORD *)(v3 - 60) = v16 + 32;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v16 + 56)))();
}
// 704C: control flows out of bounds to 4E2C
// 6FBE: variable 'v0' is possibly undefined
// 6FBE: variable 'v3' is possibly undefined
// 6FC2: variable 'v5' is possibly undefined
// 6FC4: variable 'v1' is possibly undefined
// 6FD2: variable 'v2' is possibly undefined
// 7006: variable 'v6' is possibly undefined
// 7014: variable 'v4' is possibly undefined

//----- (00007050) --------------------------------------------------------
int sub_7050()
{
  int v0; // r6
  int v1; // r7
  _DWORD *v2; // r8
  int v3; // r10
  int v4; // r4
  int v5; // r5
  int v6; // r5

  v4 = *(_DWORD *)(v0 - 8);
  if ( v4 )
  {
    v5 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v3 + 96))(v3, v4, 0);
    sub_751C(v2, v4);
    if ( !v5 )
      JUMPOUT(0x5114);
  }
  else
  {
    sub_751C(v2, 0);
  }
  v6 = *(_DWORD *)(*(_DWORD *)(v1 - 60) + 8);
  *(_DWORD *)(v1 - 60) = v6;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(v6 + 24)))();
}
// 707A: control flows out of bounds to 5114
// 7054: variable 'v0' is possibly undefined
// 705A: variable 'v3' is possibly undefined
// 706E: variable 'v2' is possibly undefined
// 708A: variable 'v1' is possibly undefined

//----- (000070A4) --------------------------------------------------------
void __fastcall sub_70A4(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int v6; // r5
  int v7; // r6
  int v8; // r7
  int v9; // r8
  int v10; // r10
  int v11; // r11
  int v12; // r10
  int v13; // r0
  int v14; // r1
  int *v15; // r6
  int v16; // r4
  int *v17; // r5
  int v18; // r0
  int v19; // r4
  _DWORD *v20; // r0
  __int16 v21; // r1
  int *v22; // r4
  int v23; // r5
  int v24; // r11
  int v25; // r8
  int *v26; // r9
  int v27; // r6
  _DWORD *v28; // r0
  __int16 v29; // r1
  int v30; // r1
  _DWORD *v31; // r8
  int v32; // r1
  _DWORD *v33; // r0
  int v34; // r0
  int i; // r5

  *(_DWORD *)(v8 - 124) = v5;
  v11 = v10;
  v12 = *(_DWORD *)(v6 + 8);
  v13 = ~*(_DWORD *)(v12 + 60);
  v14 = *(_DWORD *)(v7 + 8 * v13);
  v15 = (int *)(v7 + 8 * v13);
  *(_DWORD *)(v8 - 168) = v9;
  *(_DWORD *)(v8 - 156) = v11;
  if ( v14 )
  {
    v16 = *(_DWORD *)(v12 + 52) + *(_DWORD *)(v12 + 56) + 1;
    v17 = &a5 - 2 * v16;
    memset(v17, 0, 8 * v16);
    *(_DWORD *)(v8 - 108) = v11;
    *(_DWORD *)(v8 - 104) = (char *)&a5 - ((12 * v16 + 7) & 0xFFFFFFF8);
    v18 = 0;
    *(_DWORD *)(v8 - 100) = 0;
    v19 = *v15;
    if ( *v15 )
    {
      v20 = sub_2160(v8 - 108, *v15);
      v21 = *((_WORD *)v20 + 1);
      *((_BYTE *)v20 + 1) = 1;
      *((_WORD *)v20 + 1) = v21 + 1;
      v18 = v19;
    }
    *(_DWORD *)(v8 - 164) = v17;
    *v17 = v18;
    if ( *(int *)(v12 + 60) >= 1 )
    {
      v22 = v15 + 2;
      v23 = 0;
      v24 = *(_DWORD *)(v8 - 164) + 8;
      do
      {
        v25 = v23 + 1;
        if ( *(_BYTE *)(*(_DWORD *)(v12 + 20) + v23) == 76 )
        {
          v26 = v15;
          v27 = v22[2 * v23];
          if ( v27 )
          {
            v28 = sub_2160(v8 - 108, v22[2 * v23]);
            v29 = *((_WORD *)v28 + 1);
            *((_BYTE *)v28 + 1) = 1;
            *((_WORD *)v28 + 1) = v29 + 1;
          }
          else
          {
            v27 = 0;
          }
          *(_DWORD *)(v24 + 8 * v23) = v27;
          v15 = v26;
        }
        else
        {
          v30 = v22[2 * v23 + 1];
          *(_DWORD *)(v24 + 8 * v23) = v22[2 * v23];
          *(_DWORD *)(v24 + 8 * v23 + 4) = v30;
        }
        ++v23;
      }
      while ( v25 < *(_DWORD *)(v12 + 60) );
    }
    if ( (*(_BYTE *)(v12 + 26) & 0x20) != 0 )
    {
      pthread_mutex_lock((pthread_mutex_t *)(v12 + 28));
      sub_2CD0(v12, *(_DWORD *)(v8 - 156), *(_DWORD *)(v8 - 164), v8 - 108, v8 - 72, 1, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(v12 + 28));
    }
    else
    {
      sub_2CD0(v12, *(_DWORD *)(v8 - 156), *(_DWORD *)(v8 - 164), v8 - 108, v8 - 72, 1, 0);
    }
    v31 = *(_DWORD **)(v8 - 168);
    if ( *(_BYTE *)(*(_DWORD *)(v12 + 20) + *(_DWORD *)(v12 + 60)) == 76 )
    {
      v32 = *(_DWORD *)(v8 - 72);
      if ( v32 )
      {
        v33 = sub_2160(*(_DWORD *)(v8 - 168), v32);
        ++v33[1];
      }
    }
    sub_751C(v31, *v15);
    v34 = *(_DWORD *)(v12 + 60);
    if ( v34 >= 1 )
    {
      for ( i = 0; i < v34; ++i )
      {
        if ( *(_BYTE *)(*(_DWORD *)(v12 + 20) + i) == 76 )
        {
          sub_751C(v31, v15[2 * i + 2]);
          v34 = *(_DWORD *)(v12 + 60);
        }
      }
    }
    if ( **(_DWORD **)(v8 - 60) == 214 )
      *(_QWORD *)v15 = *(_QWORD *)(v8 - 72);
    JUMPOUT(0x6D50);
  }
  JUMPOUT(0x4E28);
}
// 71C0: control flows out of bounds to 4E28
// 726A: control flows out of bounds to 6D50
// 70A4: variable 'v5' is possibly undefined
// 70A4: variable 'v8' is possibly undefined
// 70A8: variable 'v10' is possibly undefined
// 70AA: variable 'v6' is possibly undefined
// 70B8: variable 'v7' is possibly undefined
// 70C0: variable 'v9' is possibly undefined
// 2CD0: using guessed type int __fastcall sub_2CD0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000726C) --------------------------------------------------------
int sub_726C()
{
  int v0; // r4
  int v1; // r5
  int v2; // r7
  int v3; // r10

  *(_DWORD *)(v2 - 124) = v0;
  *(_DWORD *)(v2 - 132) = sub_28E0(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 20), v3);
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)v3 + 912))(v3)
    || (*(_DWORD *)(v2 - 136) = sub_9514(*(_DWORD *)(*(_DWORD *)(v2 - 60) + 8), v3),
        (*(int (__fastcall **)(int))(*(_DWORD *)v3 + 912))(v3)) )
  {
    JUMPOUT(0x6D54);
  }
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(*(_DWORD *)(v2 - 60) + 28)))();
}
// 7290: control flows out of bounds to 6D54
// 726C: variable 'v0' is possibly undefined
// 726C: variable 'v2' is possibly undefined
// 7272: variable 'v1' is possibly undefined
// 7276: variable 'v3' is possibly undefined

//----- (000072CC) --------------------------------------------------------
int sub_72CC()
{
  int v0; // r4
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // r10

  *(_DWORD *)(v3 - 124) = v0;
  *(_DWORD *)(v3 - 136) = sub_9514(*(_DWORD *)(v1 + 8), v4);
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 912))(v4) )
    JUMPOUT(0x6D54);
  if ( !*(_DWORD *)(v2 - 8) )
  {
    *(_DWORD *)(v3 - 124) = 0;
    JUMPOUT(0x4E28);
  }
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(*(_DWORD *)(v3 - 60) + 28)))();
}
// 72EE: control flows out of bounds to 6D54
// 7310: control flows out of bounds to 4E28
// 72CC: variable 'v0' is possibly undefined
// 72CC: variable 'v3' is possibly undefined
// 72D2: variable 'v1' is possibly undefined
// 72D4: variable 'v4' is possibly undefined
// 72F2: variable 'v2' is possibly undefined

//----- (00007314) --------------------------------------------------------
int sub_7314()
{
  int v0; // r4
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // r10
  _DWORD *v5; // r6

  *(_DWORD *)(v3 - 124) = v0;
  *(_DWORD *)(v3 - 136) = sub_9514(*(_DWORD *)(v1 + 8), v4);
  v5 = (_DWORD *)(v2 - 16);
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 912))(v4) )
    JUMPOUT(0x6D54);
  if ( !*v5 )
    JUMPOUT(0x730A);
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(*(_DWORD *)(v3 - 60) + 28)))();
}
// 7338: control flows out of bounds to 6D54
// 7340: control flows out of bounds to 730A
// 7314: variable 'v0' is possibly undefined
// 7314: variable 'v3' is possibly undefined
// 731A: variable 'v1' is possibly undefined
// 731C: variable 'v4' is possibly undefined
// 7334: variable 'v2' is possibly undefined

//----- (00007354) --------------------------------------------------------
int sub_7354()
{
  int v0; // r4
  int v1; // r5
  int v2; // r7
  int v3; // r10
  int v4; // r0

  *(_DWORD *)(v2 - 132) = sub_28E0(*(_DWORD *)(v1 + 8), v3);
  v4 = (*(int (__fastcall **)(int))(*(_DWORD *)v3 + 912))(v3);
  *(_DWORD *)(v2 - 124) = v0;
  if ( v4 )
    JUMPOUT(0x6D50);
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(*(_DWORD *)(v2 - 60) + 28)))();
}
// 7372: control flows out of bounds to 6D50
// 7354: variable 'v1' is possibly undefined
// 7358: variable 'v3' is possibly undefined
// 735C: variable 'v2' is possibly undefined
// 736E: variable 'v0' is possibly undefined

//----- (00007388) --------------------------------------------------------
int sub_7388()
{
  int v0; // r4
  int v1; // r5
  int v2; // r6
  int v3; // r7
  int v4; // r10
  int v5; // r0
  int v6; // r5

  *(_DWORD *)(v3 - 132) = sub_28E0(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 8), v4);
  v5 = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 912))(v4);
  *(_DWORD *)(v3 - 124) = v0;
  if ( v5 )
LABEL_6:
    JUMPOUT(0x6D54);
  v6 = *(_DWORD *)(*(_DWORD *)(v3 - 60) + 8);
  *(_DWORD *)(v3 - 140) = sub_2BD0(v6, v4);
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 912))(v4) )
  {
    *(_DWORD *)(v3 - 124) = v0;
    goto LABEL_6;
  }
  if ( !*(_DWORD *)(v2 - 8 * *(_DWORD *)(v6 + 60) - 8) )
    JUMPOUT(0x730A);
  *(_DWORD *)(v3 - 128) = v6;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(*(_DWORD *)(v3 - 60) + 28)))();
}
// 73AC: control flows out of bounds to 6D54
// 73E4: control flows out of bounds to 730A
// 7388: variable 'v1' is possibly undefined
// 738E: variable 'v4' is possibly undefined
// 7392: variable 'v3' is possibly undefined
// 73A8: variable 'v0' is possibly undefined
// 73DA: variable 'v2' is possibly undefined

//----- (000073FC) --------------------------------------------------------
int sub_73FC()
{
  int v0; // r4
  int v1; // r5
  int v2; // r7
  int v3; // r10
  int v4; // r5

  *(_DWORD *)(v2 - 124) = v0;
  *(_DWORD *)(v2 - 132) = sub_28E0(*(_DWORD *)(*(_DWORD *)(v1 + 8) + 8), v3);
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)v3 + 912))(v3)
    || (v4 = *(_DWORD *)(*(_DWORD *)(v2 - 60) + 8),
        *(_DWORD *)(v2 - 140) = sub_2BD0(v4, v3),
        (*(int (__fastcall **)(int))(*(_DWORD *)v3 + 912))(v3)) )
  {
    JUMPOUT(0x6D54);
  }
  *(_DWORD *)(v2 - 128) = v4;
  return ((int (*)(void))((char *)&loc_47E6 + *(_DWORD *)(*(_DWORD *)(v2 - 60) + 28)))();
}
// 7420: control flows out of bounds to 6D54
// 73FC: variable 'v0' is possibly undefined
// 73FC: variable 'v2' is possibly undefined
// 7402: variable 'v1' is possibly undefined
// 7406: variable 'v3' is possibly undefined

//----- (00007468) --------------------------------------------------------
void sub_7468()
{
  int v0; // r5
  int v1; // r0
  int i; // r4
  int v3; // r4
  int v4; // r6
  int v5; // r7
  _DWORD *v6; // r8
  int v7; // r10

  (*(void (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v7 + 252))(v7, v3, *(_DWORD *)(v5 - 140));
  v0 = *(_DWORD *)(v5 - 128);
  *(_DWORD *)(v5 - 124) = v3;
  sub_751C(v6, v3);
  v1 = *(_DWORD *)(v0 + 60);
  if ( v1 >= 1 )
  {
    for ( i = 0; i < v1; ++i )
    {
      if ( *(_BYTE *)(*(_DWORD *)(v0 + 20) + i) == 76 )
      {
        sub_751C(v6, *(_DWORD *)(v4 + 8 * i));
        v1 = *(_DWORD *)(v0 + 60);
      }
    }
  }
  if ( *(_DWORD *)(*(_DWORD *)(v5 - 60) + 16) != 1 )
    *(_QWORD *)(v4 - 8) = *(_QWORD *)(v5 - 72);
  JUMPOUT(0x6D54);
}
// 694E: control flows out of bounds to 6D54
// 7468: variable 'v7' is possibly undefined
// 747E: variable 'v3' is possibly undefined
// 746E: variable 'v5' is possibly undefined
// 6914: variable 'v6' is possibly undefined
// 6928: variable 'v4' is possibly undefined

//----- (0000751C) --------------------------------------------------------
_DWORD *__fastcall sub_751C(_DWORD *result, int a2)
{
  _DWORD *v3; // r5
  int v4; // r2
  int v5; // r1
  bool v6; // cc

  v3 = result;
  if ( a2 )
  {
    result = sub_2160((int)result, a2);
    v4 = result[1];
    v5 = *((__int16 *)result + 1);
    v6 = v4 <= 1;
    result[1] = v4 - 1;
    if ( v4 <= 1 )
      v6 = v5 <= 0;
    if ( v6 && !*((_BYTE *)result + 1) )
    {
      *(_BYTE *)result = 0;
      result = (_DWORD *)(*(int (__fastcall **)(_DWORD, int))(*(_DWORD *)*v3 + 92))(*v3, a2);
    }
  }
  return result;
}

//----- (00007556) --------------------------------------------------------
_DWORD *__fastcall sub_7556(_DWORD *result, int a2)
{
  _DWORD *v3; // r5
  int v4; // r1
  __int16 v5; // r2

  v3 = result;
  if ( a2 )
  {
    result = sub_2160((int)result, a2);
    v4 = *((unsigned __int8 *)result + 1);
    v5 = *((_WORD *)result + 1) - 1;
    *((_WORD *)result + 1) = v5;
    if ( v5 <= 0 && !v4 && (int)result[1] <= 0 )
    {
      *(_BYTE *)result = 0;
      result = (_DWORD *)(*(int (__fastcall **)(_DWORD, int))(*(_DWORD *)*v3 + 92))(*v3, a2);
    }
  }
  return result;
}

//----- (00007592) --------------------------------------------------------
int __fastcall sub_7592(_DWORD *a1, int a2)
{
  int result; // r0
  int v5; // r4
  int v6; // r6
  int v7; // r5

  result = a1[2];
  if ( result >= 1 )
  {
    v5 = result + 1;
    v6 = 12 * result - 12;
    do
    {
      v7 = a1[1];
      result = *(unsigned __int8 *)(v7 + v6);
      if ( *(_BYTE *)(v7 + v6) )
      {
        result = v7 + v6;
        if ( !*(_BYTE *)(v7 + v6 + 1) && *(_DWORD *)(result + 8) != a2 )
        {
          result = (*(int (__fastcall **)(_DWORD))(*(_DWORD *)*a1 + 92))(*a1);
          *(_BYTE *)(v7 + v6) = 0;
        }
      }
      --v5;
      v6 -= 12;
    }
    while ( v5 > 1 );
  }
  return result;
}

//----- (000075E8) --------------------------------------------------------
int __fastcall sub_75E8(int a1, int a2, char *a3, int *a4, int a5)
{
  int v9; // r11
  int v10; // r0
  int v11; // r9
  int v12; // r9
  int v13; // r4
  int v14; // r11
  int v15; // r4
  _DWORD *v17; // [sp+8h] [bp-28h]
  int v18; // [sp+10h] [bp-20h]

  v18 = *a4;
  if ( a5 == 1 )
  {
    v9 = 0;
    switch ( *a3 )
    {
      case 'B':
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 704))(a2, v18);
        break;
      case 'C':
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 708))(a2, v18);
        break;
      case 'D':
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 728))(a2, v18);
        break;
      case 'E':
      case 'G':
      case 'H':
      case 'K':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
        return v9;
      case 'F':
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 724))(a2, v18);
        break;
      case 'I':
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 716))(a2, v18);
        break;
      case 'J':
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 720))(a2, v18);
        break;
      case 'L':
        v9 = 0;
        v15 = sub_8E98(a1, a2, a3);
        if ( (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
          return v9;
        v10 = (*(int (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)a2 + 688))(a2, v18, v15, 0);
        break;
      case 'S':
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 712))(a2, v18);
        break;
      default:
        if ( *a3 != 90 )
          return v9;
        v10 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 700))(a2, v18);
        break;
    }
    v9 = v10;
  }
  else
  {
    v9 = 0;
    v11 = sub_8E98(a1, a2, a3);
    if ( !(*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
    {
      v9 = 0;
      v12 = (*(int (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)a2 + 688))(a2, v18, v11, 0);
      if ( !(*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
      {
        if ( v18 < 1 )
        {
LABEL_11:
          v9 = v12;
        }
        else
        {
          v17 = a4 + 2;
          v13 = 0;
          while ( 1 )
          {
            v14 = sub_75E8(a1, a2, a3 + 1, v17, a5 - 1);
            if ( (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
              break;
            (*(void (__fastcall **)(int, int, int, int))(*(_DWORD *)a2 + 696))(a2, v12, v13, v14);
            (*(void (__fastcall **)(int, int))(*(_DWORD *)a2 + 92))(a2, v14);
            if ( (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
              break;
            if ( ++v13 >= v18 )
              goto LABEL_11;
          }
          v9 = 0;
        }
      }
    }
  }
  return v9;
}

//----- (0000776C) --------------------------------------------------------
int __fastcall sub_776C(_DWORD *a1)
{
  int result; // r0
  int v3; // r6
  int v4; // r5
  int v5; // r1

  result = a1[2];
  if ( result >= 1 )
  {
    v3 = result + 1;
    v4 = 12 * result - 12;
    do
    {
      result = a1[1];
      if ( *(_BYTE *)(result + v4) )
      {
        v5 = result + v4;
        if ( !*(_BYTE *)(result + v4 + 1) && *(__int16 *)(v5 + 2) <= 0 )
        {
          *(_BYTE *)(result + v4) = 0;
          result = (*(int (__fastcall **)(_DWORD, _DWORD))(*(_DWORD *)*a1 + 92))(*a1, *(_DWORD *)(v5 + 8));
        }
      }
      --v3;
      v4 -= 12;
    }
    while ( v3 > 1 );
  }
  return result;
}

//----- (000077C0) --------------------------------------------------------
int __fastcall sub_77C0(int a1, int a2)
{
  int result; // r0
  int v5; // r6
  int v6; // r2
  int *v7; // r10
  int *v8; // r8
  int v9; // r6
  int **v10; // r9
  int v11; // r3
  int v12; // r2
  unsigned __int8 v13; // r4
  unsigned __int8 v14; // r0
  int *v15; // r0
  int v16; // [sp+Ch] [bp-24h] BYREF

  result = *(_DWORD *)(a1 + 92);
  if ( result )
    return result;
  v16 = 0;
  v5 = 1;
  v7 = (int *)calloc(1u, 0x30u);
  if ( v7 )
  {
    v8 = (int *)sub_A870(0x18u, (unsigned int)&v16, v6);
    if ( v8 )
    {
      v9 = *(_DWORD *)(a1 + 60);
      v10 = (int **)malloc(4 * v9 + 8);
      if ( v10 )
      {
        *v10 = (int *)&unk_120E4;
        v10[1] = (int *)&unk_120E4;
        if ( v9 < 1 )
        {
LABEL_10:
          v14 = *(_BYTE *)(*(_DWORD *)(a1 + 20) + v9) - 66;
          if ( v14 <= 0x19u && 0x3120597u >> v14 << 31 )
          {
            if ( sub_A100(v7, 1, v9 + 2, (int)*(&off_13CF0 + (char)v14), v10) )
            {
              v5 = 6;
            }
            else if ( sub_EB98(v8, v7, (int)sub_16A8, a1, v16) )
            {
              v5 = 7;
            }
            else
            {
              result = v16;
              if ( v16 )
              {
                *(_DWORD *)(a1 + 84) = v7;
                *(_DWORD *)(a1 + 88) = v8;
                *(_DWORD *)(a1 + 92) = result;
                return result;
              }
              v5 = 8;
            }
          }
          else
          {
            v5 = 5;
          }
        }
        else
        {
          v11 = *(_DWORD *)(a1 + 20);
          v12 = 0;
          while ( 1 )
          {
            v13 = *(_BYTE *)(v11 + v12) - 66;
            if ( v13 > 0x19u || !(0x3120597u >> v13 << 31) )
              break;
            v10[v12++ + 2] = (int *)*(&off_13CF0 + (char)v13);
            if ( v12 >= v9 )
              goto LABEL_10;
          }
          v5 = 4;
          v10[v12 + 2] = 0;
        }
        free(v7);
        v15 = (int *)v10;
        goto LABEL_18;
      }
      v5 = 3;
    }
    else
    {
      v5 = 2;
    }
    v15 = v7;
LABEL_18:
    free(v15);
    if ( v8 )
      sub_C388(v8);
  }
  sub_8D18(
    *(_DWORD *)a1,
    a2,
    "register native failed(%d), method = %s.%s",
    v5,
    *(const char **)(*(_DWORD *)(a1 + 8) + 80),
    *(const char **)(a1 + 12));
  if ( !byte_14018 )
  {
    sub_8590(
      *(_DWORD *)a1,
      a2,
      3,
      "register native failed(%d), method = %s.%s",
      v5,
      *(const char **)(*(_DWORD *)(a1 + 8) + 80),
      *(const char **)(a1 + 12));
    byte_14018 = 1;
  }
  return 0;
}
// 77FA: variable 'v6' is possibly undefined
// 16A8: using guessed type int sub_16A8();
// 13CF0: using guessed type void *off_13CF0;
// 14018: using guessed type char byte_14018;

//----- (00007994) --------------------------------------------------------
void *__fastcall sub_7994(void *a1)
{
  void *v2; // r0
  void *v3; // r0
  int v4; // r0
  int v5; // r6
  int i; // r4
  int v7; // r1
  _DWORD **v8; // r5
  void *v9; // r0
  int *v10; // r0
  void **v11; // r0

  v2 = (void *)*((_DWORD *)a1 + 18);
  if ( v2 )
    free(v2);
  v3 = (void *)*((_DWORD *)a1 + 17);
  if ( v3 )
    free(v3);
  v4 = *((_DWORD *)a1 + 10);
  if ( v4 >= 1 )
  {
    v5 = 0;
    for ( i = 0; i < v4; ++i )
    {
      v7 = *((_DWORD *)a1 + 11);
      if ( (unsigned int)(*(_DWORD *)(v7 + v5) - 117) <= 1 )
      {
        v8 = *(_DWORD ***)(v7 + v5 + 16);
        if ( v8 )
        {
          sub_7A2E((int)v8, v8[1]);
          operator delete(v8);
          v4 = *((_DWORD *)a1 + 10);
        }
      }
      v5 += 32;
    }
  }
  v9 = (void *)*((_DWORD *)a1 + 11);
  if ( v9 )
    free(v9);
  v10 = (int *)*((_DWORD *)a1 + 22);
  if ( v10 )
    sub_C388(v10);
  v11 = (void **)*((_DWORD *)a1 + 21);
  if ( v11 )
  {
    if ( !v11[2] )
    {
LABEL_19:
      free(v11);
      return a1;
    }
    free(v11[2]);
    v11 = (void **)*((_DWORD *)a1 + 21);
  }
  if ( v11 )
    goto LABEL_19;
  return a1;
}

//----- (00007A2E) --------------------------------------------------------
void __fastcall sub_7A2E(int a1, _DWORD *a2)
{
  if ( a2 )
  {
    sub_7A2E(a1, *a2);
    sub_7A2E(a1, a2[1]);
    operator delete(a2);
  }
}

//----- (00007A54) --------------------------------------------------------
int __fastcall sub_7A54(int ***a1)
{
  int *v1; // r4
  int v2; // r11
  unsigned int *v3; // r10
  unsigned int *v4; // r10
  unsigned int v5; // t1
  size_t v6; // r0
  char *v7; // r5
  int v8; // r8
  unsigned int *v9; // r6
  int v10; // r10
  _DWORD *v11; // r1
  unsigned int *v12; // r11
  _DWORD *v13; // r4
  unsigned int v14; // r2
  unsigned int v15; // r2
  int *v16; // r3
  int v17; // r3
  int v18; // r2
  int v19; // t1
  _DWORD *v20; // r0
  char *v21; // r9
  _DWORD *v22; // r1
  void (__fastcall *v23)(void *); // r3
  unsigned int v24; // r0
  unsigned int v25; // r1
  int v26; // r0
  int v27; // r2
  int v28; // r0
  unsigned int v29; // r0
  _BOOL4 v30; // r1
  bool v31; // zf
  int v32; // r0
  int v33; // r1
  _DWORD *v34; // r2
  int v35; // r5
  int v36; // r6
  int v37; // r0
  int v39; // [sp+Ch] [bp-3Ch]
  int v40; // [sp+10h] [bp-38h]
  int *v41; // [sp+14h] [bp-34h]
  __int64 v42; // [sp+18h] [bp-30h] BYREF
  char v43[8]; // [sp+20h] [bp-28h] BYREF
  int v44; // [sp+28h] [bp-20h]

  v1 = **a1;
  v2 = *v1;
  v3 = *(unsigned int **)(*v1 + 72);
  v5 = *v3;
  v4 = v3 + 1;
  v6 = bswap32(v5);
  *(_DWORD *)(*v1 + 40) = v6;
  v7 = (char *)calloc(v6, 0x20u);
  *(_DWORD *)(v2 + 44) = v7;
  if ( !v7 )
  {
    sub_8590(
      *(_DWORD *)v2,
      v1[1],
      3,
      "Malloc instruction list of `%s.%s` failed",
      *(_DWORD *)(*(_DWORD *)(v2 + 8) + 80),
      *(_DWORD *)(v2 + 12));
LABEL_44:
    v37 = 2;
    goto LABEL_45;
  }
  if ( *(int *)(v2 + 40) >= 1 )
  {
    v8 = 0;
    v9 = v4;
    v41 = v1;
    while ( 1 )
    {
      v19 = *(unsigned __int8 *)v9;
      v9 = (unsigned int *)((char *)v9 + 1);
      v18 = v19;
      v20 = *(_DWORD **)v2;
      v21 = &v7[32 * v8];
      v22 = (_DWORD *)v1[1];
      *(_DWORD *)v21 = v19;
      v23 = (void (__fastcall *)(void *))(v19 - 2);
      switch ( v19 )
      {
        case 2:
        case 4:
        case 6:
        case 7:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
          v28 = bswap32(*(unsigned int *)((char *)v4 + 1));
          goto LABEL_36;
        case 3:
        case 5:
          v29 = bswap32(*v9);
          *((_DWORD *)v21 + 2) = bswap32(v9[1]);
          *((_DWORD *)v21 + 3) = v29;
          goto LABEL_13;
        case 8:
          v27 = bswap32(*(unsigned int *)((char *)v4 + 1));
          v28 = sub_9380(*(_DWORD *)(v20[5] + 4 * v27), (int)v22, v27, v23);
          goto LABEL_36;
        case 9:
        case 202:
        case 204:
        case 207:
        case 208:
          v25 = *(unsigned int *)((char *)v4 + 1);
          v26 = v20[7];
          goto LABEL_30;
        case 81:
          v24 = bswap32(*(unsigned int *)((char *)v4 + 1));
          goto LABEL_12;
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
        case 113:
        case 114:
        case 115:
        case 116:
        case 212:
        case 213:
          v28 = (int)&v7[32 * bswap32(*(unsigned int *)((char *)v4 + 1))];
          goto LABEL_36;
        case 117:
        case 118:
          v40 = v2;
          *((_DWORD *)v21 + 2) = &v7[32 * bswap32(*(unsigned int *)((char *)v4 + 1))];
          v9 = (unsigned int *)((char *)v4 + 9);
          v10 = bswap32(*(unsigned int *)((char *)v4 + 5));
          v11 = (_DWORD *)operator new(0xCu);
          v12 = v9;
          v11[2] = 0;
          v11[1] = 0;
          *v11 = v11 + 1;
          v39 = v10;
          if ( v10 >= 1 )
          {
            do
            {
              v13 = v11;
              v14 = v12[1];
              LODWORD(v42) = bswap32(*v12);
              HIDWORD(v42) = &v7[32 * bswap32(v14)];
              sub_7F7C((int)v43, (int)v11, (int *)&v42, &v42);
              v12 += 2;
              --v10;
              v11 = v13;
            }
            while ( v10 );
            v9 += 2 * v39;
          }
          *((_DWORD *)v21 + 4) = v11;
          v2 = v40;
          break;
        case 125:
        case 126:
        case 127:
        case 128:
        case 129:
        case 130:
        case 131:
        case 132:
        case 133:
        case 134:
        case 135:
        case 136:
        case 137:
        case 138:
        case 139:
        case 140:
        case 141:
        case 142:
        case 143:
        case 144:
        case 145:
        case 146:
        case 147:
        case 148:
        case 149:
        case 150:
        case 151:
        case 152:
        case 153:
        case 154:
        case 155:
        case 156:
        case 157:
        case 158:
        case 159:
        case 160:
          v25 = *(unsigned int *)((char *)v4 + 1);
          v26 = v20[9];
LABEL_30:
          v28 = *(_DWORD *)(v26 + 4 * bswap32(v25));
          goto LABEL_36;
        case 161:
        case 162:
        case 163:
        case 164:
        case 165:
        case 166:
        case 167:
        case 168:
        case 169:
        case 170:
        case 191:
        case 192:
        case 193:
        case 194:
        case 195:
        case 196:
        case 197:
        case 198:
        case 199:
        case 200:
          v30 = v18 == 191;
          v31 = v18 == 161;
          goto LABEL_34;
        case 171:
        case 172:
        case 173:
        case 174:
        case 175:
        case 176:
        case 177:
        case 178:
        case 179:
        case 180:
        case 181:
        case 182:
        case 183:
        case 184:
        case 185:
        case 186:
        case 187:
        case 188:
        case 189:
        case 190:
        case 214:
        case 215:
        case 216:
        case 217:
          v30 = v18 == 181;
          v31 = v18 == 171;
LABEL_34:
          v28 = *(_DWORD *)(v20[11] + 4 * bswap32(*(unsigned int *)((char *)v4 + 1)));
          *((_DWORD *)v21 + 4) = v30 || v31;
LABEL_36:
          *((_DWORD *)v21 + 2) = v28;
          v9 = (unsigned int *)((char *)v4 + 5);
          break;
        case 203:
          v15 = bswap32(*(unsigned int *)((char *)v4 + 1));
          switch ( v15 )
          {
            case 4u:
              v16 = (int *)(*v22 + 700);
              goto LABEL_21;
            case 5u:
              v16 = (int *)(*v22 + 708);
              goto LABEL_21;
            case 6u:
              v16 = (int *)(*v22 + 724);
              goto LABEL_21;
            case 7u:
              v16 = (int *)(*v22 + 728);
              goto LABEL_21;
            case 8u:
              v16 = (int *)(*v22 + 704);
              goto LABEL_21;
            case 9u:
              v16 = (int *)(*v22 + 712);
              goto LABEL_21;
            case 0xAu:
              v16 = (int *)(*v22 + 716);
              goto LABEL_21;
            case 0xBu:
              v16 = (int *)(*v22 + 720);
LABEL_21:
              v17 = *v16;
              if ( !v17 )
                goto LABEL_46;
              v9 = (unsigned int *)((char *)v4 + 5);
              *((_DWORD *)v21 + 2) = v17;
              goto LABEL_37;
            default:
LABEL_46:
              sub_8590((int)v20, (int)v22, 3, "get array type %d failed", v15);
              sub_8590(
                *(_DWORD *)v2,
                v41[1],
                3,
                "Cannot parse instruction %d in `%s.%s`",
                *(_DWORD *)v21,
                *(_DWORD *)(*(_DWORD *)(v2 + 8) + 80),
                *(_DWORD *)(v2 + 12));
              goto LABEL_44;
          }
        case 211:
          v24 = *(_DWORD *)(v20[7] + 4 * bswap32(*(unsigned int *)((char *)v4 + 1)));
LABEL_12:
          *((_DWORD *)v21 + 2) = v24;
          *((_DWORD *)v21 + 4) = bswap32(*(unsigned int *)((char *)v4 + 5));
LABEL_13:
          v9 = (unsigned int *)((char *)v4 + 9);
          break;
        default:
          break;
      }
LABEL_37:
      v1 = v41;
      sub_2CD0((_DWORD *)v2, v41[1], 0, 0, 0, 0, (unsigned int)&v7[32 * v8]);
      if ( *((_DWORD *)v21 + 6) == -1 )
        break;
      if ( ++v8 >= *(_DWORD *)(v2 + 40) )
        goto LABEL_39;
      v7 = *(char **)(v2 + 44);
      v4 = v9;
    }
    sub_8590(
      *(_DWORD *)v2,
      v41[1],
      3,
      "Cannot handle instruction %d in `%s.%s`",
      *(_DWORD *)v21,
      *(_DWORD *)(*(_DWORD *)(v2 + 8) + 80),
      *(_DWORD *)(v2 + 12));
    goto LABEL_44;
  }
LABEL_39:
  free(*(void **)(v2 + 72));
  *(_DWORD *)(v2 + 72) = 0;
  v32 = *(_DWORD *)(v2 + 64);
  if ( v32 >= 1 )
  {
    v33 = *(_DWORD *)(v2 + 44);
    v34 = *(_DWORD **)(v2 + 68);
    do
    {
      --v32;
      v35 = v34[2];
      v36 = v33 + 32 * v34[1];
      *v34 = v33 + 32 * *v34;
      v34[1] = v36;
      v34[2] = v33 + 32 * v35;
      v34 += 4;
    }
    while ( v32 );
  }
  v37 = 1;
LABEL_45:
  *(_DWORD *)(v2 + 36) = v37;
  return _stack_chk_guard - v44;
}

//----- (00007F7C) --------------------------------------------------------
int __fastcall sub_7F7C(int a1, int a2, int *a3, _QWORD *a4)
{
  int **v7; // r4
  int **v8; // r6
  int v9; // r0
  int *v10; // r1
  int *v11; // r1
  int *v12; // r5
  int result; // r0

  v8 = (int **)(a2 + 4);
  v7 = *(int ***)(a2 + 4);
  if ( v7 )
  {
    v9 = *a3;
    v8 = (int **)(a2 + 4);
    while ( 1 )
    {
      v11 = v7[4];
      if ( v9 >= (int)v11 )
      {
        if ( (int)v11 >= v9 )
          goto LABEL_10;
        v8 = v7 + 1;
        v10 = v7[1];
        if ( !v10 )
          goto LABEL_10;
      }
      else
      {
        v10 = *v7;
        v8 = v7;
        if ( !*v7 )
        {
          v8 = v7;
          goto LABEL_10;
        }
      }
      v7 = (int **)v10;
    }
  }
  v7 = (int **)(a2 + 4);
LABEL_10:
  v12 = *v8;
  if ( *v8 )
  {
    result = 0;
  }
  else
  {
    v12 = (int *)operator new(0x18u);
    *((_QWORD *)v12 + 2) = *a4;
    sub_7FF0(a2, (int)v7, v8, v12);
    result = 1;
  }
  *(_BYTE *)(a1 + 4) = result;
  *(_DWORD *)a1 = v12;
  return result;
}

//----- (00007FF0) --------------------------------------------------------
int __fastcall sub_7FF0(int a1, int a2, int **a3, int *a4)
{
  _DWORD *v5; // r0
  int result; // r0

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = *(_DWORD **)a1;
  if ( *v5 )
  {
    *(_DWORD *)a1 = *v5;
    a4 = *a3;
  }
  sub_801C(*(int **)(a1 + 4), a4);
  result = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = result;
  return result;
}

//----- (0000801C) --------------------------------------------------------
int *__fastcall sub_801C(int *result, int *a2)
{
  int v2; // r3
  int v3; // lr
  int *v4; // r2
  _BYTE *v5; // r2
  int v6; // t1
  int v7; // r2
  int v8; // t1
  char v9; // r1
  int *v10; // r0
  int *v11; // r0
  int v12; // r1
  int *v13; // r2
  _DWORD *v14; // r2
  int v15; // t1
  int v16; // r1
  int *v17; // r2
  int **v18; // r2
  int v19; // t1
  int v20; // r1
  int *v21; // r2
  int **v22; // r2
  int v23; // t1
  int v24; // r1
  int *v25; // r2
  int **v26; // r2
  int v27; // t1

  *((_BYTE *)a2 + 12) = a2 == result;
  if ( a2 != result )
  {
    do
    {
      v2 = a2[2];
      if ( *(_BYTE *)(v2 + 12) )
        return result;
      v3 = *(_DWORD *)(v2 + 8);
      v4 = *(int **)v3;
      if ( *(_DWORD *)v3 == v2 )
      {
        v7 = *(_DWORD *)(v3 + 4);
        if ( !v7 || (v8 = *(unsigned __int8 *)(v7 + 12), v5 = (_BYTE *)(v7 + 12), v8) )
        {
          if ( *(int **)v2 == a2 )
          {
            v11 = (int *)a2[2];
          }
          else
          {
            v11 = *(int **)(v2 + 4);
            v12 = *v11;
            *(_DWORD *)(v2 + 4) = *v11;
            if ( v12 )
            {
              *(_DWORD *)(v12 + 8) = v2;
              v3 = *(_DWORD *)(v2 + 8);
            }
            v11[2] = v3;
            v13 = *(int **)(v2 + 8);
            v15 = *v13;
            v14 = v13 + 1;
            if ( v15 == v2 )
              v14 = *(_DWORD **)(v2 + 8);
            *v14 = v11;
            *v11 = v2;
            *(_DWORD *)(v2 + 8) = v11;
            v3 = v11[2];
          }
          *((_BYTE *)v11 + 12) = 1;
          result = *(int **)v3;
          *(_BYTE *)(v3 + 12) = 0;
          v24 = result[1];
          *(_DWORD *)v3 = v24;
          if ( v24 )
            *(_DWORD *)(v24 + 8) = v3;
          result[2] = *(_DWORD *)(v3 + 8);
          v25 = *(int **)(v3 + 8);
          v27 = *v25;
          v26 = (int **)(v25 + 1);
          if ( v27 == v3 )
            v26 = *(int ***)(v3 + 8);
          *v26 = result;
          result[1] = v3;
          goto LABEL_37;
        }
      }
      else if ( !v4 || (v6 = *((unsigned __int8 *)v4 + 12), v5 = v4 + 3, v6) )
      {
        if ( *(int **)v2 == a2 )
        {
          v10 = *(int **)v2;
          v16 = *(_DWORD *)(*(_DWORD *)v2 + 4);
          *(_DWORD *)v2 = v16;
          if ( v16 )
          {
            *(_DWORD *)(v16 + 8) = v2;
            v3 = *(_DWORD *)(v2 + 8);
          }
          v10[2] = v3;
          v17 = *(int **)(v2 + 8);
          v19 = *v17;
          v18 = (int **)(v17 + 1);
          if ( v19 == v2 )
            v18 = *(int ***)(v2 + 8);
          *v18 = v10;
          v10[1] = v2;
          *(_DWORD *)(v2 + 8) = v10;
          v3 = v10[2];
        }
        else
        {
          v10 = (int *)a2[2];
        }
        *((_BYTE *)v10 + 12) = 1;
        result = *(int **)(v3 + 4);
        *(_BYTE *)(v3 + 12) = 0;
        v20 = *result;
        *(_DWORD *)(v3 + 4) = *result;
        if ( v20 )
          *(_DWORD *)(v20 + 8) = v3;
        result[2] = *(_DWORD *)(v3 + 8);
        v21 = *(int **)(v3 + 8);
        v23 = *v21;
        v22 = (int **)(v21 + 1);
        if ( v23 == v3 )
          v22 = *(int ***)(v3 + 8);
        *v22 = result;
        *result = v3;
LABEL_37:
        *(_DWORD *)(v3 + 8) = result;
        return result;
      }
      v9 = 0;
      *(_BYTE *)(v2 + 12) = 1;
      if ( (int *)v3 == result )
        v9 = 1;
      *(_BYTE *)(v3 + 12) = v9;
      a2 = (int *)v3;
      *v5 = 1;
    }
    while ( (int *)v3 != result );
  }
  return result;
}

//----- (00008152) --------------------------------------------------------
_DWORD *__fastcall sub_8152(int a1, int *a2)
{
  _DWORD *v2; // r0
  _DWORD *v3; // r3
  _DWORD *v4; // t1
  int v5; // r2
  _DWORD *v6; // r12

  v4 = *(_DWORD **)(a1 + 4);
  v2 = (_DWORD *)(a1 + 4);
  v3 = v4;
  if ( !v4 )
    return v2;
  v5 = *a2;
  v6 = v2;
  do
  {
    while ( v3[4] < v5 )
    {
      v3 = (_DWORD *)v3[1];
      if ( !v3 )
        goto LABEL_7;
    }
    v6 = v3;
    v3 = (_DWORD *)*v3;
  }
  while ( v3 );
LABEL_7:
  if ( v6 == v2 )
    return v2;
  if ( v5 < v6[4] )
    v6 = v2;
  return v6;
}

//----- (0000818C) --------------------------------------------------------
_DWORD *__fastcall sub_818C(int *a1, int a2, const char *a3)
{
  _DWORD *v6; // r4
  FILE *v7; // r0
  FILE *v8; // r6
  int v9; // r10
  _DWORD *v10; // r0
  _DWORD *v11; // r5
  int v12; // r8
  _DWORD *v13; // r0

  v6 = (_DWORD *)operator new(0x3Cu);
  *(_QWORD *)v6 = 0xFFFFFFFF00000000LL;
  memset(v6 + 2, 0, 0x31u);
  v6[13] = sub_8E38(a1);
  *v6 = (*(int (__fastcall **)(int *, int))(*a1 + 84))(a1, a2);
  v7 = fopen(a3, (const char *)&dword_82A0);
  v8 = v7;
  if ( v7 )
  {
    fseek(v7, 0, 2);
    v9 = ftell(v8);
    fseek(v8, 0, 0);
    v10 = malloc(v9 + 1);
    v11 = v10;
    if ( v10 )
    {
      if ( fread(v10, v9, 1u, v8) == 1 )
      {
        v12 = sub_82F8(v6, (int)a1, v11, v9);
        free(v11);
        fclose(v8);
        if ( v12 )
          return v6;
        goto LABEL_10;
      }
      sub_8590((int)v6, (int)a1, 1, "File read error: %s", a3);
      free(v11);
    }
    else
    {
      sub_8590((int)v6, (int)a1, 3, "Malloc file buffer failed with size %ld", v9);
    }
    fclose(v8);
  }
  else
  {
    sub_8590((int)v6, (int)a1, 1, "File open failed: %s", a3);
  }
LABEL_10:
  sub_8634((int)v6, (int)a1);
  v13 = sub_8FA0(v6);
  operator delete(v13);
  return 0;
}
// 82A0: using guessed type int dword_82A0;

//----- (000082F8) --------------------------------------------------------
int __fastcall sub_82F8(const void *a1, int a2, _DWORD *a3, int a4)
{
  int v8; // r4
  unsigned int v9; // r4
  int i; // r1
  unsigned int v11; // r9
  unsigned int v12; // r4
  unsigned int v13; // r10
  unsigned int v14; // r8
  unsigned int v15; // lr
  unsigned int *v16; // r12
  unsigned int v17; // r3
  int v18; // r2
  unsigned int v19; // r5
  int v20; // r6
  unsigned int v21; // r0
  uLongf v22; // r5
  Bytef *v23; // r6
  int v24; // r4
  unsigned int v25; // r1
  unsigned int v26; // r3
  uLongf v27; // r3
  const Bytef *v29; // [sp+18h] [bp-58h]
  unsigned int v30; // [sp+1Ch] [bp-54h]
  unsigned int v31; // [sp+20h] [bp-50h]
  unsigned int v32; // [sp+24h] [bp-4Ch]
  unsigned int v33; // [sp+28h] [bp-48h]
  const void *v34; // [sp+2Ch] [bp-44h]
  int v35; // [sp+30h] [bp-40h]
  unsigned int *v36; // [sp+34h] [bp-3Ch]
  signed int sourceLen; // [sp+38h] [bp-38h]
  uLongf destLen; // [sp+3Ch] [bp-34h] BYREF
  unsigned int v39; // [sp+40h] [bp-30h]
  unsigned int v40; // [sp+44h] [bp-2Ch]
  unsigned int v41; // [sp+48h] [bp-28h]
  unsigned int v42; // [sp+4Ch] [bp-24h]

  if ( a4 < 9 || *a3 != -624910421 )
    return 0;
  v8 = 0;
  if ( bswap32(a3[1]) != adler32(0, (const Bytef *)a3 + 8, a4 - 8) )
  {
    v9 = bswap32(a3[2]);
    if ( sub_86C0((int)a1, a2, v9) != 1 )
      return 0;
    v34 = a1;
    v35 = a2;
    v36 = a3 + 3;
    v29 = (const Bytef *)a3;
    v39 = -1082811668;
    v40 = -593219860;
    v41 = 1918549841;
    v42 = -748376598;
    LOBYTE(v39) = HIBYTE(v9) ^ 0xEC;
    for ( i = 1; i != 16; ++i )
      *((_BYTE *)&v39 + i) ^= v9 >> (24 - 8 * (i % 4));
    v11 = bswap32(v40);
    v33 = v39;
    v12 = bswap32(v42);
    v13 = bswap32(v39);
    v30 = v42;
    v31 = v41;
    v14 = bswap32(v41);
    v32 = v40;
    sourceLen = a4 - 12;
    sub_8D18((int)a1, v35, "[%p] decrypt using [%u %u %u %u], len = %d", a1, v13, v11, v14, v12, a4 - 12);
    if ( a4 >= 13 )
    {
      v15 = 0;
      do
      {
        v16 = &v36[v15 / 4];
        v17 = bswap32(v36[v15 / 4]);
        v18 = 16;
        v19 = bswap32(v36[v15 / 4 + 1]);
        v20 = -1250452624;
        do
        {
          --v18;
          v19 -= (v17 + v20) ^ (v14 + 16 * v17) ^ (v12 + (v17 >> 5));
          v21 = v20 + v19;
          v20 += 1688766025;
          v17 -= v21 ^ (v13 + 16 * v19) ^ (v11 + (v19 >> 5));
        }
        while ( v18 );
        v15 += 8;
        *v16 = bswap32(v17);
        v16[1] = bswap32(v19);
      }
      while ( (int)v15 < sourceLen );
    }
    v22 = bswap32(*v36);
    destLen = v22;
    if ( v22 <= 100 * sourceLen )
    {
      v23 = (Bytef *)malloc(v22);
      v24 = uncompress(v23, &destLen, v29 + 16, sourceLen);
      if ( v23 )
      {
        v26 = *((_DWORD *)v23 + 1);
        v25 = *(_DWORD *)v23;
      }
      else
      {
        v25 = 0;
        v26 = 0;
      }
      sub_8D18(
        (int)v34,
        v35,
        "[%p] uncompress result: %d, oDestLen: %lu, destLen: %lu, buffer: %p first: %llu",
        v34,
        v24,
        v22,
        destLen,
        v23,
        __PAIR64__(v26, v25));
      if ( !v24 )
      {
        v27 = destLen;
        if ( v23 && (int)destLen >= 1 )
        {
          v8 = sub_8738((int)v34, v35, (unsigned int *)v23, destLen);
          free(v23);
          return v8;
        }
        goto LABEL_20;
      }
      if ( v23 )
        free(v23);
    }
    v27 = 0;
LABEL_20:
    sub_8590(
      (int)v34,
      v35,
      3,
      "decrypt failed, key = %u %u %u %u, target = %d, output = %d",
      v33,
      v32,
      v31,
      v30,
      sourceLen,
      v27);
    return 0;
  }
  return v8;
}

//----- (00008590) --------------------------------------------------------
int sub_8590(int a1, int a2, int a3, const char *a4, ...)
{
  int v7; // r9
  char s[100]; // [sp+8h] [bp-80h] BYREF
  int v10; // [sp+6Ch] [bp-1Ch]
  va_list va; // [sp+90h] [bp+8h] BYREF

  va_start(va, a4);
  if ( !(*(int (__fastcall **)(int))(*(_DWORD *)a2 + 60))(a2) )
  {
    v7 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)a2 + 24))(a2, "java/lang/RuntimeException");
    if ( !(*(int (__fastcall **)(int))(*(_DWORD *)a2 + 60))(a2) )
    {
      vsnprintf(s, 0x64u, a4, va);
      (*(void (__fastcall **)(int, int, char *))(*(_DWORD *)a2 + 56))(a2, v7, s);
    }
  }
  sub_8D94(a1, a2);
  return _stack_chk_guard - v10;
}

//----- (00008634) --------------------------------------------------------
int __fastcall sub_8634(int result, int a2)
{
  _DWORD *v2; // r5
  int v4; // r1
  int i; // r6
  int v6; // r1
  int j; // r6
  int k; // r6

  v2 = (_DWORD *)result;
  v4 = *(_DWORD *)(result + 16);
  if ( v4 >= 1 )
  {
    for ( i = 0; i < v4; ++i )
    {
      result = *(_DWORD *)(v2[5] + 4 * i);
      if ( result )
      {
        result = sub_93DC(result, a2);
        v4 = v2[4];
      }
    }
  }
  v6 = v2[6];
  if ( v6 >= 1 )
  {
    for ( j = 0; j < v6; ++j )
    {
      result = *(_DWORD *)(v2[7] + 4 * j);
      if ( result )
      {
        result = sub_2984(result, a2);
        v6 = v2[6];
      }
    }
    if ( v6 >= 1 )
    {
      for ( k = 0; k < v6; ++k )
      {
        result = *(_DWORD *)(v2[7] + 4 * k);
        if ( result )
        {
          result = sub_2984(result, a2);
          v6 = v2[6];
        }
      }
    }
  }
  if ( v2[12] )
    result = (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 88))(a2);
  if ( *v2 )
    result = (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 88))(a2);
  return result;
}

//----- (000086C0) --------------------------------------------------------
int __fastcall sub_86C0(int a1, int a2, unsigned int a3)
{
  int v3; // r3
  bool v4; // zf

  v3 = 1;
  v4 = HIWORD(a3) == 1;
  if ( HIWORD(a3) == 1 )
    v4 = BYTE1(a3) == 0;
  if ( !v4 )
  {
    sub_8590(
      a1,
      a2,
      1,
      "Cannot handle version %u.%u.%u, current %u.%u.%u",
      HIWORD(a3),
      BYTE1(a3),
      (unsigned __int8)a3,
      1,
      0,
      0);
    v3 = 0;
  }
  return v3;
}

//----- (00008738) --------------------------------------------------------
int __fastcall sub_8738(int a1, int a2, unsigned int *a3, int a4)
{
  unsigned int *v5; // r6
  unsigned int v8; // r5
  int v9; // r0
  unsigned int v10; // r1
  unsigned int v11; // r5
  unsigned int *v12; // r0
  int v13; // r4
  int v14; // r4
  int v15; // r8
  unsigned int v16; // r1
  unsigned int v17; // r0
  signed int v18; // r8
  _DWORD *v19; // r4
  unsigned int v20; // r0
  unsigned int v21; // r9
  unsigned int *v22; // r6
  size_t v23; // r4
  int v24; // r9
  unsigned int *v25; // r11
  unsigned __int16 *v26; // r0
  int v27; // r4
  unsigned int v28; // r5
  unsigned int v29; // r0
  signed int v30; // r4
  void *v31; // r0
  int v32; // r4
  int v33; // r6
  unsigned int v34; // r0
  signed int v35; // r4
  void *v36; // r0
  int v37; // r4
  int v38; // r6
  int v39; // r0
  int v40; // r4
  unsigned int v41; // r0
  signed int v42; // r4
  void *v43; // r0
  int v44; // r4
  int v45; // r6
  int v46; // r4
  unsigned int v47; // r0
  signed int v48; // r4
  void *v49; // r0
  int v50; // r4
  int v51; // r6
  int v52; // r4
  unsigned int v53; // r0
  int v54; // r6
  int v55; // r4
  int v56; // r0
  int v57; // r4
  const char *v58; // r3
  int v60; // [sp+0h] [bp-48h]
  int v61; // [sp+4h] [bp-44h]
  int v62; // [sp+8h] [bp-40h]
  int v63; // [sp+Ch] [bp-3Ch]
  unsigned __int8 *v64; // [sp+18h] [bp-30h]
  int v65; // [sp+1Ch] [bp-2Ch]
  unsigned int *v66; // [sp+20h] [bp-28h]
  unsigned int *v67; // [sp+24h] [bp-24h] BYREF

  v5 = a3;
  v67 = a3;
  if ( !sub_8CE4(*(_DWORD **)(a1 + 52)) )
  {
    v58 = "Method cache init failed";
    goto LABEL_60;
  }
  v8 = (unsigned int)v5 + a4;
  sub_8D18(a1, a2, "[%p] start parse with start: %p, end: %p", (const void *)a1, v5, (char *)v5 + a4);
  if ( a4 <= 0 )
  {
LABEL_58:
    sub_8D18(
      a1,
      a2,
      "[%p] parse success with uStringLen: %d, constantLen: %d, fieldLen: %d, methodLen: %d, classLen: %d",
      (const void *)a1,
      *(_DWORD *)(a1 + 8),
      *(_DWORD *)(a1 + 16),
      *(_DWORD *)(a1 + 32),
      *(_DWORD *)(a1 + 40),
      *(_DWORD *)(a1 + 24));
    return 1;
  }
  v64 = (unsigned __int8 *)v5 + a4;
  v65 = a2;
  while ( 1 )
  {
    v67 = (unsigned int *)((char *)v5 + 1);
    v9 = *(unsigned __int8 *)v5;
    v10 = bswap32(*(unsigned int *)((char *)v5 + 1));
    v67 = (unsigned int *)((char *)v5 + 5);
    if ( (unsigned int)v5 + v10 + 5 > v8 )
      return 0;
    v66 = (unsigned int *)((char *)v5 + v10 + 5);
    switch ( v9 )
    {
      case 0:
        v11 = *(unsigned __int16 *)((char *)v5 + 5);
        v12 = (unsigned int *)((char *)v5 + 7);
        v67 = (unsigned int *)((char *)v5 + 7);
        if ( !v11 )
          goto LABEL_12;
        v13 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)a2 + 24))(a2, "com/xunmeng/nvwavm/Engine");
        if ( sub_8D94(a1, a2) )
          return 0;
        (*(void (__fastcall **)(int, int, const char *, const char *, int, int, int, int))(*(_DWORD *)a2 + 132))(
          a2,
          v13,
          "checkModuleVersion",
          "(Ljava/lang/String;)Z",
          v60,
          v61,
          v62,
          v63);
        if ( sub_8D94(a1, a2) )
          return 0;
        (*(void (__fastcall **)(int, unsigned int *))(*(_DWORD *)a2 + 668))(a2, v67);
        v14 = sub_21D4(a2);
        v15 = 0;
        if ( sub_8D94(a1, a2) || !v14 )
          return v15;
        v12 = (unsigned int *)((char *)v67 + __rev16(v11));
        v67 = v12;
LABEL_12:
        v16 = *v12;
        v67 = v12 + 1;
        *(_DWORD *)(a1 + 4) = bswap32(v16);
        break;
      case 1:
        v17 = *(unsigned int *)((char *)v5 + 5);
        v67 = (unsigned int *)((char *)v5 + 9);
        v18 = bswap32(v17);
        *(_DWORD *)(a1 + 8) = v18;
        v19 = calloc(v18, 4u);
        *(_DWORD *)(a1 + 12) = v19;
        if ( !v19 )
        {
          v58 = "Malloc ustring pool failed";
          goto LABEL_60;
        }
        if ( v18 < 1 )
          break;
        v20 = *(unsigned __int16 *)((char *)v5 + 9);
        v67 = (unsigned int *)((char *)v5 + 11);
        v21 = bswap32(v20);
        v22 = (unsigned int *)malloc(HIWORD(v21) + 1);
        *v19 = v22;
        if ( v22 )
        {
          v23 = HIWORD(v21);
          v24 = 1;
          do
          {
            v25 = v67;
            qmemcpy(v22, v67, v23);
            *((_BYTE *)v22 + v23) = 0;
            v26 = (unsigned __int16 *)((char *)v25 + v23);
            v67 = (unsigned int *)((char *)v25 + v23);
            if ( v24 >= v18 )
              goto LABEL_57;
            v27 = *(_DWORD *)(a1 + 12);
            v28 = bswap32(*v26);
            v67 = (unsigned int *)(v26 + 1);
            v22 = (unsigned int *)malloc(HIWORD(v28) + 1);
            *(_DWORD *)(v27 + 4 * v24++) = v22;
            v23 = HIWORD(v28);
          }
          while ( v22 );
        }
        sub_8590(a1, v65, 3, "Malloc buffer for string pool failed", v60, v61, v62, v63);
        return 0;
      case 2:
        v29 = *(unsigned int *)((char *)v5 + 5);
        v67 = (unsigned int *)((char *)v5 + 9);
        v30 = bswap32(v29);
        *(_DWORD *)(a1 + 16) = v30;
        v31 = calloc(v30, 4u);
        *(_DWORD *)(a1 + 20) = v31;
        if ( !v31 )
        {
          v58 = "Malloc constant pool failed";
LABEL_60:
          sub_8590(a1, a2, 3, v58, v60, v61, v62, v63);
          return 0;
        }
        if ( v30 >= 1 )
        {
          v32 = 0;
          do
          {
            v33 = operator new(0x20u);
            sub_9346(v33, a1, &v67);
            *(_DWORD *)(*(_DWORD *)(a1 + 20) + 4 * v32++) = v33;
          }
          while ( v32 < *(_DWORD *)(a1 + 16) );
        }
        break;
      case 3:
        v34 = *(unsigned int *)((char *)v5 + 5);
        v67 = (unsigned int *)((char *)v5 + 9);
        v35 = bswap32(v34);
        *(_DWORD *)(a1 + 24) = v35;
        v36 = calloc(v35, 4u);
        *(_DWORD *)(a1 + 28) = v36;
        if ( !v36 )
        {
          v58 = "Malloc class pool failed";
          goto LABEL_60;
        }
        if ( v35 >= 1 )
        {
          v37 = 0;
          do
          {
            v38 = operator new(0x58u);
            sub_2454(v38, a1);
            *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * v37++) = v38;
            v39 = *(_DWORD *)(a1 + 24);
          }
          while ( v37 < v39 );
          if ( v39 >= 1 )
          {
            v40 = 0;
            do
              sub_2482(*(int **)(*(_DWORD *)(a1 + 28) + 4 * v40++), &v67);
            while ( v40 < *(_DWORD *)(a1 + 24) );
          }
        }
        break;
      case 4:
        v41 = *(unsigned int *)((char *)v5 + 5);
        v67 = (unsigned int *)((char *)v5 + 9);
        v42 = bswap32(v41);
        *(_DWORD *)(a1 + 32) = v42;
        v43 = calloc(v42, 4u);
        *(_DWORD *)(a1 + 36) = v43;
        if ( !v43 )
        {
          v58 = "Malloc field pool failed";
          goto LABEL_60;
        }
        if ( v42 >= 1 )
        {
          v44 = 0;
          do
          {
            v45 = operator new(0x1Cu);
            sub_946C(v45, a1, &v67);
            *(_DWORD *)(*(_DWORD *)(a1 + 36) + 4 * v44++) = v45;
          }
          while ( v44 < *(_DWORD *)(a1 + 32) );
        }
        if ( *(int *)(a1 + 24) >= 1 )
        {
          v46 = 0;
          do
            sub_26DE(*(_DWORD **)(*(_DWORD *)(a1 + 28) + 4 * v46++));
          while ( v46 < *(_DWORD *)(a1 + 24) );
        }
        break;
      case 5:
        v47 = *(unsigned int *)((char *)v5 + 5);
        v67 = (unsigned int *)((char *)v5 + 9);
        v48 = bswap32(v47);
        *(_DWORD *)(a1 + 40) = v48;
        v49 = calloc(v48, 4u);
        *(_DWORD *)(a1 + 44) = v49;
        if ( !v49 )
        {
          v58 = "Malloc method pool failed";
          goto LABEL_60;
        }
        if ( v48 >= 1 )
        {
          v50 = 0;
          do
          {
            v51 = operator new(0x60u);
            sub_29FA(v51, a1, &v67);
            *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4 * v50++) = v51;
          }
          while ( v50 < *(_DWORD *)(a1 + 40) );
        }
        if ( *(int *)(a1 + 24) >= 1 )
        {
          v52 = 0;
          do
            sub_273E(*(_DWORD **)(*(_DWORD *)(a1 + 28) + 4 * v52++));
          while ( v52 < *(_DWORD *)(a1 + 24) );
        }
        break;
      case 6:
        if ( sub_8D94(a1, a2) )
          return 0;
        (*(void (__fastcall **)(int, _DWORD, const char *, const char *))(*(_DWORD *)a2 + 452))(
          a2,
          *(_DWORD *)(*(_DWORD *)(a1 + 52) + 8),
          "loadDex",
          "(Lcom/xunmeng/nvwavm/Engine;JLjava/nio/ByteBuffer;Ljava/lang/String;)Ljava/lang/ClassLoader;");
        if ( sub_8D94(a1, a2) )
          return 0;
        v53 = *v67++;
        v54 = bswap32(v53);
        v55 = (*(int (__fastcall **)(int, unsigned int *, int, int))(*(_DWORD *)a2 + 916))(a2, v67, v54, v54 >> 31);
        v15 = 0;
        v67 = (unsigned int *)((char *)v67 + v54);
        v56 = 0;
        if ( (unsigned int *)((char *)v67 + 33) <= v66 )
        {
          v56 = (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 668))(a2);
          v67 = (unsigned int *)((char *)v67 + 33);
        }
        v60 = a1;
        v61 = 0;
        v62 = v55;
        v63 = v56;
        v57 = sub_8DE8(a2);
        if ( sub_8D94(a1, a2) )
          return v15;
        if ( !v57 || (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)a2 + 96))(a2, v57, 0) )
        {
          v58 = "Dex load failed";
          goto LABEL_60;
        }
        *(_DWORD *)(a1 + 48) = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 84))(a2, v57);
        break;
      default:
        v60 = v9;
        v58 = "Cannot handle section %d";
        goto LABEL_60;
    }
LABEL_57:
    v5 = v66;
    v8 = (unsigned int)v64;
    a2 = v65;
    v67 = v66;
    if ( v66 >= (unsigned int *)v64 )
      goto LABEL_58;
  }
}
// 8800: variable 'v60' is possibly undefined
// 8800: variable 'v61' is possibly undefined
// 8800: variable 'v62' is possibly undefined
// 8800: variable 'v63' is possibly undefined

//----- (00008CE4) --------------------------------------------------------
bool __fastcall sub_8CE4(_DWORD *a1)
{
  _BOOL4 result; // r0

  if ( a1[3] && a1[12] && a1[13] && a1[4] && a1[5] && a1[7] && a1[8] && a1[9] && a1[10] )
    result = a1[11] != 0;
  else
    result = 0;
  return result;
}

//----- (00008D18) --------------------------------------------------------
int sub_8D18(int a1, int a2, const char *a3, ...)
{
  int v4; // r6
  char s[100]; // [sp+4h] [bp-78h] BYREF
  int v7; // [sp+68h] [bp-14h]
  va_list va; // [sp+84h] [bp+8h] BYREF

  va_start(va, a3);
  vsnprintf(s, 0x64u, a3, va);
  v4 = (*(int (__fastcall **)(int, char *))(*(_DWORD *)a2 + 668))(a2, s);
  sub_8F50(a2);
  (*(void (__fastcall **)(int, int))(*(_DWORD *)a2 + 92))(a2, v4);
  return _stack_chk_guard - v7;
}

//----- (00008D94) --------------------------------------------------------
int __fastcall sub_8D94(int a1, int a2)
{
  int v3; // r5

  v3 = (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 60))(a2);
  if ( !v3 )
    return 0;
  (*(void (__fastcall **)(int))(*(_DWORD *)a2 + 68))(a2);
  sub_9570(a2, v3);
  sub_8F50(a2);
  (*(void (__fastcall **)(int))(*(_DWORD *)a2 + 68))(a2);
  return 1;
}

//----- (00008DE8) --------------------------------------------------------
int __fastcall sub_8DE8(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 460))(a1);
}

//----- (00008E38) --------------------------------------------------------
_DWORD *__fastcall sub_8E38(int *a1)
{
  char v2; // r0

  v2 = byte_14054;
  __dmb(0xBu);
  if ( (v2 & 1) == 0 && _cxa_guard_acquire((__guard *)&byte_14054) )
  {
    sub_9068(dword_1401C, a1);
    _cxa_guard_release((__guard *)&byte_14054);
  }
  return dword_1401C;
}
// 14054: using guessed type char byte_14054;

//----- (00008E98) --------------------------------------------------------
int __fastcall sub_8E98(int a1, int a2, char *a3)
{
  char *v4; // r5
  signed int v6; // r0
  _BYTE *v7; // r1
  char *v8; // r2
  signed int v9; // r3
  char v10; // r6
  int v11; // t1
  int v13; // [sp+4h] [bp-24h]
  int v14; // [sp+8h] [bp-20h] BYREF

  v4 = a3;
  if ( !a3 )
    return 0;
  v6 = strlen(a3);
  if ( !v6 )
    return 0;
  v7 = (char *)&v14 - ((v6 + 8) & 0xFFFFFFF8);
  if ( v6 >= 1 )
  {
    v8 = (char *)&v14 - ((v6 + 8) & 0xFFFFFFF8);
    v9 = v6;
    do
    {
      v11 = (unsigned __int8)*v4++;
      v10 = v11;
      if ( v11 == 47 )
        v10 = 46;
      *v8++ = v10;
      --v9;
    }
    while ( v9 );
  }
  v7[v6] = 0;
  if ( *v7 == 76 )
    (v7++)[v6 - 1] = 0;
  (*(void (__fastcall **)(int, _BYTE *))(*(_DWORD *)a2 + 668))(a2, v7);
  v13 = *(_DWORD *)(a1 + 48);
  return sub_8DE8(a2);
}

//----- (00008F50) --------------------------------------------------------
int __fastcall sub_8F50(int a1)
{
  int v2; // [sp+8h] [bp-10h]

  (*(void (__fastcall **)(int))(*(_DWORD *)a1 + 568))(a1);
  return _stack_chk_guard - v2;
}
// 8F86: variable 'v2' is possibly undefined

//----- (00008FA0) --------------------------------------------------------
_DWORD *__fastcall sub_8FA0(_DWORD *a1)
{
  int v2; // r1
  int i; // r5
  void *v4; // r0
  void *v5; // r0
  int v6; // r1
  int j; // r5
  void *v8; // r0
  void *v9; // r0
  int v10; // r1
  int k; // r5
  _DWORD *v12; // r0
  _DWORD *v13; // r0
  void *v14; // r0
  int v15; // r1
  int l; // r5
  void *v17; // r0
  void *v18; // r0
  int v19; // r1
  int m; // r5
  void *v21; // r0
  void *v22; // r0
  void *v23; // r0

  v2 = a1[2];
  if ( v2 >= 1 )
  {
    for ( i = 0; i < v2; ++i )
    {
      v4 = *(void **)(a1[3] + 4 * i);
      if ( v4 )
      {
        free(v4);
        v2 = a1[2];
      }
    }
  }
  v5 = (void *)a1[3];
  if ( v5 )
    free(v5);
  v6 = a1[4];
  if ( v6 >= 1 )
  {
    for ( j = 0; j < v6; ++j )
    {
      v8 = *(void **)(a1[5] + 4 * j);
      if ( v8 )
      {
        operator delete(v8);
        v6 = a1[4];
      }
    }
  }
  v9 = (void *)a1[5];
  if ( v9 )
    free(v9);
  v10 = a1[6];
  if ( v10 >= 1 )
  {
    for ( k = 0; k < v10; ++k )
    {
      v12 = *(_DWORD **)(a1[7] + 4 * k);
      if ( v12 )
      {
        v13 = sub_29B8(v12);
        operator delete(v13);
        v10 = a1[6];
      }
    }
  }
  v14 = (void *)a1[7];
  if ( v14 )
    free(v14);
  v15 = a1[8];
  if ( v15 >= 1 )
  {
    for ( l = 0; l < v15; ++l )
    {
      v17 = *(void **)(a1[9] + 4 * l);
      if ( v17 )
      {
        operator delete(v17);
        v15 = a1[8];
      }
    }
  }
  v18 = (void *)a1[9];
  if ( v18 )
    free(v18);
  v19 = a1[10];
  if ( v19 >= 1 )
  {
    for ( m = 0; m < v19; ++m )
    {
      v21 = *(void **)(a1[11] + 4 * m);
      if ( v21 )
      {
        v22 = sub_7994(v21);
        operator delete(v22);
        v19 = a1[10];
      }
    }
  }
  v23 = (void *)a1[11];
  if ( v23 )
    free(v23);
  return a1;
}

//----- (00009068) --------------------------------------------------------
_DWORD *__fastcall sub_9068(_DWORD *a1, int *a2)
{
  int v4; // r0

  memset(a1, 0, 0x38u);
  v4 = (*(int (__fastcall **)(int *, int *))(*a2 + 24))(a2, &dword_918C);
  *a1 = (*(int (__fastcall **)(int *, int))(*a2 + 84))(a2, v4);
  a1[3] = sub_928C(
            (int)a1,
            (int)a2,
            (int)"java/lang/Class",
            a1 + 1,
            (int)"forName",
            (int)"(Ljava/lang/String;ZLjava/lang/ClassLoader;)Ljava/lang/Class;");
  a1[12] = sub_928C(
             (int)a1,
             (int)a2,
             (int)"com/xunmeng/nvwavm/NvwaVM",
             a1 + 2,
             (int)"invokeException",
             (int)"(Lcom/xunmeng/nvwavm/Engine;ILjava/lang/Throwable;)V");
  a1[13] = sub_928C(
             (int)a1,
             (int)a2,
             (int)"com/xunmeng/nvwavm/NvwaVM",
             a1 + 2,
             (int)&dword_91AC,
             (int)"(Ljava/lang/String;)V");
  a1[4] = sub_92F2((int)a1, a2, (int)"java/lang/Boolean", (int)"booleanValue", (int)&dword_91B8);
  a1[5] = sub_92F2((int)a1, a2, (int)"java/lang/Character", (int)"charValue", (int)&dword_91C0);
  a1[6] = sub_92F2((int)a1, a2, (int)"java/lang/Byte", (int)"byteValue", (int)&dword_91D4);
  a1[7] = sub_92F2((int)a1, a2, (int)"java/lang/Short", (int)"shortValue", (int)"()S");
  a1[8] = sub_92F2((int)a1, a2, (int)"java/lang/Integer", (int)"intValue", (int)"()I");
  a1[9] = sub_92F2((int)a1, a2, (int)"java/lang/Float", (int)"floatValue", (int)"()F");
  a1[10] = sub_92F2((int)a1, a2, (int)"java/lang/Long", (int)"longValue", (int)"()J");
  a1[11] = sub_92F2((int)a1, a2, (int)"java/lang/Double", (int)"doubleValue", (int)"()D");
  return a1;
}
// 918C: using guessed type int dword_918C;
// 91AC: using guessed type int dword_91AC;
// 91B8: using guessed type int dword_91B8;
// 91C0: using guessed type int dword_91C0;
// 91D4: using guessed type int dword_91D4;

//----- (0000928C) --------------------------------------------------------
int __fastcall sub_928C(int a1, int a2, int a3, _DWORD *a4, int a5, int a6)
{
  int v8; // r6
  int result; // r0
  int v10; // r5

  v8 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 24))(a2, a3);
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2) )
  {
    (*(void (__fastcall **)(int))(*(_DWORD *)a2 + 68))(a2);
    result = 0;
  }
  else
  {
    *a4 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 84))(a2, v8);
    v10 = (*(int (__fastcall **)(int, int, int, int))(*(_DWORD *)a2 + 452))(a2, v8, a5, a6);
    (*(void (__fastcall **)(int))(*(_DWORD *)a2 + 68))(a2);
    result = v10;
  }
  return result;
}

//----- (000092F2) --------------------------------------------------------
int __fastcall sub_92F2(int a1, int *a2, int a3, int a4, int a5)
{
  int v7; // r6
  int v8; // r0
  int v9; // r1
  int result; // r0
  int v11; // r5

  v7 = (*(int (__fastcall **)(int *, int))(*a2 + 24))(a2, a3);
  v8 = (*(int (__fastcall **)(int *))(*a2 + 912))(a2);
  v9 = *a2;
  if ( v8 )
  {
    (*(void (__fastcall **)(int *))(v9 + 68))(a2);
    result = 0;
  }
  else
  {
    v11 = (*(int (__fastcall **)(int *, int, int, int))(v9 + 132))(a2, v7, a4, a5);
    (*(void (__fastcall **)(int *))(*a2 + 68))(a2);
    result = v11;
  }
  return result;
}

//----- (00009346) --------------------------------------------------------
int __fastcall sub_9346(int result, int a2, _DWORD *a3)
{
  unsigned __int8 *v3; // lr
  unsigned int v4; // r1

  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 16) = 0;
  *(_DWORD *)(result + 24) = 0;
  *(_DWORD *)result = a2;
  *(_DWORD *)(result + 4) = 0;
  v3 = (unsigned __int8 *)(*a3)++;
  *(_DWORD *)(result + 4) = *v3;
  v4 = *(_DWORD *)(v3 + 1);
  *a3 = v3 + 5;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 8) = bswap32(v4);
  return result;
}

//----- (00009380) --------------------------------------------------------
int __fastcall sub_9380(int a1, int a2, int a3, void (__fastcall *a4)(void *))
{
  int v5; // r0
  _DWORD v7[2]; // [sp+4h] [bp-1Ch] BYREF
  unsigned int v8; // [sp+Ch] [bp-14h] BYREF
  _DWORD *v9; // [sp+10h] [bp-10h] BYREF

  v7[0] = a1;
  v7[1] = a2;
  v5 = *(_DWORD *)(a1 + 24);
  __dmb(0xBu);
  if ( v5 != -1 )
  {
    v9 = v7;
    v8 = (unsigned int)&v9;
    std::__call_once((std::__ndk1 *)(a1 + 24), &v8, sub_93F4, a4);
  }
  return *(_DWORD *)(a1 + 16);
}
// 93F4: using guessed type int sub_93F4();

//----- (000093DC) --------------------------------------------------------
int __fastcall sub_93DC(int result, int a2)
{
  int v2; // r2

  if ( *(_DWORD *)(result + 4) == 1 )
  {
    v2 = *(_DWORD *)(result + 16);
    if ( v2 )
      result = (*(int (__fastcall **)(int, int))(*(_DWORD *)a2 + 88))(a2, v2);
  }
  return result;
}

//----- (000093F4) --------------------------------------------------------
int __fastcall sub_93F4(int ***a1)
{
  int *v1; // r6
  int *v2; // r5
  int result; // r0
  int v4; // r0
  int v5; // r4

  v1 = **a1;
  v2 = (int *)*v1;
  result = *(_DWORD *)(*v1 + 4);
  if ( result == 1 )
  {
    v4 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)v1[1] + 668))(
           v1[1],
           *(_DWORD *)(*(_DWORD *)(*v2 + 12) + 4 * v2[2]));
    result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v1[1] + 84))(v1[1], v4);
    v5 = result;
    if ( !result )
      result = sub_8590(
                 *v2,
                 v1[1],
                 3,
                 "get constant string `%s` failed",
                 *(const char **)(*(_DWORD *)(*v2 + 12) + 4 * v2[2]));
    v2[4] = v5;
  }
  return result;
}

//----- (0000946C) --------------------------------------------------------
int __fastcall sub_946C(int a1, int a2, unsigned int **a3)
{
  unsigned int *v6; // r2
  unsigned int v7; // r0
  unsigned int *v8; // r3
  int v9; // r1
  unsigned int v10; // r2
  int v11; // r3
  unsigned int v12; // r2
  int v13; // r2
  unsigned int v14; // r3
  unsigned int *v15; // r1
  unsigned int v16; // r3

  memset((void *)(a1 + 4), 0, 0x18u);
  *(_DWORD *)a1 = a2;
  v6 = *a3;
  *a3 = (unsigned int *)((char *)*a3 + 1);
  v8 = (unsigned int *)((char *)v6 + 5);
  v7 = *(unsigned __int8 *)v6;
  *(_BYTE *)(a1 + 12) = v7 & 1;
  *(_BYTE *)(a1 + 13) = (v7 & 2) != 0;
  v9 = *(_DWORD *)(a2 + 28);
  v10 = bswap32(*(unsigned int *)((char *)v6 + 1));
  *a3 = v8;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(v9 + 4 * v10);
  v11 = *(_DWORD *)(a2 + 12);
  v12 = *(*a3)++;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v11 + 4 * bswap32(v12));
  v13 = *(_DWORD *)(a2 + 12);
  v14 = *(*a3)++;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v13 + 4 * bswap32(v14));
  if ( (v7 & 4) != 0 )
    *a3 = (unsigned int *)((char *)*a3 + bswap32(**a3) + 4);
  if ( ((v7 >> 1) & 1) != 0 )
  {
    v15 = *a3;
    v16 = *(unsigned __int16 *)*a3;
    *a3 = (unsigned int *)((char *)*a3 + 2);
    *(_WORD *)(a1 + 14) = bswap32(v16) >> 16;
    if ( (v7 & 8) != 0 )
      *a3 = (unsigned int *)((char *)v15 + bswap32(*(unsigned int *)((char *)v15 + 2)) + 6);
  }
  return a1;
}

//----- (00009514) --------------------------------------------------------
int __fastcall sub_9514(int a1, int a2)
{
  int result; // r0
  int v5; // r6
  __int64 v6; // r2
  int v7; // r0
  int v8; // r0

  result = *(_DWORD *)(a1 + 16);
  if ( !result )
  {
    v5 = sub_28E0(*(_DWORD *)(a1 + 20), a2);
    if ( (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2)
      || ((v6 = *(_QWORD *)(a1 + 4), v7 = *(_DWORD *)a2, *(_BYTE *)(a1 + 12)) ? (v8 = (*(int (__fastcall **)(int, int, _DWORD, _DWORD))(v7 + 576))(
                                                                                        a2,
                                                                                        v5,
                                                                                        v6,
                                                                                        HIDWORD(v6))) : (v8 = (*(int (__fastcall **)(int, int, _DWORD, _DWORD))(v7 + 376))(a2, v5, v6, HIDWORD(v6))),
          *(_DWORD *)(a1 + 16) = v8,
          (*(int (__fastcall **)(int))(*(_DWORD *)a2 + 912))(a2)) )
    {
      result = 0;
    }
    else
    {
      result = *(_DWORD *)(a1 + 16);
    }
  }
  return result;
}

//----- (00009570) --------------------------------------------------------
int __fastcall sub_9570(int a1, int a2)
{
  int v3; // r5
  int v5; // r0
  int v6; // r9
  int (__fastcall *v7)(int, const char *); // r6
  _DWORD **v8; // r8
  int v9; // r11
  _DWORD *v10; // r10
  int v11; // r0
  _DWORD *v12; // r11
  int v13; // r8
  int v14; // r0
  int v15; // r0
  int v16; // r1
  _DWORD *v17; // r0
  bool v18; // zf
  int v19; // [sp+18h] [bp-38h]
  int v20; // [sp+1Ch] [bp-34h]
  int v21; // [sp+20h] [bp-30h]
  int v22; // [sp+24h] [bp-2Ch]
  int v23; // [sp+28h] [bp-28h] BYREF
  int v24[9]; // [sp+2Ch] [bp-24h] BYREF

  if ( a2 )
  {
    v3 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)a1 + 24))(a1, "com/xunmeng/nvwavm/ExceptionUtil");
    if ( !v3 || (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 912))(a1) )
      return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 68))(a1);
    (*(void (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)a1 + 452))(
      a1,
      v3,
      "fastCheck",
      "(Ljava/lang/Throwable;)Z");
    if ( !sub_97D4(a1) )
    {
      v5 = *(_DWORD *)_emutls_get_address(&unk_14004);
      if ( v5 )
      {
        v6 = -1;
        do
        {
          v5 = *(_DWORD *)(v5 + 12);
          ++v6;
        }
        while ( v5 );
        v7 = *(int (__fastcall **)(int, const char *))(*(_DWORD *)a1 + 24);
        v8 = (_DWORD **)_emutls_get_address(&unk_14004);
        v9 = v7(a1, "java/lang/String");
        v10 = *v8;
        v22 = (*(int (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)a1 + 688))(a1, v6 + 1, v9, 0);
        v21 = (*(int (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)a1 + 688))(a1, v6 + 1, v9, 0);
        v20 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 716))(a1, v6 + 1);
        v19 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 716))(a1, v6 + 1);
        if ( v6 >= 0 )
        {
          v11 = 0;
          do
          {
            v12 = (_DWORD *)v10[1];
            v13 = v11;
            v14 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)a1 + 668))(a1, *(_DWORD *)(v12[2] + 84));
            (*(void (__fastcall **)(int, int, int, int))(*(_DWORD *)a1 + 696))(a1, v22, v13, v14);
            v15 = (*(int (__fastcall **)(int, _DWORD))(*(_DWORD *)a1 + 668))(a1, v12[3]);
            (*(void (__fastcall **)(int, int, int, int))(*(_DWORD *)a1 + 696))(a1, v21, v13, v15);
            v24[0] = 0;
            v17 = (_DWORD *)v10[2];
            v18 = v17 == 0;
            if ( v17 )
            {
              v16 = v12[11];
              v18 = v16 == 0;
            }
            if ( !v18 )
              v24[0] = (unsigned int)(*v17 - v16) >> 5;
            (*(void (__fastcall **)(int, int, int, int, int *))(*(_DWORD *)a1 + 844))(a1, v20, v13, 1, v24);
            v23 = *(unsigned __int8 *)v10;
            (*(void (__fastcall **)(int, int, int, int, int *))(*(_DWORD *)a1 + 844))(a1, v19, v13, 1, &v23);
            v10 = (_DWORD *)v10[3];
            v11 = v13 + 1;
          }
          while ( v13 != v6 );
        }
        (*(void (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)a1 + 452))(
          a1,
          v3,
          "adjust",
          "(Ljava/lang/Throwable;[Ljava/lang/String;[Ljava/lang/String;[I[I)V");
        sub_8F50(a1);
      }
    }
  }
  return _stack_chk_guard - v24[1];
}
// 96CC: variable 'v16' is possibly undefined
// 13EC: using guessed type int __fastcall _emutls_get_address(_DWORD);

//----- (000097D4) --------------------------------------------------------
int __fastcall sub_97D4(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 472))(a1);
}

//----- (00009824) --------------------------------------------------------
bool __fastcall sub_9824(int a1, int *a2)
{
  _DWORD *v2; // r3
  int v3; // r11
  unsigned int v4; // r1
  int v5; // lr
  _BOOL4 result; // r0
  int v7; // r3
  _DWORD *v8; // r12
  unsigned int v9; // r0
  int v10; // r2
  int v11; // r2
  _DWORD *v12; // r3
  int v13; // r9
  unsigned int v14; // r1
  int v15; // r11
  _DWORD *v16; // r12
  unsigned int v17; // r3
  int v18; // r2
  int v19; // r3
  _DWORD *v20; // r6
  int v21; // r10
  unsigned int v22; // r1
  int v23; // r11
  _DWORD *v24; // r12
  unsigned int v25; // r2
  int v26; // r3
  int v27; // r2
  _DWORD *v28; // r8
  int v29; // r10
  unsigned int v30; // r0
  _DWORD *v31; // r12
  unsigned int v32; // r3
  int v33; // r2
  int v34; // r3
  _DWORD *v35; // r9
  int v36; // r11
  unsigned int v37; // r1
  _DWORD *v38; // r12
  unsigned int v39; // r2
  int v40; // r3
  int v41; // r2
  int **v42; // r6
  int *v43; // r7
  unsigned int v44; // r1
  int *v45; // r12
  unsigned int v46; // r3
  int *v47; // t1
  int v48; // r2
  int v49; // r3
  int **v50; // r8
  int *v51; // r5
  unsigned int v52; // r1
  int *v53; // r12
  unsigned int v54; // r2
  int *v55; // t1
  int v56; // r3
  int v57; // r2
  int **v58; // r9
  int *v59; // r4
  unsigned int v60; // r1
  int *v61; // r0
  unsigned int v62; // r12
  int *v63; // t1
  int v64; // r3
  int v65; // r3
  _DWORD *v66; // r10
  _DWORD *v67; // r0
  unsigned int v68; // r2
  _DWORD *v69; // r1
  unsigned int v70; // r12
  _DWORD *v71; // t1
  int v72; // r3
  int v73; // r3
  int v74; // r1
  int v75; // r3
  int v76; // r0
  int v77; // r3
  int v78; // r1
  int v79; // r3
  int v80; // r1
  int v81; // r3
  _DWORD *v82; // [sp+4h] [bp-54h]
  _DWORD *v85; // [sp+10h] [bp-48h]
  _DWORD *v86; // [sp+14h] [bp-44h]
  _DWORD *v87; // [sp+18h] [bp-40h]
  _DWORD *v88; // [sp+1Ch] [bp-3Ch]
  int v89; // [sp+20h] [bp-38h]
  int v90; // [sp+24h] [bp-34h]
  int v91; // [sp+28h] [bp-30h]
  int v92; // [sp+2Ch] [bp-2Ch]

  if ( !a1 )
    return 1;
  v2 = *(_DWORD **)(a1 + 8);
  v82 = v2;
  if ( !v2 )
    return 1;
  v3 = *v2;
  v4 = 0;
  *(_DWORD *)a1 = 0;
  *(_WORD *)(a1 + 4) = 0;
  if ( v3 )
  {
    v7 = 0;
    while ( 1 )
    {
      v11 = *(_DWORD *)v3;
      if ( !*(_DWORD *)v3 )
      {
        v12 = *(_DWORD **)(v3 + 8);
        v85 = v12;
        if ( !v12 )
          return 1;
        v13 = *v12;
        *(_WORD *)(v3 + 4) = 0;
        if ( !v13 )
        {
          *(_DWORD *)v3 = 0;
          return 1;
        }
        v89 = v3;
        v14 = 0;
        v15 = v13;
        do
        {
          v19 = *(_DWORD *)v15;
          if ( !*(_DWORD *)v15 )
          {
            v20 = *(_DWORD **)(v15 + 8);
            if ( !v20 )
              return 1;
            v21 = *v20;
            *(_WORD *)(v15 + 4) = 0;
            if ( !v21 )
            {
              *(_DWORD *)v15 = 0;
              return 1;
            }
            v90 = v15;
            v22 = 0;
            v86 = v20;
            v23 = v21;
            do
            {
              v27 = *(_DWORD *)v23;
              if ( !*(_DWORD *)v23 )
              {
                v28 = *(_DWORD **)(v23 + 8);
                if ( !v28 )
                  return 1;
                v29 = *v28;
                *(_WORD *)(v23 + 4) = 0;
                if ( !v29 )
                {
                  *(_DWORD *)v23 = 0;
                  return 1;
                }
                v30 = 0;
                v87 = v28;
                v91 = v23;
                do
                {
                  v34 = *(_DWORD *)v29;
                  if ( !*(_DWORD *)v29 )
                  {
                    v35 = *(_DWORD **)(v29 + 8);
                    if ( !v35 )
                      return 1;
                    v36 = *v35;
                    *(_WORD *)(v29 + 4) = 0;
                    if ( !v36 )
                    {
                      *(_DWORD *)v29 = 0;
                      return 1;
                    }
                    v37 = 0;
                    v88 = v35;
                    v92 = v29;
                    do
                    {
                      v41 = *(_DWORD *)v36;
                      if ( !*(_DWORD *)v36 )
                      {
                        v42 = *(int ***)(v36 + 8);
                        if ( !v42 )
                          return 1;
                        v43 = *v42;
                        *(_WORD *)(v36 + 4) = 0;
                        if ( !v43 )
                        {
                          *(_DWORD *)v36 = 0;
                          return 1;
                        }
                        v44 = 0;
                        do
                        {
                          v49 = *v43;
                          if ( !*v43 )
                          {
                            v50 = (int **)v43[2];
                            if ( !v50 )
                              return 1;
                            v51 = *v50;
                            *((_WORD *)v43 + 2) = 0;
                            if ( !v51 )
                            {
                              *v43 = 0;
                              return 1;
                            }
                            v52 = 0;
                            do
                            {
                              v57 = *v51;
                              if ( !*v51 )
                              {
                                v58 = (int **)v51[2];
                                if ( !v58 )
                                  return 1;
                                v59 = *v58;
                                *((_WORD *)v51 + 2) = 0;
                                if ( !v59 )
                                {
                                  *v51 = 0;
                                  return 1;
                                }
                                v60 = 0;
                                do
                                {
                                  v65 = *v59;
                                  if ( !*v59 )
                                  {
                                    v66 = (_DWORD *)v59[2];
                                    if ( !v66 )
                                      return 1;
                                    v67 = (_DWORD *)*v66;
                                    *((_WORD *)v59 + 2) = 0;
                                    if ( !v67 )
                                    {
                                      *v59 = 0;
                                      return 1;
                                    }
                                    v68 = 0;
                                    do
                                    {
                                      if ( !*v67 )
                                      {
                                        if ( sub_9824() )
                                          return 1;
                                        v68 = *((unsigned __int16 *)v59 + 2);
                                        v65 = *v59;
                                      }
                                      v69 = (_DWORD *)*v66;
                                      v70 = *(unsigned __int16 *)(*v66 + 4);
                                      v71 = (_DWORD *)v66[1];
                                      ++v66;
                                      v67 = v71;
                                      v72 = ((v65 - 1) | (v70 - 1)) + 1;
                                      *v59 = v72;
                                      if ( v68 < v70 )
                                        LOWORD(v68) = v70;
                                      v65 = v72 + *v69;
                                      v68 = (unsigned __int16)v68;
                                      *v59 = v65;
                                      *((_WORD *)v59 + 2) = v68;
                                    }
                                    while ( v67 );
                                    v81 = (((unsigned __int16)v68 - 1) | (v65 - 1)) + 1;
                                    *v59 = v81;
                                    if ( !v81 )
                                      return 1;
                                    v60 = *((unsigned __int16 *)v51 + 2);
                                    v57 = *v51;
                                  }
                                  v61 = *v58;
                                  v62 = *((unsigned __int16 *)*v58 + 2);
                                  v63 = v58[1];
                                  ++v58;
                                  v59 = v63;
                                  v64 = ((v57 - 1) | (v62 - 1)) + 1;
                                  if ( v60 < v62 )
                                    LOWORD(v60) = v62;
                                  *v51 = v64;
                                  v57 = v64 + *v61;
                                  v60 = (unsigned __int16)v60;
                                  *v51 = v57;
                                  *((_WORD *)v51 + 2) = v60;
                                }
                                while ( v59 );
                                v80 = (unsigned __int16)v60 - 1;
                                *v51 = (v80 | (v57 - 1)) + 1;
                                if ( (v80 | (v57 - 1)) == -1 )
                                  return 1;
                                v52 = *((unsigned __int16 *)v43 + 2);
                                v49 = *v43;
                              }
                              v53 = *v50;
                              v54 = *((unsigned __int16 *)*v50 + 2);
                              v55 = v50[1];
                              ++v50;
                              v51 = v55;
                              v56 = ((v49 - 1) | (v54 - 1)) + 1;
                              if ( v52 < v54 )
                                LOWORD(v52) = v54;
                              *v43 = v56;
                              v49 = v56 + *v53;
                              v52 = (unsigned __int16)v52;
                              *v43 = v49;
                              *((_WORD *)v43 + 2) = v52;
                            }
                            while ( v51 );
                            v79 = (((unsigned __int16)v52 - 1) | (v49 - 1)) + 1;
                            *v43 = v79;
                            if ( !v79 )
                              return 1;
                            v44 = *(unsigned __int16 *)(v36 + 4);
                            v41 = *(_DWORD *)v36;
                          }
                          v45 = *v42;
                          v46 = *((unsigned __int16 *)*v42 + 2);
                          v47 = v42[1];
                          ++v42;
                          v43 = v47;
                          v48 = ((v41 - 1) | (v46 - 1)) + 1;
                          if ( v44 < v46 )
                            LOWORD(v44) = v46;
                          *(_DWORD *)v36 = v48;
                          v41 = v48 + *v45;
                          v44 = (unsigned __int16)v44;
                          *(_DWORD *)v36 = v41;
                          *(_WORD *)(v36 + 4) = v44;
                        }
                        while ( v43 );
                        v78 = (unsigned __int16)v44 - 1;
                        *(_DWORD *)v36 = (v78 | (v41 - 1)) + 1;
                        if ( (v78 | (v41 - 1)) == -1 )
                          return 1;
                        v37 = *(unsigned __int16 *)(v92 + 4);
                        v34 = *(_DWORD *)v92;
                      }
                      v38 = (_DWORD *)*v88;
                      v36 = v88[1];
                      v39 = *(unsigned __int16 *)(*v88++ + 4);
                      v40 = ((v34 - 1) | (v39 - 1)) + 1;
                      if ( v37 < v39 )
                        LOWORD(v37) = v39;
                      *(_DWORD *)v92 = v40;
                      v34 = v40 + *v38;
                      v37 = (unsigned __int16)v37;
                      *(_DWORD *)v92 = v34;
                      *(_WORD *)(v92 + 4) = v37;
                    }
                    while ( v36 );
                    v77 = (((unsigned __int16)v37 - 1) | (v34 - 1)) + 1;
                    *(_DWORD *)v92 = v77;
                    if ( !v77 )
                      return 1;
                    v30 = *(unsigned __int16 *)(v91 + 4);
                    v27 = *(_DWORD *)v91;
                  }
                  v31 = (_DWORD *)*v87;
                  v29 = v87[1];
                  v32 = *(unsigned __int16 *)(*v87++ + 4);
                  v33 = ((v27 - 1) | (v32 - 1)) + 1;
                  if ( v30 < v32 )
                    LOWORD(v30) = v32;
                  *(_DWORD *)v91 = v33;
                  v27 = v33 + *v31;
                  v30 = (unsigned __int16)v30;
                  *(_DWORD *)v91 = v27;
                  *(_WORD *)(v91 + 4) = v30;
                }
                while ( v29 );
                v76 = (unsigned __int16)v30 - 1;
                *(_DWORD *)v91 = (v76 | (v27 - 1)) + 1;
                if ( (v76 | (v27 - 1)) == -1 )
                  return 1;
                v22 = *(unsigned __int16 *)(v90 + 4);
                v19 = *(_DWORD *)v90;
              }
              v24 = (_DWORD *)*v86;
              v23 = v86[1];
              v25 = *(unsigned __int16 *)(*v86++ + 4);
              v26 = ((v19 - 1) | (v25 - 1)) + 1;
              if ( v22 < v25 )
                LOWORD(v22) = v25;
              *(_DWORD *)v90 = v26;
              v19 = v26 + *v24;
              v22 = (unsigned __int16)v22;
              *(_DWORD *)v90 = v19;
              *(_WORD *)(v90 + 4) = v22;
            }
            while ( v23 );
            v75 = (((unsigned __int16)v22 - 1) | (v19 - 1)) + 1;
            *(_DWORD *)v90 = v75;
            if ( !v75 )
              return 1;
            v14 = *(unsigned __int16 *)(v89 + 4);
            v11 = *(_DWORD *)v89;
          }
          v16 = (_DWORD *)*v85;
          v15 = v85[1];
          v17 = *(unsigned __int16 *)(*v85++ + 4);
          v18 = ((v11 - 1) | (v17 - 1)) + 1;
          if ( v14 < v17 )
            LOWORD(v14) = v17;
          *(_DWORD *)v89 = v18;
          v11 = v18 + *v16;
          v14 = (unsigned __int16)v14;
          *(_DWORD *)v89 = v11;
          *(_WORD *)(v89 + 4) = v14;
        }
        while ( v15 );
        v74 = (unsigned __int16)v14 - 1;
        *(_DWORD *)v89 = (v74 | (v11 - 1)) + 1;
        if ( (v74 | (v11 - 1)) == -1 )
          return 1;
        v7 = *(_DWORD *)a1;
        v4 = *(unsigned __int16 *)(a1 + 4);
      }
      v8 = (_DWORD *)*v82;
      v9 = *(unsigned __int16 *)(*v82 + 4);
      v10 = ((v7 - 1) | (v9 - 1)) + 1;
      *(_DWORD *)a1 = v10;
      if ( a2 )
      {
        *a2 = v10;
        v10 = *(_DWORD *)a1;
        ++a2;
      }
      if ( v4 < v9 )
        LOWORD(v4) = v9;
      v3 = v82[1];
      v7 = v10 + *v8;
      v4 = (unsigned __int16)v4;
      ++v82;
      *(_WORD *)(a1 + 4) = v4;
      *(_DWORD *)a1 = v7;
      if ( !v3 )
      {
        v73 = ((unsigned __int16)v4 - 1) | (v7 - 1);
        v5 = v73 + 1;
        result = v73 == -1;
        goto LABEL_72;
      }
    }
  }
  v5 = 0;
  result = 1;
LABEL_72:
  *(_DWORD *)a1 = v5;
  return result;
}

//----- (0000A100) --------------------------------------------------------
int __fastcall sub_A100(int *a1, int a2, int a3, int a4, int **a5)
{
  int **v5; // r8
  int *v9; // r1
  int v11; // r7
  int v12; // r6
  int v13; // r3
  int v14; // r12
  bool v15; // zf
  int v16; // r3
  int *v17; // r4
  int v18; // r3
  _DWORD *v19; // r9
  _DWORD *v20; // r0
  unsigned int v21; // r12
  _DWORD *v22; // r1
  unsigned int v23; // lr
  _DWORD *v24; // t1
  int v25; // r3
  int v26; // r3

  v5 = a5;
  if ( (unsigned int)(a2 - 1) > 1 )
    return 2;
  v9 = *(int **)a4;
  v15 = *(_DWORD *)a4 == 0;
  *a1 = a2;
  a1[1] = a3;
  a1[2] = (int)a5;
  a1[3] = a4;
  a1[5] = 0;
  if ( v15 )
  {
    if ( sub_9824(a4, v9) )
      return 1;
    v11 = a1[1];
    v5 = (int **)a1[2];
    a4 = a1[3];
  }
  else
  {
    v11 = a3;
  }
  if ( *(_WORD *)(a4 + 6) == 13 )
    v12 = 4;
  else
    v12 = 0;
  for ( ; v11; ++v5 )
  {
    v17 = *v5;
    v18 = **v5;
    if ( !v18 )
    {
      v19 = (_DWORD *)v17[2];
      if ( !v19 )
        return 1;
      v20 = (_DWORD *)*v19;
      *((_WORD *)v17 + 2) = 0;
      if ( !v20 )
      {
        *v17 = 0;
        return 1;
      }
      v21 = 0;
      do
      {
        if ( !*v20 )
        {
          if ( sub_9824((int)v20, 0) )
            return 1;
          v21 = *((unsigned __int16 *)v17 + 2);
          v18 = *v17;
        }
        v22 = (_DWORD *)*v19;
        v23 = *(unsigned __int16 *)(*v19 + 4);
        v24 = (_DWORD *)v19[1];
        ++v19;
        v20 = v24;
        v25 = ((v18 - 1) | (v23 - 1)) + 1;
        *v17 = v25;
        if ( v21 < v23 )
          LOWORD(v21) = v23;
        v18 = v25 + *v22;
        v21 = (unsigned __int16)v21;
        *v17 = v18;
        *((_WORD *)v17 + 2) = v21;
      }
      while ( v20 );
      v26 = (((unsigned __int16)v21 - 1) | (v18 - 1)) + 1;
      *v17 = v26;
      if ( !v26 )
        return 1;
      v17 = *v5;
      v18 = **v5;
    }
    v13 = v18 - 1;
    v14 = *((unsigned __int16 *)v17 + 2) - 1;
    v15 = (v12 & v14) == 0;
    if ( (v12 & v14) != 0 )
      v12 = (v12 - 1) | v14;
    v16 = v13 | 3;
    if ( !v15 )
      ++v12;
    --v11;
    v12 += v16 + 1;
  }
  a1[4] = v12;
  return sub_E184(a1);
}

//----- (0000A48C) --------------------------------------------------------
int __fastcall sub_A48C(const char *a1, int a2, int a3, int a4)
{
  int v5; // r4
  int result; // r0
  _BOOL4 *v7; // r0
  bool v8; // cc
  _BOOL4 v9; // r3
  size_t v10; // r6
  int v11; // r5
  _DWORD v12[5]; // [sp+0h] [bp-14h] BYREF

  v12[0] = a4;
  v5 = open(a1, 4735106, 448);
  if ( v5 != -1 )
    return v5;
  v7 = (_BOOL4 *)_errno();
  v8 = (unsigned int)*v7 > 0x5F;
  if ( *v7 != 95 )
    v8 = (unsigned int)(*v7 - 21) > 1;
  v9 = v8;
  if ( v8 )
    return v5;
  *v7 = v9;
  v10 = strlen(a1);
  memcpy(v12, a1, v10);
  strcpy((char *)v12 + v10, "/ffiXXXXXX");
  result = mkstemp((char *)v12);
  v11 = result;
  if ( result != -1 )
  {
    unlink((const char *)v12);
    result = v11;
  }
  return result;
}
// 15A8: using guessed type int _errno(void);

//----- (0000A548) --------------------------------------------------------
int __fastcall sub_A548(const char *a1, int a2, int a3, int a4)
{
  char *v4; // r0
  int v5; // r1
  int v6; // r2
  int result; // r0

  v4 = getenv(a1);
  if ( v4 )
    result = sub_A48C(v4, v5, v6, a4);
  else
    result = -1;
  return result;
}
// A55C: variable 'v5' is possibly undefined
// A55C: variable 'v6' is possibly undefined

//----- (0000A568) --------------------------------------------------------
int __fastcall sub_A568(signed int a1, int a2)
{
  int v2; // r5
  int v4; // r10
  int v5; // r4
  __off_t v6; // r9
  int result; // r0
  int v8; // r2
  int v9; // r10
  int v10; // r0
  int v11; // r9
  int v12; // r4
  char *v13; // r5
  int v14; // r3
  int v15; // r8
  int v16; // r3
  int v17; // [sp+0h] [bp-34h] BYREF
  char v18[4]; // [sp+8h] [bp-2Ch] BYREF
  int *v19; // [sp+Ch] [bp-28h]

  v2 = dword_14014;
  if ( dword_14014 == -1 )
  {
    v8 = 0;
    v9 = 0;
    dword_14058[0] = 0;
    goto LABEL_13;
  }
  while ( 1 )
  {
LABEL_2:
    v4 = a1;
    v5 = dword_14060;
    v6 = dword_1405C;
    v19 = &v17;
    if ( !dword_14060 )
    {
      v5 = sysconf(39);
      dword_14060 = v5;
    }
    memset(v18, 0, v5);
    if ( a1 > 0 )
      break;
LABEL_16:
    v13 = (char *)mmap(0, a1, 5, 1, dword_14014, v6);
    if ( v13 != (char *)-1 )
    {
      if ( !v6 && *(&off_13CA0 + 3 * dword_14058[0] + 2) )
      {
        ((void (__fastcall *)(_DWORD))*(&off_13CA0 + 3 * dword_14058[0]))(0);
        if ( dword_14058[0] == 4 )
          v16 = 0;
        else
          v16 = dword_14058[0] + 1;
        dword_14058[0] = v16;
      }
      result = (int)mmap(0, a1, 3, 1, dword_14014, v6);
      if ( result == -1 )
      {
        munmap(v13, a1);
        ftruncate(dword_14014, v6);
        result = -1;
      }
      else
      {
        v14 = result + a1;
        v15 = a1 + dword_1405C;
        *(_DWORD *)(v14 - 4) = &v13[-result];
        dword_1405C = v15;
      }
      return result;
    }
    if ( v6 )
    {
      ftruncate(dword_14014, v6);
      return -1;
    }
    close(dword_14014);
    v9 = dword_14058[0];
    while ( 1 )
    {
LABEL_13:
      v10 = ((int (__fastcall *)(const char *, int, int, int))*(&off_13CA0 + 3 * v9))(
              (const char *)*(&off_13CA0 + 3 * v9 + 1),
              a2,
              v8,
              (int)*(&off_13CA0 + 3 * v9));
      v11 = dword_14058[0];
      v8 = (int)*(&off_13CA0 + 3 * dword_14058[0] + 2);
      v12 = v10;
      if ( v8 )
      {
        if ( v10 != -1 )
          goto LABEL_15;
        ((void (__fastcall *)(_DWORD))*(&off_13CA0 + 3 * dword_14058[0]))(0);
        v11 = dword_14058[0];
      }
      v9 = v11 + 1;
      dword_14058[0] = v11 + 1;
      if ( v11 == 4 )
        break;
      if ( v12 != -1 )
      {
LABEL_15:
        v2 = v12;
        dword_14014 = v12;
        goto LABEL_2;
      }
    }
    dword_14014 = v12;
    dword_14058[0] = 0;
    if ( v12 == -1 )
      return -1;
    v2 = v12;
  }
  while ( 1 )
  {
    if ( v5 >= (unsigned int)v4 )
      v5 = v4;
    v4 -= v5;
    if ( v5 > write(v2, v18, v5) )
      return -1;
    if ( v4 <= 0 )
      goto LABEL_16;
    v5 = dword_14060;
  }
}
// A670: variable 'a2' is possibly undefined
// A670: variable 'v8' is possibly undefined
// 13CA0: using guessed type int (*off_13CA0)();
// 14014: using guessed type int dword_14014;
// 14058: using guessed type int dword_14058[];
// 1405C: using guessed type int dword_1405C;
// 14060: using guessed type int dword_14060;

//----- (0000A870) --------------------------------------------------------
unsigned int __fastcall sub_A870(unsigned int a1, unsigned int a2, int a3)
{
  _DWORD *v4; // r5
  int v5; // r0
  bool v6; // cc
  int v7; // r12
  int v8; // r0
  unsigned int v9; // r3
  int v10; // r4
  int *v11; // lr
  int v12; // r6
  unsigned int v13; // r3
  int v14; // r3
  unsigned int v15; // r6
  int *v16; // r3
  int v17; // r0
  unsigned int v18; // r2
  int v19; // r1
  unsigned int result; // r0
  int v21; // r0
  int v22; // r6
  unsigned int v23; // r6
  int v24; // lr
  int v25; // r3
  unsigned int v26; // r3
  int *v27; // r0
  int v28; // r6
  unsigned int v29; // lr
  int v30; // r3
  int v31; // r0
  int v32; // r4
  unsigned int v33; // r2
  int v34; // r1
  int *v35; // r2
  int v36; // r0
  unsigned int v37; // r1
  int v38; // r3
  int v39; // r2
  int v40; // r6
  int v41; // r0
  unsigned int v42; // r8
  unsigned int v43; // r12
  unsigned int v44; // r1
  unsigned int v45; // r6
  unsigned int v46; // r3
  unsigned int v47; // lr
  _DWORD *v48; // r3
  int v49; // lr
  _DWORD *v50; // r7
  unsigned int v51; // lr
  _DWORD *v52; // r6
  unsigned int v53; // r2
  _DWORD *v54; // r2
  bool v55; // zf
  bool v56; // zf
  int v57; // r8
  int v58; // r8
  int v59; // r3
  unsigned int v60; // r3
  unsigned int v61; // r2
  bool v62; // cf
  _DWORD *v63; // r7
  _DWORD *v64; // r3
  unsigned int v65; // r9
  unsigned int v66; // r2
  int v67; // r1
  int *v68; // r2
  unsigned int v69; // r2
  unsigned int v70; // r1
  unsigned int v71; // r12
  int v72; // r3
  int v73; // r12
  int v74; // r2
  unsigned int v75; // r3
  _DWORD *v76; // r2
  _DWORD *v77; // r6
  unsigned int v78; // lr
  char *v79; // r7
  _DWORD *v80; // r3
  unsigned int v81; // r8
  unsigned int v82; // r2
  int v83; // r0
  unsigned int v84; // r2
  unsigned int v85; // r1
  unsigned int v86; // r3
  unsigned int v87; // r3
  int v88; // r12
  int *v89; // r3
  unsigned int v90; // r2
  int *v91; // r8
  unsigned int v92; // r7
  char *v93; // lr
  int *v94; // r3
  int v95; // r2
  unsigned int v96; // r0
  bool v97; // cc
  int *v98; // r3
  int *v99; // r3
  unsigned int v100; // r2
  char v101; // r3
  int v102; // r8
  char *v103; // r8
  unsigned int v104; // r9
  int v105; // r10
  int v106; // r11
  int v107; // r10
  int v108; // r0
  int v109; // r1
  int v110; // r2
  int v111; // r3
  int v112; // r2
  _DWORD *v113; // r3
  unsigned int v114; // r0
  unsigned int v115; // r3
  int v116; // r1
  int *v117; // r3
  int *v118; // r2
  unsigned int v119; // r12
  int v120; // r3
  void *v121; // r0
  int v122; // r3
  bool v123; // zf
  int v124; // r1
  unsigned int v125; // r8
  unsigned int v126; // r3
  int v127; // r2
  unsigned int v128; // r6
  int v129; // r1
  int v130; // lr
  unsigned int v131; // r3
  int v132; // r0
  int *v133; // r3
  unsigned int v134; // r2
  int v135; // r1
  int v136; // r7
  int v137; // r12
  int v138; // lr
  int v139; // r2
  unsigned int v140; // r2
  int v141; // r6
  unsigned int v142; // r1
  unsigned int v143; // r3
  int v144; // r2
  unsigned int v145; // r12
  int v146; // r2
  unsigned int v147; // r1
  int v148; // r2
  int v149; // r7
  int *v150; // r2
  int v151; // r1
  unsigned int v152; // r2
  unsigned int v153; // r1
  int v154; // r3
  unsigned int v155; // r3
  _BOOL4 v156; // r1
  void *v157; // r0
  int v158; // r3
  bool v159; // zf
  int v160; // r1
  int v161; // r7
  unsigned int v162; // r2
  int v163; // r0
  unsigned int v164; // r3
  unsigned int v165; // r3
  unsigned int v166; // r2
  unsigned int v167; // r0
  int v168; // r2
  unsigned int v169; // r1
  int v170; // r2
  int v171; // lr
  unsigned int v172; // r3
  _DWORD *v173; // lr
  _DWORD *v174; // r2
  int v175; // r1
  int v176; // r12
  int v177; // r2
  int *v178; // r3
  int v179; // r3
  int v180; // r12
  int v181; // r7
  int v182; // r3
  int *v183; // r3
  int *v184; // r1
  int v185; // r3
  unsigned int v186; // r3
  int v187; // r2
  unsigned int v188; // r3
  _BOOL4 v189; // r0
  unsigned int v190; // lr
  int v191; // r3
  _DWORD *v192; // r0
  _DWORD *v193; // r2
  int v194; // r1
  int v195; // r12
  int v196; // r2
  unsigned int v197; // r7
  char *v198; // r2
  char *v199; // r1
  unsigned int v200; // r4
  int v201; // r0
  unsigned int v202; // lr
  unsigned int v203; // r6
  int *v204; // r12
  int *v205; // r0
  int *v206; // r3
  unsigned int v207; // r3
  int v208; // r0
  int *v209; // r3
  unsigned int v210; // r2
  int v211; // r1
  unsigned int v212; // r3
  int v213; // r12
  unsigned int v214; // r3
  unsigned int v215; // r2
  int v216; // r3
  unsigned int v217; // r12
  int v218; // r3
  unsigned int v219; // r0
  int v220; // r6
  int *v221; // r0
  int v222; // r3
  unsigned int v223; // r0
  unsigned int v224; // r3
  int v225; // r2
  unsigned int v226; // r3
  _BOOL4 v227; // r1
  char *v228; // r3
  unsigned int v229; // r0
  unsigned int v230; // r12
  int v231; // r8
  int *v232; // r12
  unsigned int v233; // r12
  unsigned int v234; // r6
  unsigned int v235; // r0
  _DWORD *v236; // r6
  char *v237; // r12
  _DWORD *v238; // r8
  unsigned int v239; // [sp+Ch] [bp-34h]
  unsigned int v240; // [sp+10h] [bp-30h]

  if ( !a2 )
    return 0;
  v4 = (_DWORD *)a2;
  if ( !dword_14234 )
  {
    dword_1423C = -1;
    dword_14240 = 0x200000;
    dword_14244 = 7;
    pthread_mutex_lock((pthread_mutex_t *)algn_14248);
    if ( !dword_14230 )
    {
      dword_14230 = 1482184792;
      pthread_mutex_init((pthread_mutex_t *)algn_1421C, 0);
      dword_14218 = dword_14244;
    }
    pthread_mutex_unlock((pthread_mutex_t *)algn_14248);
    dword_14234 = sysconf(40);
    v5 = sysconf(40) ? sysconf(40) : dword_14234;
    dword_14238 = v5;
    if ( ((v5 - 1) & v5) != 0 )
      goto LABEL_129;
    a3 = dword_14234 - 1;
    if ( ((dword_14234 - 1) & dword_14234) != 0 )
      goto LABEL_129;
  }
  if ( (dword_14218 & 2) != 0 && pthread_mutex_lock((pthread_mutex_t *)algn_1421C) )
    return 0;
  if ( a1 <= 0xF4 )
  {
    v6 = a1 > 0xA;
    if ( a1 > 0xA )
      a1 = (a1 + 11) & 0xFFFFFFF8;
    a2 = (unsigned int)dword_14058;
    if ( v6 )
      a3 = a1 >> 3;
    v7 = dword_14064[0];
    if ( v6 )
      v8 = a3;
    else
      v8 = 2;
    v9 = (unsigned int)dword_14064[0] >> v8;
    if ( !v6 )
    {
      a3 = v8;
      a1 = 16;
    }
    if ( (v9 & 3) != 0 )
    {
      v10 = !(v9 & 1) + a3;
      v11 = &dword_14058[2 * v10 + 12];
      v12 = dword_14058[2 * v10 + 14];
      v13 = *(_DWORD *)(v12 + 8);
      if ( v11 == (int *)v13 )
      {
        dword_14064[0] &= ~(1 << v10);
      }
      else
      {
        if ( v13 < dword_14074 )
          goto LABEL_129;
        dword_14058[2 * v10 + 14] = v13;
        *(_DWORD *)(v13 + 12) = v11;
      }
      v14 = v12 + 8 * v10;
      *(_DWORD *)(v12 + 4) = (8 * v10) | 3;
      v15 = v12 + 8;
      *(_DWORD *)(v14 + 4) |= 1u;
      goto LABEL_26;
    }
    v18 = dword_1406C;
    if ( a1 <= dword_1406C )
      goto LABEL_66;
    if ( v9 )
    {
      v24 = (-2 * (1 << v8)) | (2 * (1 << v8));
      v25 = v24 & (v9 << v8) & -(v24 & (v9 << v8));
      v55 = v25 == 0;
      v26 = 31 - __clz(-v25 & v25);
      if ( v55 )
        v26 = -1;
      v27 = &dword_14058[2 * v26 + 12];
      v28 = *(_DWORD *)&byte_8[(_DWORD)v27];
      v29 = *(_DWORD *)(v28 + 8);
      if ( v27 == (int *)v29 )
      {
        v7 = dword_14064[0] & ~(1 << v26);
        dword_14064[0] = v7;
      }
      else
      {
        if ( v29 < dword_14074 )
          goto LABEL_129;
        *(_DWORD *)&byte_8[(_DWORD)v27] = v29;
        *(_DWORD *)(v29 + 12) = v27;
      }
      v30 = 8 * v26 - a1;
      v31 = a1 | 3;
      v32 = v28 + a1;
      *(_DWORD *)(v28 + 4) = v31;
      *(_DWORD *)(v32 + 4) = v30 | 1;
      *(_DWORD *)(v32 + v30) = v30;
      if ( v18 )
      {
        v33 = v18 >> 3;
        v34 = 1 << v33;
        v35 = &dword_14058[2 * v33 + 12];
        v36 = dword_14078;
        if ( (v7 & v34) != 0 )
        {
          v37 = v35[2];
          if ( v37 < dword_14074 )
            goto LABEL_129;
        }
        else
        {
          dword_14064[0] = v7 | v34;
          v37 = (unsigned int)v35;
        }
        v35[2] = dword_14078;
        *(_DWORD *)(v37 + 12) = v36;
        *(_DWORD *)(v36 + 8) = v37;
        *(_DWORD *)(v36 + 12) = v35;
      }
      v15 = v28 + 8;
      dword_1406C = v30;
      dword_14078 = v32;
LABEL_26:
      if ( (dword_14218 & 2) == 0 )
        goto LABEL_27;
      goto LABEL_53;
    }
    v73 = dword_14068;
    if ( !dword_14068 )
      goto LABEL_37;
    v74 = -dword_14068 & dword_14068;
    v75 = 31 - __clz(-v74 & v74);
    if ( !v74 )
      v75 = -1;
    v76 = *(_DWORD **)((char *)&dword_14058[v75] + (_DWORD)&dword_138);
    v77 = v76;
    v78 = (v76[1] & 0xFFFFFFFC) - a1;
    while ( 1 )
    {
      a2 = v76[4];
      if ( !a2 )
      {
        a2 = v76[5];
        if ( !a2 )
          break;
      }
      v76 = (_DWORD *)a2;
      if ( (*(_DWORD *)(a2 + 4) & 0xFFFFFFFC) - a1 < v78 )
      {
        v78 = (*(_DWORD *)(a2 + 4) & 0xFFFFFFFC) - a1;
        v77 = (_DWORD *)a2;
      }
    }
    if ( dword_14074 > (unsigned int)v77 )
      goto LABEL_129;
    v79 = (char *)v77 + a1;
    if ( (_DWORD *)((char *)v77 + a1) <= v77 )
      goto LABEL_129;
    v80 = (_DWORD *)v77[3];
    v81 = v77[6];
    if ( v80 == v77 )
    {
      v80 = (_DWORD *)v77[5];
      v192 = v77 + 5;
      if ( v80 || (v80 = (_DWORD *)v77[4], v192 = v77 + 4, v80) )
      {
        while ( 1 )
        {
          v193 = (_DWORD *)v80[5];
          a2 = (unsigned int)(v80 + 5);
          if ( !v193 )
          {
            v193 = (_DWORD *)v80[4];
            a2 = (unsigned int)(v80 + 4);
            if ( !v193 )
              break;
          }
          v192 = (_DWORD *)a2;
          v80 = v193;
        }
        if ( dword_14074 > (unsigned int)v192 )
          goto LABEL_129;
        *v192 = 0;
      }
    }
    else
    {
      v82 = v77[2];
      if ( dword_14074 > v82 )
        goto LABEL_129;
      *(_DWORD *)(v82 + 12) = v80;
      v80[2] = v82;
    }
    if ( !v81 )
      goto LABEL_158;
    v83 = v77[7];
    a2 = (unsigned int)&dword_14058[v83 + 74];
    if ( *(_DWORD **)(a2 + 16) == v77 )
    {
      *(_DWORD *)(a2 + 16) = v80;
      if ( v80 )
      {
        v84 = dword_14074;
        goto LABEL_151;
      }
      dword_14068 = v73 & ~(1 << v83);
    }
    else
    {
      v84 = dword_14074;
      if ( v81 < dword_14074 )
        goto LABEL_129;
      a2 = *(_DWORD *)(v81 + 16);
      if ( (_DWORD *)a2 == v77 )
        *(_DWORD *)(v81 + 16) = v80;
      else
        *(_DWORD *)(v81 + 20) = v80;
      if ( v80 )
      {
LABEL_151:
        if ( (unsigned int)v80 < v84 )
          goto LABEL_129;
        v85 = v77[4];
        v80[6] = v81;
        if ( v85 )
        {
          if ( v85 < v84 )
            goto LABEL_129;
          v80[4] = v85;
          *(_DWORD *)(v85 + 24) = v80;
        }
        a2 = v77[5];
        if ( a2 )
        {
          if ( a2 < v84 )
            goto LABEL_129;
          v80[5] = a2;
          *(_DWORD *)(a2 + 24) = v80;
        }
        goto LABEL_158;
      }
    }
LABEL_158:
    if ( v78 <= 0xF )
    {
      v190 = v78 + a1;
      v191 = *(_DWORD *)((char *)v77 + v190 + 4);
      v77[1] = v190 | 3;
      *(_DWORD *)((char *)v77 + v190 + 4) = v191 | 1;
    }
    else
    {
      v86 = dword_1406C;
      a2 = v78 | 1;
      v55 = dword_1406C == 0;
      v77[1] = a1 | 3;
      *((_DWORD *)v79 + 1) = v78 | 1;
      *(_DWORD *)&v79[v78] = v78;
      if ( !v55 )
      {
        v87 = v86 >> 3;
        v88 = 1 << v87;
        v89 = &dword_14058[2 * v87 + 12];
        a2 = dword_14078;
        if ( (v88 & dword_14064[0]) != 0 )
        {
          v90 = v89[2];
          if ( v90 < dword_14074 )
            goto LABEL_129;
        }
        else
        {
          dword_14064[0] |= v88;
          v90 = (unsigned int)v89;
        }
        v89[2] = dword_14078;
        *(_DWORD *)(v90 + 12) = a2;
        *(_DWORD *)(a2 + 8) = v90;
        *(_DWORD *)(a2 + 12) = v89;
      }
      dword_1406C = v78;
      dword_14078 = (int)v77 + a1;
    }
    v15 = (unsigned int)(v77 + 2);
    if ( v15 )
      goto LABEL_126;
    v18 = dword_1406C;
    goto LABEL_36;
  }
  if ( a1 > 0xFFFFFFBF )
  {
    v18 = dword_1406C;
    if ( dword_1406C != -1 )
    {
      a1 = -1;
      goto LABEL_44;
    }
    v40 = dword_14078;
    v41 = dword_1406C;
    goto LABEL_69;
  }
  v17 = dword_14068;
  a1 = (a1 + 11) & 0xFFFFFFF8;
  if ( !dword_14068 )
  {
LABEL_35:
    v18 = dword_1406C;
    goto LABEL_36;
  }
  v42 = a1 >> 8;
  v43 = -a1;
  if ( a1 >> 8 )
  {
    if ( v42 >= 0x10000 )
    {
      v48 = (_DWORD *)dword_1420C;
      if ( dword_1420C )
      {
        LOBYTE(v42) = 31;
LABEL_254:
        LOBYTE(v49) = 0;
LABEL_75:
        v50 = 0;
        v51 = a1 << v49;
        v52 = 0;
        while ( 1 )
        {
          v53 = (v48[1] & 0xFFFFFFFC) - a1;
          if ( v53 < v43 )
          {
            v43 = (v48[1] & 0xFFFFFFFC) - a1;
            v52 = v48;
            if ( !v53 )
              goto LABEL_95;
          }
          a2 = (v51 >> 31) + 4;
          v54 = (_DWORD *)v48[5];
          v48 = (_DWORD *)v48[a2];
          v55 = v54 == v48;
          if ( v54 != v48 )
            v55 = v54 == 0;
          if ( !v55 )
            v50 = v54;
          if ( !v48 )
          {
            v56 = v52 == 0;
            if ( !v52 )
              v56 = v50 == 0;
            if ( v56 )
              goto LABEL_88;
            v48 = v50;
            if ( v50 )
              goto LABEL_95;
            goto LABEL_102;
          }
          v51 *= 2;
        }
      }
LABEL_257:
      v18 = dword_1406C;
      goto LABEL_36;
    }
    v44 = ((v42 - 256) >> 16) & 8;
    v45 = (((v42 << v44) - 4096) >> 16) & 4;
    v46 = v42 << v44 << v45;
    v47 = ((v46 - 0x4000) >> 16) & 2;
    a2 = v44 + v45 + v47;
    v42 = ((a1 >> ((v46 << v47 >> 15) - a2 + 21)) & 1) + 2 * ((v46 << v47 >> 15) - a2 + 14);
    v48 = (_DWORD *)dword_14058[v42 + 78];
    if ( v48 )
    {
      if ( v42 != 31 )
      {
        v49 = 25 - (v42 >> 1);
        goto LABEL_75;
      }
      goto LABEL_254;
    }
LABEL_88:
    v57 = -2 << v42;
  }
  else
  {
    v48 = (_DWORD *)dword_14190;
    if ( dword_14190 )
    {
      LOBYTE(v49) = 25;
      goto LABEL_75;
    }
    v57 = -2;
  }
  v58 = v57 & dword_14068;
  if ( !v58 )
    goto LABEL_257;
  v59 = -v58 & v58;
  v55 = v59 == 0;
  v60 = 31 - __clz(-v59 & v59);
  if ( v55 )
    v60 = -1;
  v48 = *(_DWORD **)((char *)&dword_14058[v60] + (_DWORD)&dword_138);
  if ( !v48 )
    goto LABEL_35;
  v52 = 0;
  do
  {
    while ( 1 )
    {
LABEL_95:
      v61 = (v48[1] & 0xFFFFFFFC) - a1;
      v62 = v61 >= v43;
      if ( v61 < v43 )
        v43 = (v48[1] & 0xFFFFFFFC) - a1;
      if ( !v62 )
        v52 = v48;
      if ( !v48[4] )
        break;
      v48 = (_DWORD *)v48[4];
    }
    v48 = (_DWORD *)v48[5];
  }
  while ( v48 );
LABEL_102:
  if ( !v52 )
    goto LABEL_257;
  v18 = dword_1406C;
  a2 = dword_1406C - a1;
  if ( dword_1406C - a1 <= v43 )
    goto LABEL_36;
  if ( (unsigned int)v52 < dword_14074 )
    goto LABEL_129;
  v63 = (_DWORD *)((char *)v52 + a1);
  if ( v52 >= (_DWORD *)((char *)v52 + a1) )
    goto LABEL_129;
  v64 = (_DWORD *)v52[3];
  v65 = v52[6];
  if ( v52 == v64 )
  {
    v64 = (_DWORD *)v52[5];
    v173 = v52 + 5;
    if ( v64 || (v64 = (_DWORD *)v52[4], v173 = v52 + 4, v64) )
    {
      while ( 1 )
      {
        v174 = (_DWORD *)v64[5];
        a2 = (unsigned int)(v64 + 5);
        if ( !v174 )
        {
          v174 = (_DWORD *)v64[4];
          a2 = (unsigned int)(v64 + 4);
          if ( !v174 )
            break;
        }
        v173 = (_DWORD *)a2;
        v64 = v174;
      }
      if ( dword_14074 > (unsigned int)v173 )
        goto LABEL_129;
      *v173 = 0;
    }
  }
  else
  {
    v66 = v52[2];
    if ( dword_14074 > v66 )
      goto LABEL_129;
    *(_DWORD *)(v66 + 12) = v64;
    v64[2] = v66;
  }
  if ( !v65 )
    goto LABEL_123;
  v67 = v52[7];
  v68 = &dword_14058[v67 + 74];
  if ( v52 == (_DWORD *)v68[4] )
  {
    v68[4] = (int)v64;
    if ( v64 )
    {
      v69 = dword_14074;
      goto LABEL_116;
    }
    a2 = v17 & ~(1 << v67);
    dword_14068 = a2;
  }
  else
  {
    v69 = dword_14074;
    if ( v65 < dword_14074 )
      goto LABEL_129;
    a2 = *(_DWORD *)(v65 + 16);
    if ( v52 == (_DWORD *)a2 )
      *(_DWORD *)(v65 + 16) = v64;
    else
      *(_DWORD *)(v65 + 20) = v64;
    if ( v64 )
    {
LABEL_116:
      if ( (unsigned int)v64 < v69 )
        goto LABEL_129;
      v70 = v52[4];
      v64[6] = v65;
      if ( v70 )
      {
        if ( v70 < v69 )
          goto LABEL_129;
        v64[4] = v70;
        *(_DWORD *)(v70 + 24) = v64;
      }
      a2 = v52[5];
      if ( a2 )
      {
        if ( a2 < v69 )
          goto LABEL_129;
        v64[5] = a2;
        *(_DWORD *)(a2 + 24) = v64;
      }
      goto LABEL_123;
    }
  }
LABEL_123:
  if ( v43 > 0xF )
  {
    v131 = v43 >> 3;
    v52[1] = a1 | 3;
    v63[1] = v43 | 1;
    *(_DWORD *)((char *)v63 + v43) = v43;
    if ( v43 >> 3 > 0x1F )
    {
      v162 = v43 >> 8;
      if ( v43 >> 8 < 0x10000 )
      {
        v165 = ((v162 - 256) >> 16) & 8;
        v166 = v162 << v165;
        v167 = ((v166 - 4096) >> 16) & 4;
        v168 = v166 << v167;
        v169 = ((unsigned int)(v168 - 0x4000) >> 16) & 2;
        v170 = ((unsigned int)(v168 << v169) >> 15) - (v165 + v167 + v169);
        v164 = ((v43 >> (v170 + 21)) & 1) + 2 * (v170 + 14);
        v163 = 1 << v164;
      }
      else
      {
        v163 = 0x80000000;
        v164 = 31;
      }
      a2 = (unsigned int)dword_14058;
      v171 = dword_14068;
      v63[7] = v164;
      v63[5] = 0;
      v63[4] = 0;
      if ( (v163 & v171) != 0 )
      {
        v184 = &dword_14058[v164];
        if ( v164 == 31 )
          LOBYTE(v185) = 0;
        else
          v185 = 25 - (v164 >> 1);
        a2 = v184[78];
        v186 = v43 << v185;
        while ( v43 != (*(_DWORD *)(a2 + 4) & 0xFFFFFFFC) )
        {
          v187 = (v186 >> 31) + 4;
          v186 *= 2;
          if ( !*(_DWORD *)(a2 + 4 * v187) )
          {
            if ( dword_14074 > a2 + 4 * v187 )
              goto LABEL_129;
            *(_DWORD *)(a2 + 4 * v187) = v63;
            v63[6] = a2;
            v63[3] = v63;
            v63[2] = v63;
            goto LABEL_125;
          }
          a2 = *(_DWORD *)(a2 + 4 * v187);
        }
        v188 = *(_DWORD *)(a2 + 8);
        v189 = dword_14074 <= a2;
        if ( v188 < dword_14074 )
          v189 = 0;
        if ( !v189 )
          goto LABEL_129;
        *(_DWORD *)(v188 + 12) = v63;
        *(_DWORD *)(a2 + 8) = v63;
        v63[2] = v188;
        v63[3] = a2;
        v63[6] = 0;
      }
      else
      {
        v172 = v164 + 74;
        dword_14058[v172 + 4] = (int)v63;
        dword_14068 = v163 | v171;
        v63[6] = &dword_14058[v172 + 4];
        v63[3] = v63;
        v63[2] = v63;
      }
    }
    else
    {
      v132 = 1 << v131;
      v133 = &dword_14058[2 * v131 + 12];
      if ( (v132 & dword_14064[0]) != 0 )
      {
        a2 = dword_14074;
        v134 = v133[2];
        if ( v134 < dword_14074 )
          goto LABEL_129;
      }
      else
      {
        a2 = v132 | dword_14064[0];
        dword_14064[0] |= v132;
        v134 = (unsigned int)v133;
      }
      v133[2] = (int)v63;
      *(_DWORD *)(v134 + 12) = v63;
      v63[2] = v134;
      v63[3] = v133;
    }
  }
  else
  {
    v71 = v43 + a1;
    v72 = *(_DWORD *)((char *)v52 + v71 + 4);
    v52[1] = v71 | 3;
    *(_DWORD *)((char *)v52 + v71 + 4) = v72 | 1;
  }
LABEL_125:
  v15 = (unsigned int)(v52 + 2);
  if ( v15 )
    goto LABEL_126;
  v18 = dword_1406C;
LABEL_36:
  if ( a1 <= v18 )
  {
LABEL_66:
    v38 = v18 - a1;
    v40 = dword_14078;
    if ( v18 - a1 > 0xF )
    {
      v39 = dword_14078 + a1;
      dword_1406C = v38;
      dword_14078 = v39;
      *(_DWORD *)(v39 + 4) = v38 | 1;
      *(_DWORD *)(v39 + v38) = v38;
      *(_DWORD *)(v40 + 4) = a1 | 3;
LABEL_68:
      v15 = v40 + 8;
      goto LABEL_26;
    }
    v41 = v18 | 3;
LABEL_69:
    dword_1406C = 0;
    dword_14078 = 0;
    *(_DWORD *)(v40 + 4) = v41;
    *(_DWORD *)(v40 + v18 + 4) |= 1u;
    goto LABEL_68;
  }
LABEL_37:
  if ( dword_14070 > a1 )
  {
    v19 = dword_1407C;
    dword_14070 -= a1;
    dword_1407C += a1;
    v15 = v19 + 8;
    *(_DWORD *)(dword_1407C + 4) = dword_14070 | 1;
    *(_DWORD *)(v19 + 4) = a1 | 3;
    goto LABEL_26;
  }
LABEL_44:
  if ( dword_14234 )
  {
    v21 = dword_14238;
  }
  else
  {
    dword_1423C = -1;
    dword_14240 = 0x200000;
    dword_14244 = 7;
    pthread_mutex_lock((pthread_mutex_t *)algn_14248);
    if ( !dword_14230 )
    {
      dword_14230 = 1482184792;
      pthread_mutex_init((pthread_mutex_t *)algn_1421C, 0);
      dword_14218 = dword_14244;
    }
    pthread_mutex_unlock((pthread_mutex_t *)algn_14248);
    dword_14234 = sysconf(40);
    if ( sysconf(40) )
      v21 = sysconf(40);
    else
      v21 = dword_14234;
    dword_14238 = v21;
    if ( ((v21 - 1) & v21) != 0 || ((dword_14234 - 1) & dword_14234) != 0 )
      goto LABEL_129;
  }
  if ( (dword_14218 & 1) == 0 || a1 < dword_1423C )
    goto LABEL_49;
  a2 = a1 + 31 + v21;
  v22 = -v21;
  v125 = a2 & -v21;
  if ( a1 >= v125 )
    goto LABEL_50;
  if ( dword_14014 != -1 )
  {
    if ( dword_1405C )
    {
LABEL_241:
      v126 = sub_A568(v125, a2);
LABEL_242:
      if ( v126 != -1 )
        goto LABEL_243;
      v21 = dword_14238;
      v22 = -dword_14238;
LABEL_50:
      v23 = v22 & (a1 + 41 + v21);
      if ( a1 >= v23 )
      {
LABEL_51:
        *(_DWORD *)_errno() = 12;
        if ( (dword_14218 & 2) == 0 )
          return 0;
        v15 = 0;
        goto LABEL_53;
      }
      v91 = &dword_14014;
      if ( dword_14014 == -1 )
      {
        v121 = mmap(0, v23, 7, 34, dword_14014, 0);
        if ( v121 != (void *)-1 )
        {
          v92 = (unsigned int)v121;
          goto LABEL_183;
        }
        v122 = *(_DWORD *)_errno();
        v123 = v122 == 13;
        if ( v122 != 13 )
          v123 = v122 == 1;
        if ( !v123 )
          goto LABEL_51;
        if ( dword_1405C && dword_14014 != -1 )
          goto LABEL_181;
      }
      else if ( dword_1405C )
      {
LABEL_181:
        v92 = sub_A568(v23, a2);
        goto LABEL_182;
      }
      v91 = (int *)&algn_14248[4];
      pthread_mutex_lock((pthread_mutex_t *)&algn_14248[4]);
      v92 = sub_A568(v23, v124);
      pthread_mutex_unlock((pthread_mutex_t *)&algn_14248[4]);
LABEL_182:
      if ( v92 == -1 )
        goto LABEL_51;
LABEL_183:
      if ( v23 + dword_14210 > dword_14214 )
        dword_14214 = v23 + dword_14210;
      dword_14210 += v23;
      v93 = (char *)dword_1407C;
      if ( dword_1407C )
      {
        v94 = &dword_14220;
        while ( 1 )
        {
          v95 = v94[1];
          if ( v92 == *v94 + v95 )
            break;
          v94 = (int *)v94[2];
          if ( !v94 )
          {
            v96 = v92 + v23;
LABEL_191:
            v239 = dword_14074;
            v97 = dword_14074 > v92;
            if ( dword_14074 > v92 )
              dword_14074 = v92;
            if ( v97 )
              v239 = v92;
            v98 = &dword_14220;
            while ( *v98 != v96 )
            {
              v98 = (int *)v98[2];
              if ( !v98 )
              {
                v99 = &dword_14220;
                goto LABEL_199;
              }
            }
            if ( *(_DWORD *)(v96 - 4) != v98[3] )
            {
              v99 = &dword_14220;
LABEL_199:
              while ( 1 )
              {
                if ( dword_1407C >= (unsigned int)*v99 )
                {
                  v100 = *v99 + v99[1];
                  if ( dword_1407C < v100 )
                    break;
                }
                v99 = (int *)v99[2];
                if ( !v99 )
                  __und(0);
              }
              v101 = v100 - 39;
              if ( ((v100 - 39) & 7) != 0 )
                v101 = 39 - v100;
              v240 = v100;
              if ( ((v100 - 39) & 7) != 0 )
                v91 = (int *)(v101 & 7);
              if ( ((v100 - 39) & 7) != 0 )
                v102 = (int)v91 - 47;
              else
                v102 = -47;
              v103 = (char *)(v100 + v102);
              v104 = v92 + 8;
              if ( (unsigned int)v103 < dword_1407C + 16 )
                v103 = (char *)dword_1407C;
              v105 = v104 & 7;
              if ( (v104 & 7) != 0 )
                v105 = -v104;
              if ( (v104 & 7) != 0 )
                v105 &= 7u;
              v106 = v23 - 40 - v105;
              v107 = v92 + v105;
              v108 = dword_14220;
              v109 = dword_14224;
              v110 = dword_14228;
              v111 = dword_1422C;
              dword_14070 = v106;
              dword_1407C = v107;
              *(_DWORD *)(v107 + 4) = v106 | 1;
              *(_DWORD *)(v107 + v106 + 4) = 40;
              dword_14080 = dword_14240;
              *((_DWORD *)v103 + 1) = 27;
              *((_DWORD *)v103 + 2) = v108;
              *((_DWORD *)v103 + 3) = v109;
              *((_DWORD *)v103 + 4) = v110;
              *((_DWORD *)v103 + 5) = v111;
              dword_14224 = v23;
              dword_1422C = *(_DWORD *)(v92 + v23 - 4);
              v112 = *(_DWORD *)(v92 + v23 - 4 + dword_1422C);
              dword_14220 = v92;
              if ( dword_1422C != v112 )
                goto LABEL_129;
              v113 = v103 + 28;
              *(_DWORD *)(v92 + v23 - 4) = 0;
              dword_14228 = (int)(v103 + 8);
              do
                *v113++ = 7;
              while ( v240 > (unsigned int)v113 );
              if ( v93 == v103 )
              {
                v119 = dword_14070;
                goto LABEL_226;
              }
              v114 = v103 - v93;
              v115 = (unsigned int)(v103 - v93) >> 3;
              *((_DWORD *)v103 + 1) &= 0xFFFFFFFE;
              *((_DWORD *)v93 + 1) = (v103 - v93) | 1;
              *(_DWORD *)v103 = v103 - v93;
              if ( v115 <= 0x1F )
              {
                v116 = 1 << v115;
                v117 = &dword_14058[2 * v115 + 12];
                if ( (v116 & dword_14064[0]) != 0 )
                {
                  v118 = (int *)v117[2];
                  if ( (unsigned int)v118 < v239 )
                    goto LABEL_129;
                }
                else
                {
                  dword_14064[0] |= v116;
                  v118 = v117;
                }
                v117[2] = (int)v93;
                v119 = dword_14070;
                v118[3] = (int)v93;
                *((_DWORD *)v93 + 2) = v118;
                *((_DWORD *)v93 + 3) = v117;
                goto LABEL_226;
              }
              v140 = v114 >> 8;
              if ( v114 >> 8 < 0x10000 )
              {
                v143 = ((v140 - 256) >> 16) & 8;
                v144 = v140 << v143;
                v145 = ((unsigned int)(v144 - 4096) >> 16) & 4;
                v146 = v144 << v145;
                v147 = ((unsigned int)(v146 - 0x4000) >> 16) & 2;
                v148 = ((unsigned int)(v146 << v147) >> 15) - (v143 + v145 + v147);
                v142 = ((v114 >> (v148 + 21)) & 1) + 2 * (v148 + 14);
                v141 = 1 << v142;
              }
              else
              {
                v141 = 0x80000000;
                v142 = 31;
              }
              v149 = dword_14068;
              *((_DWORD *)v93 + 7) = v142;
              *((_DWORD *)v93 + 5) = 0;
              *((_DWORD *)v93 + 4) = 0;
              if ( (v141 & v149) == 0 )
              {
                v183 = &dword_14058[v142 + 78];
                *v183 = (int)v93;
                dword_14068 = v141 | v149;
                v119 = dword_14070;
                *((_DWORD *)v93 + 6) = v183;
                *((_DWORD *)v93 + 3) = v93;
                *((_DWORD *)v93 + 2) = v93;
                goto LABEL_226;
              }
              v150 = &dword_14058[v142];
              if ( v142 == 31 )
                LOBYTE(v151) = 0;
              else
                v151 = 25 - (v142 >> 1);
              v152 = v150[78];
              v153 = v114 << v151;
              while ( v114 != (*(_DWORD *)(v152 + 4) & 0xFFFFFFFC) )
              {
                v154 = (v153 >> 31) + 4;
                v153 *= 2;
                if ( !*(_DWORD *)(v152 + 4 * v154) )
                {
                  if ( v239 <= v152 + 4 * v154 )
                  {
                    *(_DWORD *)(v152 + 4 * v154) = v93;
                    v119 = dword_14070;
                    *((_DWORD *)v93 + 6) = v152;
                    *((_DWORD *)v93 + 3) = v93;
                    *((_DWORD *)v93 + 2) = v93;
                    goto LABEL_226;
                  }
LABEL_129:
                  abort();
                }
                v152 = *(_DWORD *)(v152 + 4 * v154);
              }
              v155 = *(_DWORD *)(v152 + 8);
              v156 = v239 <= v152;
              if ( v155 < v239 )
                v156 = 0;
              if ( v156 )
              {
                *(_DWORD *)(v155 + 12) = v93;
                v119 = dword_14070;
                *(_DWORD *)(v152 + 8) = v93;
                *((_DWORD *)v93 + 2) = v155;
                *((_DWORD *)v93 + 3) = v152;
                *((_DWORD *)v93 + 6) = 0;
                goto LABEL_226;
              }
              goto LABEL_129;
            }
            v194 = (v92 + 8) & 7;
            v195 = v98[1];
            if ( v194 )
              v194 = -(v92 + 8) & 7;
            *v98 = v92;
            v98[1] = v195 + v23;
            if ( ((v96 + 8) & 7) != 0 )
              v196 = -(v96 + 8);
            else
              v196 = 0;
            if ( ((v96 + 8) & 7) != 0 )
              v196 &= 7u;
            v197 = v92 + v194;
            v198 = (char *)(v96 + v196);
            v199 = &v198[-v197 - a1];
            *(_DWORD *)(v197 + 4) = a1 | 3;
            v200 = v197 + a1;
            if ( v93 == v198 )
            {
              dword_1407C = v200;
              dword_14070 += (int)v199;
              *(_DWORD *)(v200 + 4) = dword_14070 | 1;
            }
            else if ( v198 == (char *)dword_14078 )
            {
              dword_14078 = v200;
              v211 = (int)&v199[dword_1406C];
              dword_1406C = v211;
              *(_DWORD *)(v200 + 4) = v211 | 1;
              *(_DWORD *)(v200 + v211) = v211;
            }
            else
            {
              v201 = *((_DWORD *)v198 + 1);
              if ( (v201 & 2) == 0 )
              {
                v202 = v201 & 0xFFFFFFFC;
                v203 = (v201 & 0xFFFFFFFC) >> 3;
                if ( v203 > 0x1F )
                {
                  v228 = (char *)*((_DWORD *)v198 + 3);
                  v229 = *((_DWORD *)v198 + 6);
                  if ( v198 == v228 )
                  {
                    v228 = (char *)*((_DWORD *)v198 + 5);
                    v236 = v198 + 20;
                    if ( v228 || (v228 = (char *)*((_DWORD *)v198 + 4), v236 = v198 + 16, v228) )
                    {
                      while ( 1 )
                      {
                        v237 = (char *)*((_DWORD *)v228 + 5);
                        v238 = v228 + 20;
                        if ( !v237 )
                        {
                          v237 = (char *)*((_DWORD *)v228 + 4);
                          v238 = v228 + 16;
                          if ( !v237 )
                            break;
                        }
                        v236 = v238;
                        v228 = v237;
                      }
                      if ( v239 > (unsigned int)v236 )
                        goto LABEL_129;
                      *v236 = 0;
                    }
                  }
                  else
                  {
                    v230 = *((_DWORD *)v198 + 2);
                    if ( v230 < v239 )
                      goto LABEL_129;
                    *(_DWORD *)(v230 + 12) = v228;
                    *((_DWORD *)v228 + 2) = v230;
                  }
                  if ( v229 )
                  {
                    v231 = *((_DWORD *)v198 + 7);
                    v232 = &dword_14058[v231 + 74];
                    if ( v198 == (char *)v232[4] )
                    {
                      v232[4] = (int)v228;
                      if ( !v228 )
                      {
                        dword_14068 &= ~(1 << v231);
                        goto LABEL_375;
                      }
                      v233 = dword_14074;
                    }
                    else
                    {
                      v233 = dword_14074;
                      if ( v229 < dword_14074 )
                        goto LABEL_129;
                      if ( v198 == *(char **)(v229 + 16) )
                        *(_DWORD *)(v229 + 16) = v228;
                      else
                        *(_DWORD *)(v229 + 20) = v228;
                      if ( !v228 )
                        goto LABEL_375;
                    }
                    if ( (unsigned int)v228 < v233 )
                      goto LABEL_129;
                    v234 = *((_DWORD *)v198 + 4);
                    *((_DWORD *)v228 + 6) = v229;
                    if ( v234 )
                    {
                      if ( v234 < v233 )
                        goto LABEL_129;
                      *((_DWORD *)v228 + 4) = v234;
                      *(_DWORD *)(v234 + 24) = v228;
                    }
                    v235 = *((_DWORD *)v198 + 5);
                    if ( v235 )
                    {
                      if ( v235 < v233 )
                        goto LABEL_129;
                      *((_DWORD *)v228 + 5) = v235;
                      *(_DWORD *)(v235 + 24) = v228;
                    }
                  }
                }
                else
                {
                  v204 = (int *)*((_DWORD *)v198 + 2);
                  v205 = (int *)*((_DWORD *)v198 + 3);
                  if ( v204 == v205 )
                  {
                    dword_14064[0] &= ~(1 << v203);
                  }
                  else
                  {
                    v206 = &dword_14058[2 * v203 + 12];
                    if ( v204 == v206 )
                      goto LABEL_373;
                    if ( (unsigned int)v204 < v239 )
                      goto LABEL_129;
                    if ( v205 != v206 )
                    {
LABEL_373:
                      if ( (unsigned int)v205 < v239 )
                        goto LABEL_129;
                    }
                    v204[3] = (int)v205;
                    v205[2] = (int)v204;
                  }
                }
LABEL_375:
                v198 += v202;
                v201 = *((_DWORD *)v198 + 1);
                v199 += v202;
              }
              v207 = (unsigned int)v199 >> 3;
              *((_DWORD *)v198 + 1) = v201 & 0xFFFFFFFE;
              *(_DWORD *)(v200 + 4) = (unsigned int)v199 | 1;
              *(_DWORD *)&v199[v200] = v199;
              if ( (unsigned int)v199 >> 3 > 0x1F )
              {
                v212 = (unsigned int)v199 >> 8;
                if ( (unsigned int)v199 >> 8 < 0x10000 )
                {
                  v215 = ((v212 - 256) >> 16) & 8;
                  v216 = v212 << v215;
                  v217 = ((unsigned int)(v216 - 4096) >> 16) & 4;
                  v218 = v216 << v217;
                  v219 = ((unsigned int)(v218 - 0x4000) >> 16) & 2;
                  v214 = (((unsigned int)v199 >> (((unsigned int)(v218 << v219) >> 15) - (v215 + v217 + v219) + 21)) & 1)
                       + 2 * (((unsigned int)(v218 << v219) >> 15) - (v215 + v217 + v219) + 14);
                  v213 = 1 << v214;
                }
                else
                {
                  v213 = 0x80000000;
                  v214 = 31;
                }
                v220 = dword_14068;
                v55 = (v213 & dword_14068) == 0;
                v221 = &dword_14058[v214 + 74];
                *(_DWORD *)(v200 + 28) = v214;
                *(_DWORD *)(v200 + 20) = 0;
                *(_DWORD *)(v200 + 16) = 0;
                if ( v55 )
                {
                  v221[4] = v200;
                  dword_14068 = v213 | v220;
                  *(_DWORD *)(v200 + 24) = v221 + 4;
                  *(_DWORD *)(v200 + 12) = v200;
                  *(_DWORD *)(v200 + 8) = v200;
                }
                else
                {
                  if ( v214 == 31 )
                    LOBYTE(v222) = 0;
                  else
                    v222 = 25 - (v214 >> 1);
                  v223 = v221[4];
                  v224 = (_DWORD)v199 << v222;
                  while ( v199 != (char *)(*(_DWORD *)(v223 + 4) & 0xFFFFFFFC) )
                  {
                    v225 = (v224 >> 31) + 4;
                    v224 *= 2;
                    if ( !*(_DWORD *)(v223 + 4 * v225) )
                    {
                      if ( dword_14074 > v223 + 4 * v225 )
                        goto LABEL_129;
                      *(_DWORD *)(v223 + 4 * v225) = v200;
                      *(_DWORD *)(v200 + 24) = v223;
                      *(_DWORD *)(v200 + 12) = v200;
                      *(_DWORD *)(v200 + 8) = v200;
                      goto LABEL_380;
                    }
                    v223 = *(_DWORD *)(v223 + 4 * v225);
                  }
                  v226 = *(_DWORD *)(v223 + 8);
                  v227 = dword_14074 <= v223;
                  if ( v226 < dword_14074 )
                    v227 = 0;
                  if ( !v227 )
                    goto LABEL_129;
                  *(_DWORD *)(v226 + 12) = v200;
                  *(_DWORD *)(v223 + 8) = v200;
                  *(_DWORD *)(v200 + 8) = v226;
                  *(_DWORD *)(v200 + 12) = v223;
                  *(_DWORD *)(v200 + 24) = 0;
                }
              }
              else
              {
                v208 = 1 << v207;
                v209 = &dword_14058[2 * v207 + 12];
                if ( (v208 & dword_14064[0]) != 0 )
                {
                  v210 = v209[2];
                  if ( v210 < dword_14074 )
                    goto LABEL_129;
                }
                else
                {
                  dword_14064[0] |= v208;
                  v210 = (unsigned int)v209;
                }
                v209[2] = v200;
                *(_DWORD *)(v210 + 12) = v200;
                *(_DWORD *)(v200 + 8) = v210;
                *(_DWORD *)(v200 + 12) = v209;
              }
            }
LABEL_380:
            v15 = v197 + 8;
            goto LABEL_26;
          }
        }
        v96 = v92 + v23;
        v91 = *(int **)(v92 + v23 - 4);
        if ( v91 != (int *)v94[3] || dword_1407C < (unsigned int)*v94 || dword_1407C >= v92 )
          goto LABEL_191;
        v135 = dword_1407C + 8;
        v136 = dword_14070;
        v137 = (dword_1407C + 8) & 7;
        v94[1] = v95 + v23;
        if ( ((unsigned int)(v93 + 8) & 7) != 0 )
          v135 = -v135;
        if ( ((unsigned int)(v93 + 8) & 7) != 0 )
          v137 = v135 & 7;
        v138 = (int)&v93[v137];
        v119 = v23 + v136 - v137;
        v139 = dword_14240;
        dword_1407C = v138;
        dword_14070 = v119;
        *(_DWORD *)(v138 + 4) = v119 | 1;
        *(_DWORD *)(v138 + v119 + 4) = 40;
        dword_14080 = v139;
      }
      else
      {
        dword_14224 = v23;
        dword_1422C = *(_DWORD *)(v92 + v23 - 4);
        v175 = *(_DWORD *)(v92 + v23 - 4 + dword_1422C);
        dword_14074 = v92;
        dword_14220 = v92;
        if ( dword_1422C != v175 )
          goto LABEL_129;
        v176 = dword_14230;
        v177 = dword_1407C;
        *(_DWORD *)(v92 + v23 - 4) = dword_1407C;
        dword_14084 = v176;
        do
        {
          v178 = &dword_14064[2 * v177++];
          v178 += 9;
          v178[3] = (int)v178;
          v178[2] = (int)v178;
        }
        while ( v177 != 32 );
        v179 = v92 + 8;
        v180 = (v92 + 8) & 7;
        if ( v180 )
          v179 = -v179;
        if ( ((v92 + 8) & 7) != 0 )
          v180 = v179 & 7;
        v181 = v92 + v180;
        v119 = v23 - 40 - v180;
        v182 = dword_14240;
        dword_1407C = v181;
        dword_14070 = v119;
        *(_DWORD *)(v181 + 4) = v119 | 1;
        *(_DWORD *)(v181 + v119 + 4) = 40;
        dword_14080 = v182;
      }
LABEL_226:
      if ( a1 < v119 )
      {
        v120 = dword_1407C;
        dword_14070 = v119 - a1;
        dword_1407C += a1;
        v15 = v120 + 8;
        *(_DWORD *)(dword_1407C + 4) = (v119 - a1) | 1;
        *(_DWORD *)(v120 + 4) = a1 | 3;
        goto LABEL_26;
      }
      goto LABEL_51;
    }
LABEL_295:
    pthread_mutex_lock((pthread_mutex_t *)&algn_14248[4]);
    v161 = sub_A568(v125, v160);
    pthread_mutex_unlock((pthread_mutex_t *)&algn_14248[4]);
    v126 = v161;
    goto LABEL_242;
  }
  v157 = mmap(0, v125, 7, 34, dword_14014, 0);
  if ( v157 == (void *)-1 )
  {
    v158 = *(_DWORD *)_errno();
    v159 = v158 == 13;
    if ( v158 != 13 )
      v159 = v158 == 1;
    if ( !v159 )
    {
      v21 = dword_14238;
      v22 = -dword_14238;
      goto LABEL_50;
    }
    if ( dword_1405C && dword_14014 != -1 )
      goto LABEL_241;
    goto LABEL_295;
  }
  v126 = (unsigned int)v157;
LABEL_243:
  v127 = (v126 + 8) & 7;
  if ( v127 )
    v127 = -(v126 + 8) & 7;
  v128 = v126 + v127;
  v129 = v125 - v127 - 16;
  if ( ((v126 + 8) & 7) != 0 )
    v130 = v127 | 1;
  else
    v130 = 1;
  v6 = dword_14074 > v126;
  *(_DWORD *)(v126 + v127) = v130;
  *(_DWORD *)(v128 + 4) = v129 | 2;
  *(_DWORD *)(v128 + v129 + 4) = 7;
  *(_DWORD *)(v126 + v125 - 8) = 0;
  if ( v6 )
    dword_14074 = v126;
  a2 = v125 + dword_14210;
  if ( v125 + dword_14210 > dword_14214 )
    dword_14214 = v125 + dword_14210;
  v15 = v128 + 8;
  dword_14210 += v125;
  if ( !v15 )
  {
    v21 = dword_14238;
LABEL_49:
    v22 = -v21;
    goto LABEL_50;
  }
LABEL_126:
  if ( (dword_14218 & 2) != 0 )
  {
LABEL_53:
    pthread_mutex_unlock((pthread_mutex_t *)algn_1421C);
LABEL_27:
    if ( v15 )
      goto LABEL_28;
    return 0;
  }
LABEL_28:
  v16 = &dword_14220;
  while ( *v16 > v15 || v15 >= *v16 + v16[1] )
  {
    v16 = (int *)v16[2];
    if ( !v16 )
      __und(0);
  }
  result = v15;
  *v4 = v15 + v16[3];
  return result;
}
// A95C: variable 'a3' is possibly undefined
// B278: variable 'a2' is possibly undefined
// B574: variable 'v124' is possibly undefined
// BA78: variable 'v160' is possibly undefined
// 138: using guessed type int;
// 15A8: using guessed type int _errno(void);
// 14014: using guessed type int dword_14014;
// 14058: using guessed type int dword_14058[];
// 1405C: using guessed type int dword_1405C;
// 14064: using guessed type int dword_14064[];
// 14068: using guessed type int dword_14068;
// 1406C: using guessed type int dword_1406C;
// 14070: using guessed type int dword_14070;
// 14074: using guessed type int dword_14074;
// 14078: using guessed type int dword_14078;
// 1407C: using guessed type int dword_1407C;
// 14080: using guessed type int dword_14080;
// 14084: using guessed type int dword_14084;
// 14190: using guessed type int dword_14190;
// 1420C: using guessed type int dword_1420C;
// 14210: using guessed type int dword_14210;
// 14214: using guessed type int dword_14214;
// 14218: using guessed type int dword_14218;
// 14220: using guessed type int dword_14220;
// 14224: using guessed type int dword_14224;
// 14228: using guessed type int dword_14228;
// 1422C: using guessed type int dword_1422C;
// 14230: using guessed type int dword_14230;
// 14234: using guessed type int dword_14234;
// 14238: using guessed type int dword_14238;
// 1423C: using guessed type int dword_1423C;
// 14240: using guessed type int dword_14240;
// 14244: using guessed type int dword_14244;

//----- (0000C388) --------------------------------------------------------
int *__fastcall sub_C388(int *result)
{
  int *v1; // r5
  int *v2; // r4
  int v3; // r2
  unsigned int v4; // r2
  int *v5; // r0
  unsigned int v6; // r12
  unsigned int v7; // r12
  unsigned int v8; // r1
  unsigned int v9; // r5
  int *v10; // r3
  int v11; // r3
  unsigned int v12; // r3
  int v13; // r2
  int *v14; // r3
  unsigned int v15; // r2
  int v16; // r0
  int v17; // lr
  unsigned int v18; // r3
  unsigned int v19; // r12
  unsigned int v20; // r3
  unsigned int v21; // r0
  int *v22; // r12
  unsigned int v23; // r1
  int v24; // lr
  unsigned int v25; // r3
  unsigned int v26; // r3
  unsigned int v27; // r1
  unsigned int v28; // r12
  int v29; // r1
  unsigned int v30; // r0
  int v31; // r0
  unsigned int v32; // r1
  int v33; // r12
  int *v34; // r2
  unsigned int v35; // r12
  size_t v36; // r5
  char *v37; // r4
  int *v38; // r3
  int *v39; // r3
  unsigned int v40; // r6
  unsigned int v41; // r1
  int v42; // lr
  int *v43; // r1
  unsigned int v44; // r1
  unsigned int v45; // r12
  unsigned int v46; // r12
  unsigned int v47; // r0
  unsigned int v48; // r1
  int v49; // r3
  unsigned int v50; // r2
  _BOOL4 v51; // r1
  int *v52; // r3
  unsigned int v53; // r5
  unsigned int v54; // r1
  int v55; // r12
  int *v56; // lr
  unsigned int v57; // r1
  unsigned int v58; // r12
  unsigned int v59; // r0
  int v60; // r1
  char *v61; // r0
  int v62; // lr
  unsigned int v63; // r2
  int *v64; // r7
  unsigned int v65; // r3
  unsigned int v66; // r0
  int v67; // r2
  _DWORD *v68; // r5
  int *v69; // r1
  _DWORD *v70; // r12
  _DWORD *v71; // lr
  int *v72; // r1
  _DWORD *v73; // r12
  char *v74; // r0
  int v75; // r7
  int *v76; // r10
  char *v77; // r5
  size_t v78; // r9
  int v79; // r8
  int v80; // r3
  int v81; // r4
  char *v82; // r4
  int v83; // r6
  unsigned int v84; // r6
  char *v85; // r3
  unsigned int v86; // r2
  unsigned int v87; // r1
  int v88; // r12
  int *v89; // r1
  unsigned int v90; // r1
  unsigned int v91; // r0
  unsigned int v92; // r2
  int *v93; // r3
  char *v94; // r0
  unsigned int v95; // r3
  int v96; // r10
  unsigned int v97; // r2
  unsigned int v98; // r3
  unsigned int v99; // r0
  unsigned int v100; // r3
  unsigned int v101; // r1
  int v102; // r3
  int v103; // r1
  int v104; // r2
  unsigned int v105; // r3
  int *v106; // r2
  char *v107; // r4
  int *v108; // r3
  _BOOL4 v109; // r0
  int v110; // r1
  int v111; // r0
  int v112; // r2
  int v113; // lr
  int v114; // r1
  int v115; // r2
  int v116; // r0
  unsigned int v117; // r2
  unsigned int v118; // r1
  int v119; // r3
  unsigned int v120; // r3
  _BOOL4 v121; // r0
  _DWORD *v122; // r12
  char *v123; // r1
  _DWORD *v124; // r0
  int v125; // [sp+4h] [bp-44h]
  unsigned int len; // [sp+10h] [bp-38h]

  if ( result )
  {
    v1 = result;
    v2 = result - 2;
    if ( !dword_14234 )
    {
      dword_1423C = -1;
      dword_14240 = 0x200000;
      dword_14244 = 7;
      pthread_mutex_lock((pthread_mutex_t *)algn_14248);
      if ( !dword_14230 )
      {
        dword_14230 = 1482184792;
        pthread_mutex_init((pthread_mutex_t *)algn_1421C, 0);
        dword_14218 = dword_14244;
      }
      pthread_mutex_unlock((pthread_mutex_t *)algn_14248);
      dword_14234 = sysconf(40);
      v16 = sysconf(40) ? sysconf(40) : dword_14234;
      dword_14238 = v16;
      if ( ((v16 - 1) & v16) != 0 || ((dword_14234 - 1) & dword_14234) != 0 )
        goto LABEL_32;
    }
    if ( (dword_14218 & 2) == 0 || (result = (int *)pthread_mutex_lock((pthread_mutex_t *)algn_1421C)) == 0 )
    {
      if ( (unsigned int)v2 < dword_14074 )
        goto LABEL_33;
      v3 = *(v1 - 1);
      if ( (v3 & 2) == 0 )
        goto LABEL_33;
      v4 = v3 & 0xFFFFFFFC;
      v5 = (int *)((char *)v2 + v4);
      if ( (*(v1 - 1) & 1) != 0 )
        goto LABEL_15;
      v6 = *(v1 - 2);
      if ( (v6 & 1) != 0 )
      {
        v35 = v6 & 0xFFFFFFFE;
        v36 = v4 + v35 + 16;
        v37 = (char *)v2 - v35;
        v38 = &dword_14220;
        while ( (unsigned int)v37 < *v38 || (unsigned int)v37 >= *v38 + v38[1] )
        {
          v38 = (int *)v38[2];
          if ( !v38 )
            goto LABEL_54;
        }
        v61 = &v37[v38[3]];
        if ( v37 != v61 && munmap(v61, v36) )
          goto LABEL_23;
LABEL_54:
        if ( !munmap(v37, v36) )
          dword_14210 -= v36;
        goto LABEL_23;
      }
      v2 = (int *)((char *)v2 - v6);
      v4 += v6;
      if ( dword_14074 > (unsigned int)v2 )
        goto LABEL_33;
      if ( v2 == (int *)dword_14078 )
      {
        v60 = v5[1];
        if ( (v60 & 3) == 3 )
        {
          dword_1406C = v4;
          v5[1] = v60 & 0xFFFFFFFE;
          v2[1] = v4 | 1;
          *(int *)((char *)v2 + v4) = v4;
          goto LABEL_23;
        }
      }
      else
      {
        v7 = v6 >> 3;
        if ( v7 > 0x1F )
        {
          v39 = (int *)v2[3];
          v40 = v2[6];
          if ( v2 == v39 )
          {
            v39 = (int *)v2[5];
            v68 = v2 + 5;
            if ( v39 || (v39 = (int *)v2[4], v68 = v2 + 4, v39) )
            {
              while ( 1 )
              {
                v69 = (int *)v39[5];
                v70 = v39 + 5;
                if ( !v69 )
                {
                  v69 = (int *)v39[4];
                  v70 = v39 + 4;
                  if ( !v69 )
                    break;
                }
                v68 = v70;
                v39 = v69;
              }
              if ( dword_14074 > (unsigned int)v68 )
                goto LABEL_32;
              *v68 = 0;
            }
          }
          else
          {
            v41 = v2[2];
            if ( dword_14074 > v41 )
              goto LABEL_32;
            *(_DWORD *)(v41 + 12) = v39;
            v39[2] = v41;
          }
          if ( v40 )
          {
            v42 = v2[7];
            v43 = &dword_14058[v42 + 74];
            if ( v2 == (int *)v43[4] )
            {
              v43[4] = (int)v39;
              if ( !v39 )
              {
                dword_14068 &= ~(1 << v42);
                goto LABEL_15;
              }
              v44 = dword_14074;
            }
            else
            {
              v44 = dword_14074;
              if ( v40 < dword_14074 )
                goto LABEL_32;
              if ( v2 == *(int **)(v40 + 16) )
                *(_DWORD *)(v40 + 16) = v39;
              else
                *(_DWORD *)(v40 + 20) = v39;
              if ( !v39 )
                goto LABEL_15;
            }
            if ( (unsigned int)v39 < v44 )
              goto LABEL_32;
            v45 = v2[4];
            v39[6] = v40;
            if ( v45 )
            {
              if ( v45 < v44 )
                goto LABEL_32;
              v39[4] = v45;
              *(_DWORD *)(v45 + 24) = v39;
            }
            v46 = v2[5];
            if ( v46 )
            {
              if ( v46 < v44 )
                goto LABEL_32;
              v39[5] = v46;
              *(_DWORD *)(v46 + 24) = v39;
            }
          }
        }
        else
        {
          v8 = v2[2];
          v9 = v2[3];
          if ( v8 == v9 )
          {
            dword_14064[0] &= ~(1 << v7);
          }
          else
          {
            v10 = &dword_14058[2 * v7 + 12];
            if ( (int *)v8 == v10 )
              goto LABEL_13;
            if ( dword_14074 > v8 )
              goto LABEL_32;
            if ( (int *)v9 != v10 )
            {
LABEL_13:
              if ( dword_14074 > v9 )
                goto LABEL_32;
            }
            *(_DWORD *)(v8 + 12) = v9;
            *(_DWORD *)(v9 + 8) = v8;
          }
        }
      }
LABEL_15:
      if ( v5 > v2 )
      {
        v11 = v5[1];
        if ( (v11 & 1) != 0 )
        {
          if ( (v11 & 2) != 0 )
          {
            v5[1] = v11 & 0xFFFFFFFE;
            v2[1] = v4 | 1;
            *(int *)((char *)v2 + v4) = v4;
            goto LABEL_19;
          }
          if ( v5 != (int *)dword_1407C )
          {
            v17 = dword_14078;
            if ( v5 == (int *)dword_14078 )
            {
              dword_14078 = (int)v2;
              v67 = v4 + dword_1406C;
              dword_1406C = v67;
              v2[1] = v67 | 1;
              *(int *)((char *)v2 + v67) = v67;
              goto LABEL_23;
            }
            v18 = v11 & 0xFFFFFFFC;
            v19 = v18 >> 3;
            v4 += v18;
            if ( v18 >> 3 <= 0x1F )
            {
              v20 = v5[2];
              v21 = v5[3];
              if ( v20 == v21 )
              {
                dword_14064[0] &= ~(1 << v19);
              }
              else
              {
                v22 = &dword_14058[2 * v19 + 12];
                if ( (int *)v20 == v22 )
                  goto LABEL_41;
                if ( v20 < dword_14074 )
                  goto LABEL_32;
                if ( (int *)v21 != v22 )
                {
LABEL_41:
                  if ( v21 < dword_14074 )
                    goto LABEL_32;
                }
                *(_DWORD *)(v20 + 12) = v21;
                *(_DWORD *)(v21 + 8) = v20;
              }
              goto LABEL_43;
            }
            v52 = (int *)v5[3];
            v53 = v5[6];
            if ( v5 == v52 )
            {
              v52 = (int *)v5[5];
              v71 = v5 + 5;
              if ( v52 || (v52 = (int *)v5[4], v71 = v5 + 4, v52) )
              {
                while ( 1 )
                {
                  v72 = (int *)v52[5];
                  v73 = v52 + 5;
                  if ( !v72 )
                  {
                    v72 = (int *)v52[4];
                    v73 = v52 + 4;
                    if ( !v72 )
                      break;
                  }
                  v71 = v73;
                  v52 = v72;
                }
                if ( dword_14074 > (unsigned int)v71 )
                  goto LABEL_32;
                *v71 = 0;
              }
            }
            else
            {
              v54 = v5[2];
              if ( v54 < dword_14074 )
                goto LABEL_32;
              *(_DWORD *)(v54 + 12) = v52;
              v52[2] = v54;
            }
            if ( v53 )
            {
              v55 = v5[7];
              v56 = &dword_14058[v55 + 74];
              if ( v5 == (int *)v56[4] )
              {
                v56[4] = (int)v52;
                if ( v52 )
                {
                  v57 = dword_14074;
                  goto LABEL_97;
                }
                v17 = dword_14078;
                dword_14068 &= ~(1 << v55);
              }
              else
              {
                v57 = dword_14074;
                if ( v53 < dword_14074 )
                  goto LABEL_32;
                if ( v5 == *(int **)(v53 + 16) )
                  *(_DWORD *)(v53 + 16) = v52;
                else
                  *(_DWORD *)(v53 + 20) = v52;
                if ( v52 )
                {
LABEL_97:
                  if ( (unsigned int)v52 < v57 )
                    goto LABEL_32;
                  v58 = v5[4];
                  v52[6] = v53;
                  if ( v58 )
                  {
                    if ( v58 < v57 )
                      goto LABEL_32;
                    v52[4] = v58;
                    *(_DWORD *)(v58 + 24) = v52;
                  }
                  v59 = v5[5];
                  if ( v59 )
                  {
                    if ( v59 < v57 )
                      goto LABEL_32;
                    v52[5] = v59;
                    v17 = dword_14078;
                    *(_DWORD *)(v59 + 24) = v52;
                  }
                  else
                  {
                    v17 = dword_14078;
                  }
                  goto LABEL_43;
                }
                v17 = dword_14078;
              }
            }
            else
            {
              v17 = dword_14078;
            }
LABEL_43:
            v2[1] = v4 | 1;
            *(int *)((char *)v2 + v4) = v4;
            if ( v2 != (int *)v17 )
            {
LABEL_19:
              v12 = v4 >> 3;
              if ( v4 >> 3 > 0x1F )
              {
                v23 = v4 >> 8;
                if ( v4 >> 8 < 0x10000 )
                {
                  v26 = ((v23 - 256) >> 16) & 8;
                  v27 = v23 << v26;
                  v28 = ((v27 - 4096) >> 16) & 4;
                  v29 = v27 << v28;
                  v30 = ((unsigned int)(v29 - 0x4000) >> 16) & 2;
                  v31 = ((unsigned int)(v29 << v30) >> 15) - (v26 + v28 + v30);
                  v25 = ((v4 >> (v31 + 21)) & 1) + 2 * (v31 + 14);
                  v24 = 1 << v25;
                }
                else
                {
                  v24 = 0x80000000;
                  v25 = 31;
                }
                LOBYTE(v32) = 0;
                v33 = dword_14068;
                v2[7] = v25;
                v2[5] = 0;
                v2[4] = 0;
                if ( (v24 & v33) != 0 )
                {
                  if ( v25 != 31 )
                    v32 = v25 >> 1;
                  if ( v25 != 31 )
                    LOBYTE(v32) = 25 - v32;
                  v47 = dword_14058[v25 + 78];
                  v48 = v4 << v32;
                  while ( v4 != (*(_DWORD *)(v47 + 4) & 0xFFFFFFFC) )
                  {
                    v49 = (v48 >> 31) + 4;
                    v48 *= 2;
                    if ( !*(_DWORD *)(v47 + 4 * v49) )
                    {
                      if ( dword_14074 <= v47 + 4 * v49 )
                      {
                        *(_DWORD *)(v47 + 4 * v49) = v2;
                        v2[6] = v47;
                        v2[3] = (int)v2;
                        v2[2] = (int)v2;
                        goto LABEL_23;
                      }
LABEL_32:
                      abort();
                    }
                    v47 = *(_DWORD *)(v47 + 4 * v49);
                  }
                  v50 = *(_DWORD *)(v47 + 8);
                  v51 = dword_14074 <= v47;
                  if ( v50 < dword_14074 )
                    v51 = 0;
                  if ( !v51 )
                    goto LABEL_32;
                  *(_DWORD *)(v50 + 12) = v2;
                  *(_DWORD *)(v47 + 8) = v2;
                  v2[2] = v50;
                  v2[3] = v47;
                  v2[6] = 0;
                }
                else
                {
                  v34 = &dword_14058[v25 + 78];
                  *v34 = (int)v2;
                  dword_14068 = v24 | v33;
                  v2[6] = (int)v34;
                  v2[3] = (int)v2;
                  v2[2] = (int)v2;
                }
              }
              else
              {
                v13 = 1 << v12;
                v14 = &dword_14058[2 * v12 + 12];
                if ( (v13 & dword_14064[0]) != 0 )
                {
                  v15 = v14[2];
                  if ( v15 < dword_14074 )
                    goto LABEL_32;
                }
                else
                {
                  dword_14064[0] |= v13;
                  v15 = (unsigned int)v14;
                }
                v14[2] = (int)v2;
                *(_DWORD *)(v15 + 12) = v2;
                v2[2] = v15;
                v2[3] = (int)v14;
              }
              goto LABEL_23;
            }
            dword_1406C = v4;
LABEL_23:
            result = dword_14058;
            if ( (dword_14218 & 2) != 0 )
              result = (int *)pthread_mutex_unlock((pthread_mutex_t *)algn_1421C);
            return result;
          }
          v62 = dword_14078;
          v63 = v4 + dword_14070;
          dword_1407C = (int)v2;
          dword_14070 = v63;
          v2[1] = v63 | 1;
          if ( v2 == (int *)v62 )
          {
            dword_14078 = 0;
            dword_1406C = 0;
          }
          if ( v63 <= dword_14080 )
            goto LABEL_23;
          if ( v63 > 0x28 )
          {
            v64 = &dword_14220;
            len = dword_14238 * ((dword_14238 - 41 + v63) / dword_14238 - 1);
            while ( 1 )
            {
              v65 = *v64;
              if ( (unsigned int)v2 >= *v64 )
              {
                v66 = v64[1];
                if ( (unsigned int)v2 < v65 + v66 )
                  break;
              }
              v64 = (int *)v64[2];
              if ( !v64 )
                __und(0);
            }
            if ( len <= v66 )
            {
              v106 = &dword_14220;
              do
              {
                if ( (unsigned int)v106 >= v65 && (unsigned int)v106 < v65 + v66 )
                  goto LABEL_147;
                v106 = (int *)v106[2];
              }
              while ( v106 );
              v107 = (char *)(v65 + v66 - len);
              v108 = &dword_14220;
              while ( (unsigned int)v107 < *v108 || (unsigned int)v107 >= *v108 + v108[1] )
              {
                v108 = (int *)v108[2];
                if ( !v108 )
                  goto LABEL_207;
              }
              v74 = &v107[v108[3]];
              if ( v107 == v74 || !munmap(v74, len) )
              {
LABEL_207:
                v109 = munmap(v107, len) == 0;
                if ( !len )
                  v109 = 0;
                if ( v109 )
                {
                  v110 = dword_1407C;
                  v111 = (dword_1407C + 8) & 7;
                  if ( v111 )
                    v111 = -(dword_1407C + 8) & 7;
                  v112 = dword_14070;
                  v113 = dword_14210;
                  v64[1] -= len;
                  v75 = dword_14228;
                  v114 = v110 + v111;
                  v115 = v112 - len - v111;
                  dword_14210 = v113 - len;
                  v116 = dword_14240;
                  dword_1407C = v114;
                  dword_14070 = v115;
                  *(_DWORD *)(v114 + 4) = v115 | 1;
                  *(_DWORD *)(v114 + v115 + 4) = 40;
                  dword_14080 = v116;
                  if ( !v75 )
                    goto LABEL_23;
                  goto LABEL_150;
                }
              }
            }
          }
LABEL_147:
          v75 = dword_14228;
          if ( !dword_14228 )
            goto LABEL_182;
          len = 0;
LABEL_150:
          v76 = &dword_14220;
          v125 = 0;
          while ( 1 )
          {
            v77 = *(char **)v75;
            v78 = *(_DWORD *)(v75 + 4);
            v79 = *(_DWORD *)(v75 + 8);
            v80 = *(_DWORD *)v75 + 8;
            v81 = v80 & 7;
            if ( (v80 & 7) != 0 )
              v81 = -v80 & 7;
            v82 = &v77[v81];
            v83 = *((_DWORD *)v82 + 1);
            if ( (v83 & 2) != 0 || (v84 = v83 & 0xFFFFFFFC, &v82[v84] < &v77[v78 - 40]) )
            {
              v76 = (int *)v75;
              goto LABEL_180;
            }
            if ( v82 == (char *)dword_14078 )
            {
              dword_14078 = 0;
              dword_1406C = 0;
              goto LABEL_174;
            }
            v85 = (char *)*((_DWORD *)v82 + 3);
            v86 = *((_DWORD *)v82 + 6);
            if ( v82 == v85 )
            {
              v85 = (char *)*((_DWORD *)v82 + 5);
              v122 = v82 + 20;
              if ( v85 || (v85 = (char *)*((_DWORD *)v82 + 4), v122 = v82 + 16, v85) )
              {
                while ( 1 )
                {
                  v123 = (char *)*((_DWORD *)v85 + 5);
                  v124 = v85 + 20;
                  if ( !v123 )
                  {
                    v123 = (char *)*((_DWORD *)v85 + 4);
                    v124 = v85 + 16;
                    if ( !v123 )
                      break;
                  }
                  v122 = v124;
                  v85 = v123;
                }
                if ( dword_14074 > (unsigned int)v122 )
                  goto LABEL_32;
                *v122 = 0;
              }
            }
            else
            {
              v87 = *((_DWORD *)v82 + 2);
              if ( v87 < dword_14074 )
                goto LABEL_32;
              *(_DWORD *)(v87 + 12) = v85;
              *((_DWORD *)v85 + 2) = v87;
            }
            if ( v86 )
            {
              v88 = *((_DWORD *)v82 + 7);
              v89 = &dword_14058[v88 + 74];
              if ( v82 == (char *)v89[4] )
              {
                v89[4] = (int)v85;
                if ( !v85 )
                {
                  dword_14068 &= ~(1 << v88);
                  goto LABEL_174;
                }
                v90 = dword_14074;
              }
              else
              {
                v90 = dword_14074;
                if ( v86 < dword_14074 )
                  goto LABEL_32;
                if ( v82 == *(char **)(v86 + 16) )
                  *(_DWORD *)(v86 + 16) = v85;
                else
                  *(_DWORD *)(v86 + 20) = v85;
                if ( !v85 )
                  goto LABEL_174;
              }
              if ( (unsigned int)v85 < v90 )
                goto LABEL_32;
              v91 = *((_DWORD *)v82 + 4);
              *((_DWORD *)v85 + 6) = v86;
              if ( v91 )
              {
                if ( v91 < v90 )
                  goto LABEL_32;
                *((_DWORD *)v85 + 4) = v91;
                *(_DWORD *)(v91 + 24) = v85;
              }
              v92 = *((_DWORD *)v82 + 5);
              if ( v92 )
              {
                if ( v92 < v90 )
                  goto LABEL_32;
                *((_DWORD *)v85 + 5) = v92;
                *(_DWORD *)(v92 + 24) = v85;
              }
            }
LABEL_174:
            v93 = &dword_14220;
            while ( (unsigned int)v77 < *v93 || (unsigned int)v77 >= *v93 + v93[1] )
            {
              v93 = (int *)v93[2];
              if ( !v93 )
                goto LABEL_178;
            }
            v94 = &v77[v93[3]];
            if ( v77 == v94 || !munmap(v94, v78) )
            {
LABEL_178:
              if ( !munmap(v77, v78) )
              {
                v125 += v78;
                dword_14210 -= v78;
                v76[2] = v79;
                goto LABEL_180;
              }
            }
            v95 = v84 >> 8;
            if ( v84 >> 8 )
            {
              if ( v95 < 0x10000 )
              {
                v97 = ((v95 - 256) >> 16) & 8;
                v98 = v95 << v97;
                v99 = ((v98 - 4096) >> 16) & 4;
                v100 = v98 << v99;
                v101 = ((v100 - 0x4000) >> 16) & 2;
                v102 = (v100 << v101 >> 15) - (v97 + v99 + v101);
                v95 = ((v84 >> (v102 + 21)) & 1) + 2 * (v102 + 14);
                v96 = 1 << v95;
              }
              else
              {
                v96 = 0x80000000;
                v95 = 31;
              }
            }
            else
            {
              v96 = 1;
            }
            LOBYTE(v103) = 0;
            v104 = dword_14068;
            *((_DWORD *)v82 + 7) = v95;
            *((_DWORD *)v82 + 5) = 0;
            *((_DWORD *)v82 + 4) = 0;
            if ( (v96 & v104) == 0 )
            {
              v105 = v95 + 74;
              dword_14058[v105 + 4] = (int)v82;
              dword_14068 = v96 | v104;
              *((_DWORD *)v82 + 6) = &dword_14064[v105 + 1];
              v76 = (int *)v75;
              *((_DWORD *)v82 + 3) = v82;
              *((_DWORD *)v82 + 2) = v82;
              goto LABEL_180;
            }
            if ( v95 != 31 )
              v103 = 25 - (v95 >> 1);
            v117 = dword_14058[v95 + 78];
            v118 = v84 << v103;
            while ( v84 != (*(_DWORD *)(v117 + 4) & 0xFFFFFFFC) )
            {
              v119 = (v118 >> 31) + 4;
              v118 *= 2;
              if ( !*(_DWORD *)(v117 + 4 * v119) )
              {
                if ( dword_14074 > v117 + 4 * v119 )
                  goto LABEL_32;
                *(_DWORD *)(v117 + 4 * v119) = v82;
                v76 = (int *)v75;
                *((_DWORD *)v82 + 6) = v117;
                *((_DWORD *)v82 + 3) = v82;
                *((_DWORD *)v82 + 2) = v82;
                goto LABEL_180;
              }
              v117 = *(_DWORD *)(v117 + 4 * v119);
            }
            v120 = *(_DWORD *)(v117 + 8);
            v121 = dword_14074 <= v117;
            if ( v120 < dword_14074 )
              v121 = 0;
            if ( !v121 )
              goto LABEL_32;
            *(_DWORD *)(v120 + 12) = v82;
            v76 = (int *)v75;
            *(_DWORD *)(v117 + 8) = v82;
            *((_DWORD *)v82 + 2) = v120;
            *((_DWORD *)v82 + 3) = v117;
            *((_DWORD *)v82 + 6) = 0;
LABEL_180:
            v75 = v79;
            if ( !v79 )
            {
              if ( len + v125 )
                goto LABEL_23;
LABEL_182:
              dword_14080 = -1;
              goto LABEL_23;
            }
          }
        }
      }
LABEL_33:
      abort();
    }
  }
  return result;
}
// 14058: using guessed type int dword_14058[];
// 14064: using guessed type int dword_14064[];
// 14068: using guessed type int dword_14068;
// 1406C: using guessed type int dword_1406C;
// 14070: using guessed type int dword_14070;
// 14074: using guessed type int dword_14074;
// 14078: using guessed type int dword_14078;
// 1407C: using guessed type int dword_1407C;
// 14080: using guessed type int dword_14080;
// 14210: using guessed type int dword_14210;
// 14218: using guessed type int dword_14218;
// 14220: using guessed type int dword_14220;
// 14228: using guessed type int dword_14228;
// 14230: using guessed type int dword_14230;
// 14234: using guessed type int dword_14234;
// 14238: using guessed type int dword_14238;
// 1423C: using guessed type int dword_1423C;
// 14240: using guessed type int dword_14240;
// 14244: using guessed type int dword_14244;

//----- (0000D2B8) --------------------------------------------------------
int __fastcall sub_D2B8(_DWORD *a1)
{
  int v1; // r4
  int result; // r0
  int *v3; // r11
  int v4; // r4
  int *v5; // r10
  int v6; // r4
  int *v7; // r9
  int v8; // r4
  int *v9; // r8
  int v10; // r4
  int *v11; // r7
  int v12; // r4
  int *v13; // r6
  int v14; // r4
  int *v15; // r5
  int v16; // r4
  int *v17; // r4
  int v18; // r2
  int v19; // t1
  int v20; // t1
  int v21; // t1
  int v22; // t1
  int v23; // t1
  int v24; // t1
  int v25; // t1
  int v26; // t1
  int v27; // t1
  int v28; // t1
  int v29; // t1
  int v30; // t1
  int v31; // t1
  int v32; // t1
  _DWORD *v33; // [sp+4h] [bp-2Ch]

  if ( !a1 )
    return -1;
  v1 = *a1;
  if ( !*a1 )
    return -1;
  if ( (*(_WORD *)(v1 + 6) & 0xFFFD) != 13 )
    return *(unsigned __int16 *)(v1 + 6);
  v33 = a1;
  while ( 1 )
  {
    v3 = *(int **)(v1 + 8);
    if ( v3 )
    {
      v4 = *v3;
      if ( *v3 )
        break;
    }
    result = -1;
LABEL_40:
    v1 = v33[1];
    ++v33;
    if ( v1 )
    {
      result = *(unsigned __int16 *)(v1 + 6);
      if ( (result & 0xFFFFFFFD) == 13 )
        continue;
    }
    return result;
  }
  while ( 1 )
  {
    result = *(unsigned __int16 *)(v4 + 6);
    if ( (result & 0xFFFFFFFD) != 13 )
      return result;
    v5 = *(int **)(v4 + 8);
    if ( v5 )
    {
      v6 = *v5;
      if ( *v5 )
      {
LABEL_11:
        while ( 1 )
        {
          result = *(unsigned __int16 *)(v6 + 6);
          if ( (result & 0xFFFFFFFD) != 13 )
            return result;
          v7 = *(int **)(v6 + 8);
          if ( v7 )
          {
            v8 = *v7;
            if ( *v7 )
            {
LABEL_14:
              while ( 1 )
              {
                result = *(unsigned __int16 *)(v8 + 6);
                if ( (result & 0xFFFFFFFD) != 13 )
                  return result;
                v9 = *(int **)(v8 + 8);
                if ( v9 )
                {
                  v10 = *v9;
                  if ( *v9 )
                  {
LABEL_17:
                    while ( 1 )
                    {
                      result = *(unsigned __int16 *)(v10 + 6);
                      if ( (result & 0xFFFFFFFD) != 13 )
                        return result;
                      v11 = *(int **)(v10 + 8);
                      if ( v11 )
                      {
                        v12 = *v11;
                        if ( *v11 )
                        {
LABEL_20:
                          while ( 1 )
                          {
                            result = *(unsigned __int16 *)(v12 + 6);
                            if ( (result & 0xFFFFFFFD) != 13 )
                              return result;
                            v13 = *(int **)(v12 + 8);
                            if ( v13 )
                            {
                              v14 = *v13;
                              if ( *v13 )
                              {
LABEL_23:
                                while ( 1 )
                                {
                                  result = *(unsigned __int16 *)(v14 + 6);
                                  if ( (result & 0xFFFFFFFD) != 13 )
                                    return result;
                                  v15 = *(int **)(v14 + 8);
                                  if ( v15 )
                                  {
                                    v16 = *v15;
                                    if ( *v15 )
                                    {
LABEL_26:
                                      while ( 1 )
                                      {
                                        result = *(unsigned __int16 *)(v16 + 6);
                                        if ( (result & 0xFFFFFFFD) != 13 )
                                          return result;
                                        v17 = *(int **)(v16 + 8);
                                        if ( v17 )
                                        {
                                          v18 = *v17;
                                          if ( *v17 )
                                          {
                                            while ( 1 )
                                            {
                                              result = *(unsigned __int16 *)(v18 + 6);
                                              if ( (result & 0xFFFFFFFD) != 13 )
                                                return result;
                                              result = sub_D2B8(*(_DWORD *)(v18 + 8));
                                              if ( result >= 0 )
                                                return result;
                                              v19 = v17[1];
                                              ++v17;
                                              v18 = v19;
                                              if ( !v19 )
                                              {
                                                v20 = v15[1];
                                                ++v15;
                                                v16 = v20;
                                                if ( v20 )
                                                  goto LABEL_26;
                                                goto LABEL_34;
                                              }
                                            }
                                          }
                                        }
                                        v27 = v15[1];
                                        ++v15;
                                        v16 = v27;
                                        result = -1;
                                        if ( !v27 )
                                        {
LABEL_34:
                                          v21 = v13[1];
                                          ++v13;
                                          v14 = v21;
                                          if ( v21 )
                                            goto LABEL_23;
                                          goto LABEL_35;
                                        }
                                      }
                                    }
                                  }
                                  v28 = v13[1];
                                  ++v13;
                                  v14 = v28;
                                  result = -1;
                                  if ( !v28 )
                                  {
LABEL_35:
                                    v22 = v11[1];
                                    ++v11;
                                    v12 = v22;
                                    if ( v22 )
                                      goto LABEL_20;
                                    goto LABEL_36;
                                  }
                                }
                              }
                            }
                            v29 = v11[1];
                            ++v11;
                            v12 = v29;
                            result = -1;
                            if ( !v29 )
                            {
LABEL_36:
                              v23 = v9[1];
                              ++v9;
                              v10 = v23;
                              if ( v23 )
                                goto LABEL_17;
                              goto LABEL_37;
                            }
                          }
                        }
                      }
                      v30 = v9[1];
                      ++v9;
                      v10 = v30;
                      result = -1;
                      if ( !v30 )
                      {
LABEL_37:
                        v24 = v7[1];
                        ++v7;
                        v8 = v24;
                        if ( v24 )
                          goto LABEL_14;
                        goto LABEL_38;
                      }
                    }
                  }
                }
                v31 = v7[1];
                ++v7;
                v8 = v31;
                result = -1;
                if ( !v31 )
                {
LABEL_38:
                  v25 = v5[1];
                  ++v5;
                  v6 = v25;
                  if ( v25 )
                    goto LABEL_11;
                  goto LABEL_39;
                }
              }
            }
          }
          v32 = v5[1];
          ++v5;
          v6 = v32;
          result = -1;
          if ( !v32 )
            goto LABEL_39;
        }
      }
    }
    result = -1;
LABEL_39:
    v26 = v3[1];
    ++v3;
    v4 = v26;
    if ( !v26 )
      goto LABEL_40;
  }
}

//----- (0000D564) --------------------------------------------------------
int __fastcall sub_D564(_DWORD *a1, int a2)
{
  int v2; // r4
  int v4; // r3
  int result; // r0
  _DWORD *v6; // r9
  int v7; // r4
  int v8; // r3
  int *v9; // r10
  int v10; // r4
  int v11; // t1
  int v12; // r3
  int *v13; // r11
  int v14; // r4
  int v15; // t1
  int v16; // r3
  int *v17; // r7
  int v18; // r4
  int v19; // t1
  int v20; // r3
  int *v21; // r6
  int v22; // r4
  int v23; // t1
  int v24; // r3
  int *v25; // r5
  int v26; // r4
  int v27; // t1
  int v28; // r3
  int *v29; // r4
  int v30; // r3
  int v31; // t1
  int v32; // r2
  _DWORD *v33; // r2
  int v34; // r3
  _DWORD *v35; // r9
  int v36; // t1
  int v37; // r1
  _DWORD *i; // [sp+0h] [bp-30h]
  _DWORD *v39; // [sp+4h] [bp-2Ch]

  if ( a1 )
  {
    v2 = *a1;
    if ( !*a1 )
      return 1;
    for ( i = a1; ; ++i )
    {
      v4 = *(unsigned __int16 *)(v2 + 6);
      if ( (v4 & 0xFFFFFFFD) == 13 )
      {
        v6 = *(_DWORD **)(v2 + 8);
        if ( v6 )
        {
          v7 = *v6;
          if ( *v6 )
          {
            v39 = v6;
            do
            {
              v8 = *(unsigned __int16 *)(v7 + 6);
              if ( (v8 & 0xFFFFFFFD) == 13 )
              {
                v9 = *(int **)(v7 + 8);
                if ( v9 )
                {
                  v10 = *v9;
                  if ( *v9 )
                  {
                    do
                    {
                      v12 = *(unsigned __int16 *)(v10 + 6);
                      if ( (v12 & 0xFFFFFFFD) == 13 )
                      {
                        v13 = *(int **)(v10 + 8);
                        if ( v13 )
                        {
                          v14 = *v13;
                          if ( *v13 )
                          {
                            do
                            {
                              v16 = *(unsigned __int16 *)(v14 + 6);
                              if ( (v16 & 0xFFFFFFFD) == 13 )
                              {
                                v17 = *(int **)(v14 + 8);
                                if ( v17 )
                                {
                                  v18 = *v17;
                                  if ( *v17 )
                                  {
                                    do
                                    {
                                      v20 = *(unsigned __int16 *)(v18 + 6);
                                      if ( (v20 & 0xFFFFFFFD) == 13 )
                                      {
                                        v21 = *(int **)(v18 + 8);
                                        if ( v21 )
                                        {
                                          v22 = *v21;
                                          if ( *v21 )
                                          {
                                            do
                                            {
                                              v24 = *(unsigned __int16 *)(v22 + 6);
                                              if ( (v24 & 0xFFFFFFFD) == 13 )
                                              {
                                                v25 = *(int **)(v22 + 8);
                                                if ( v25 )
                                                {
                                                  v26 = *v25;
                                                  if ( *v25 )
                                                  {
                                                    do
                                                    {
                                                      v28 = *(unsigned __int16 *)(v26 + 6);
                                                      if ( (v28 & 0xFFFFFFFD) == 13 )
                                                      {
                                                        v29 = *(int **)(v26 + 8);
                                                        if ( v29 )
                                                        {
                                                          v30 = *v29;
                                                          if ( *v29 )
                                                          {
                                                            do
                                                            {
                                                              v32 = *(unsigned __int16 *)(v30 + 6);
                                                              if ( (v32 & 0xFFFFFFFD) == 13 )
                                                              {
                                                                v33 = *(_DWORD **)(v30 + 8);
                                                                if ( v33 )
                                                                {
                                                                  v34 = *v33;
                                                                  if ( *v33 )
                                                                  {
                                                                    v35 = v33;
                                                                    do
                                                                    {
                                                                      v37 = *(unsigned __int16 *)(v34 + 6);
                                                                      if ( (v37 & 0xFFFFFFFD) == 13 )
                                                                      {
                                                                        result = sub_D564(*(_DWORD *)(v34 + 8), a2);
                                                                        if ( !result )
                                                                          return result;
                                                                      }
                                                                      else if ( a2 != v37 )
                                                                      {
                                                                        return 0;
                                                                      }
                                                                      v36 = v35[1];
                                                                      ++v35;
                                                                      v34 = v36;
                                                                    }
                                                                    while ( v36 );
                                                                  }
                                                                }
                                                              }
                                                              else if ( a2 != v32 )
                                                              {
                                                                return 0;
                                                              }
                                                              v31 = v29[1];
                                                              ++v29;
                                                              v30 = v31;
                                                            }
                                                            while ( v31 );
                                                          }
                                                        }
                                                      }
                                                      else if ( a2 != v28 )
                                                      {
                                                        return 0;
                                                      }
                                                      v27 = v25[1];
                                                      ++v25;
                                                      v26 = v27;
                                                    }
                                                    while ( v27 );
                                                  }
                                                }
                                              }
                                              else if ( a2 != v24 )
                                              {
                                                return 0;
                                              }
                                              v23 = v21[1];
                                              ++v21;
                                              v22 = v23;
                                            }
                                            while ( v23 );
                                          }
                                        }
                                      }
                                      else if ( a2 != v20 )
                                      {
                                        return 0;
                                      }
                                      v19 = v17[1];
                                      ++v17;
                                      v18 = v19;
                                    }
                                    while ( v19 );
                                  }
                                }
                              }
                              else if ( a2 != v16 )
                              {
                                return 0;
                              }
                              v15 = v13[1];
                              ++v13;
                              v14 = v15;
                            }
                            while ( v15 );
                          }
                        }
                      }
                      else if ( a2 != v12 )
                      {
                        return 0;
                      }
                      v11 = v9[1];
                      ++v9;
                      v10 = v11;
                    }
                    while ( v11 );
                  }
                }
              }
              else if ( a2 != v8 )
              {
                return 0;
              }
              v7 = v39[1];
              ++v39;
            }
            while ( v7 );
          }
        }
      }
      else if ( v4 != a2 )
      {
        return 0;
      }
      v2 = i[1];
      if ( !v2 )
        return 1;
    }
  }
  return 1;
}

//----- (0000D7F8) --------------------------------------------------------
void *__fastcall sub_D7F8(_DWORD *a1, __int64 (__fastcall *a2)(), void *a3, int a4, int a5)
{
  void **v5; // r1
  int v7; // r2
  void *v8; // r9
  int *v9; // r7
  _DWORD *v10; // r5
  void *v11; // r1
  int v12; // r12
  unsigned int *v13; // r9
  int v14; // r2
  int v15; // r10
  _DWORD *v16; // r7
  int v17; // r6
  int v18; // r8
  int v19; // r5
  size_t *v20; // r4
  int v21; // t1
  unsigned int v22; // r9
  unsigned int v23; // r3
  int v24; // r2
  int v25; // r3
  int v26; // r3
  int v27; // r9
  size_t v28; // r4
  _DWORD *v29; // r1
  _DWORD *v30; // t1
  _DWORD *v31; // r1
  void *v32; // r0
  int v33; // r1
  int v34; // r8
  int v35; // r7
  _DWORD *v36; // r9
  _DWORD *v37; // t1
  int v38; // r10
  int v39; // r5
  size_t v40; // r4
  int v41; // r6
  int v42; // r1
  _BOOL4 v43; // r1
  unsigned int v44; // r1
  int v45; // r0
  int v46; // r0
  char *v47; // r3
  unsigned int v48; // lr
  int v49; // r10
  int v50; // r10
  void *v51; // r3
  unsigned int v52; // r3
  int *v53; // r4
  int v54; // t1
  int v55; // r0
  int v56; // r6
  int *v57; // r3
  int *v58; // r4
  int v59; // r0
  int *v60; // r6
  int v61; // r3
  int v62; // r2
  unsigned int v63; // r1
  int v64; // r4
  int v65; // t1
  int v66; // r1
  _BOOL4 v67; // r0
  void *result; // r0
  bool v69; // zf
  int v70; // r2
  int v71; // r2
  int v72; // r3
  int v73; // r6
  int *v74; // r0
  int v75; // r1
  int v76; // r2
  int v77; // r2
  int v78; // r2
  _DWORD *v79; // [sp+0h] [bp-74h] BYREF
  unsigned int v80; // [sp+4h] [bp-70h] BYREF
  int v81; // [sp+8h] [bp-6Ch]
  int v82; // [sp+Ch] [bp-68h]
  int *v83; // [sp+10h] [bp-64h]
  void **v84; // [sp+14h] [bp-60h]
  __int64 (__fastcall *v85)(); // [sp+18h] [bp-5Ch]
  void *v86; // [sp+1Ch] [bp-58h]
  void *v87; // [sp+20h] [bp-54h]
  unsigned int v88; // [sp+24h] [bp-50h]
  int *v89; // [sp+28h] [bp-4Ch]
  int *v90; // [sp+2Ch] [bp-48h]
  unsigned int v91; // [sp+30h] [bp-44h]
  int v92; // [sp+34h] [bp-40h]
  int v93; // [sp+38h] [bp-3Ch]
  _BOOL4 v94; // [sp+3Ch] [bp-38h]
  _DWORD *v95; // [sp+40h] [bp-34h] BYREF
  int v96; // [sp+44h] [bp-30h]
  unsigned int v97; // [sp+48h] [bp-2Ch]
  int *v98; // [sp+4Ch] [bp-28h]

  v69 = a3 == 0;
  v85 = a2;
  v5 = (void **)a1[3];
  v87 = a3;
  v7 = a1[5];
  v84 = v5;
  if ( v69 )
  {
    if ( v7 == 6 )
    {
      v8 = *v5;
    }
    else
    {
      v8 = v87;
      v7 = 5;
    }
  }
  else
  {
    if ( v7 == 2 )
    {
      v8 = &dword_20;
      goto LABEL_19;
    }
    if ( v7 == 4 && *((_WORD *)v84 + 3) == 13 )
    {
      v8 = &byte_4;
LABEL_19:
      if ( *a1 != 2 )
      {
        v9 = (int *)&v79;
        v10 = (_DWORD **)((char *)&v79 + a1[4]);
        goto LABEL_21;
      }
      if ( a1[6] )
      {
        v31 = (_DWORD **)((char *)&v95 + a1[4]);
        v90 = (int *)&v79;
        v89 = (int *)&v95;
        v79 = v31;
        goto LABEL_126;
      }
      goto LABEL_6;
    }
    v8 = 0;
  }
  if ( *a1 == 2 && a1[6] )
  {
    v31 = (_DWORD **)((char *)&v95 + a1[4]);
    v90 = (int *)&v79;
    v89 = (int *)&v95;
    v79 = v31;
    if ( !v8 )
    {
      v32 = v87;
      v31[2] = v87;
      v31[3] = v7;
      v31[4] = a5;
      v86 = v32;
LABEL_25:
      v33 = a1[2];
      v91 = (unsigned int)(v90 + 20);
      if ( v7 == 6 )
      {
        v89 = v90 + 17;
        v90[16] = (int)v86;
      }
      v92 = a1[1];
      if ( v92 <= 0 )
      {
LABEL_73:
        result = (void *)sub_ECA0((int)v90);
        goto LABEL_74;
      }
      v34 = a4 - 4;
      v35 = 0;
      v93 = 0;
      v98 = (int *)(v33 - 4);
      v94 = 0;
      v96 = 0;
      v97 = v91;
      v95 = a1;
      while ( 1 )
      {
        v37 = *(_DWORD **)(v34 + 4);
        v34 += 4;
        v36 = v37;
        v38 = v98[1];
        ++v98;
        v39 = *(unsigned __int16 *)(v38 + 6);
        switch ( *(_WORD *)(v38 + 6) )
        {
          case 2:
          case 3:
            v40 = *(_DWORD *)v38;
            v41 = *(unsigned __int16 *)(v38 + 6);
            v42 = 256;
            goto LABEL_64;
          case 0xD:
            v52 = *(_DWORD *)v38;
            v88 = v52;
            if ( v52 - 4 > 0x1C )
            {
              v40 = v52;
              v43 = 1;
              goto LABEL_35;
            }
            v83 = *(int **)(v38 + 8);
            v81 = *v83;
            v82 = *(unsigned __int16 *)(v81 + 6);
            v80 = v82 & 0xFFFFFFFD;
            if ( (v82 & 0xFFFFFFFD) == 13 )
            {
              v53 = v83 - 1;
              do
              {
                v54 = v53[1];
                ++v53;
                v55 = sub_D2B8(*(_DWORD **)(v54 + 8));
              }
              while ( v55 < 0 );
              v56 = v55;
              if ( v55 != 2 )
              {
LABEL_53:
                if ( v56 != 3 )
                {
LABEL_62:
                  v40 = v88;
LABEL_34:
                  v43 = 1;
LABEL_35:
                  v69 = !v43 || v94;
                  v44 = *(unsigned __int16 *)(v38 + 4);
                  if ( !v69 )
                  {
                    if ( v44 <= 3 )
                      v45 = 3;
                    else
                      v45 = v44 - 1;
                    v46 = v45 | ((unsigned int)v89 - 1);
                    v47 = (char *)(v46 + 1);
                    if ( v40 < 4 )
                      v48 = v46 + 5;
                    else
                      v48 = (unsigned int)&v47[v40];
                    if ( v91 >= v48 )
                    {
                      switch ( v39 )
                      {
                        case 1:
                        case 2:
                        case 9:
                        case 10:
                        case 14:
                          *(_DWORD *)(v46 + 1) = *v36;
                          goto LABEL_106;
                        case 3:
                        case 11:
                        case 12:
                          v77 = v36[1];
                          *(_DWORD *)(v46 + 1) = *v36;
                          *(_DWORD *)(v46 + 5) = v77;
                          goto LABEL_106;
                        case 5:
                          *(_DWORD *)(v46 + 1) = *(unsigned __int8 *)v36;
                          goto LABEL_106;
                        case 6:
                          *(_DWORD *)(v46 + 1) = *(char *)v36;
                          goto LABEL_106;
                        case 7:
                          *(_DWORD *)(v46 + 1) = *(unsigned __int16 *)v36;
                          goto LABEL_106;
                        case 8:
                          *(_DWORD *)(v46 + 1) = *(__int16 *)v36;
                          goto LABEL_106;
                        case 13:
                        case 15:
                          v47 = (char *)memcpy((void *)(v46 + 1), v36, v40);
LABEL_106:
                          v89 = (int *)&v47[((v40 - 1) | 3) + 1];
                          v94 = v89 == (int *)v97;
                          goto LABEL_72;
                        default:
                          goto LABEL_85;
                      }
                    }
                    if ( !v93 )
                    {
                      switch ( v39 )
                      {
                        case 1:
                        case 2:
                        case 9:
                        case 10:
                        case 14:
                          *(_DWORD *)(v46 + 1) = *v36;
                          goto LABEL_128;
                        case 3:
                        case 11:
                        case 12:
                          v78 = v36[1];
                          *(_DWORD *)(v46 + 1) = *v36;
                          *(_DWORD *)(v46 + 5) = v78;
                          goto LABEL_128;
                        case 5:
                          *(_DWORD *)(v46 + 1) = *(unsigned __int8 *)v36;
                          goto LABEL_128;
                        case 6:
                          *(_DWORD *)(v46 + 1) = *(char *)v36;
                          goto LABEL_128;
                        case 7:
                          *(_DWORD *)(v46 + 1) = *(unsigned __int16 *)v36;
                          goto LABEL_128;
                        case 8:
                          *(_DWORD *)(v46 + 1) = *(__int16 *)v36;
                          goto LABEL_128;
                        case 13:
                        case 15:
                          v47 = (char *)memcpy((void *)(v46 + 1), v36, v40);
LABEL_128:
                          v94 = 1;
                          v97 = (unsigned int)&v47[((v40 - 1) | 3) + 1];
                          v93 = 1;
                          goto LABEL_72;
                        default:
                          goto LABEL_85;
                      }
                    }
                  }
                  if ( v44 <= 3 )
                    v49 = 3;
                  else
                    v49 = v44 - 1;
                  v50 = v49 | (v97 - 1);
                  v51 = (void *)(v50 + 1);
                  switch ( v39 )
                  {
                    case 1:
                    case 2:
                    case 9:
                    case 10:
                    case 14:
                      *(_DWORD *)(v50 + 1) = *v36;
                      goto LABEL_71;
                    case 3:
                    case 11:
                    case 12:
                      v70 = v36[1];
                      *(_DWORD *)(v50 + 1) = *v36;
                      *(_DWORD *)(v50 + 5) = v70;
                      goto LABEL_71;
                    case 5:
                      *(_DWORD *)(v50 + 1) = *(unsigned __int8 *)v36;
                      goto LABEL_71;
                    case 6:
                      *(_DWORD *)(v50 + 1) = *(char *)v36;
                      goto LABEL_71;
                    case 7:
                      *(_DWORD *)(v50 + 1) = *(unsigned __int16 *)v36;
                      goto LABEL_71;
                    case 8:
                      *(_DWORD *)(v50 + 1) = *(__int16 *)v36;
                      goto LABEL_71;
                    case 13:
                    case 15:
                      v51 = memcpy((void *)(v50 + 1), v36, v40);
LABEL_71:
                      v97 = (unsigned int)v51 + ((v40 - 1) | 3) + 1;
                      v93 = 1;
                      goto LABEL_72;
                    default:
                      goto LABEL_85;
                  }
                }
                v57 = (int *)(v88 >> 3);
                if ( v88 != 8 * (v88 >> 3) )
                {
                  v40 = v88;
                  v43 = 1;
                  goto LABEL_35;
                }
                goto LABEL_56;
              }
            }
            else
            {
              v56 = v82;
              if ( v82 != 2 )
                goto LABEL_53;
            }
            v57 = (int *)(v88 >> 2);
            v43 = v88 != 4 * (v88 >> 2);
            if ( v88 >> 2 > 4 )
              v43 = 1;
            if ( v43 )
            {
              v40 = v88;
              goto LABEL_35;
            }
LABEL_56:
            v58 = v83;
            v59 = v56;
            v83 = v57;
            v60 = v58;
            v61 = v81;
            v62 = v82;
            v63 = v80;
            v64 = v59;
            while ( 1 )
            {
              if ( v63 == 13 )
              {
                if ( !sub_D564(*(_DWORD **)(v61 + 8), v64) )
                  goto LABEL_62;
              }
              else if ( v64 != v62 )
              {
                goto LABEL_62;
              }
              v65 = v60[1];
              ++v60;
              v61 = v65;
              if ( !v65 )
                break;
              v62 = *(unsigned __int16 *)(v61 + 6);
              v63 = v62 & 0xFFFFFFFD;
            }
            v41 = v64;
            v42 = (_DWORD)v83 << 8;
            v40 = v88;
LABEL_64:
            v66 = v41 | v42;
            if ( *((unsigned __int16 *)v95 + 15) > v96 )
              v67 = v66 != 0;
            else
              v67 = 0;
            if ( !v67 )
            {
              v43 = v66 == 0;
              goto LABEL_35;
            }
            v72 = *((char *)v95 + v96 + 32);
            v73 = v96 + 1;
            v74 = &v90[v72];
            switch ( v39 )
            {
              case 1:
              case 2:
              case 9:
              case 10:
              case 14:
                v90[v72] = *v36;
                v96 = v73;
                break;
              case 3:
              case 11:
              case 12:
                v75 = *v36;
                v76 = v36[1];
                ++v96;
                v90[v72] = v75;
                v74[1] = v76;
                break;
              case 5:
                v90[v72] = *(unsigned __int8 *)v36;
                v96 = v73;
                break;
              case 6:
                v90[v72] = *(char *)v36;
                v96 = v73;
                break;
              case 7:
                v90[v72] = *(unsigned __int16 *)v36;
                v96 = v73;
                break;
              case 8:
                v90[v72] = *(__int16 *)v36;
                v96 = v73;
                break;
              case 13:
              case 15:
                memcpy(v74, v36, v40);
                v96 = v73;
                break;
              default:
LABEL_85:
                abort();
                return result;
            }
LABEL_72:
            if ( v92 == ++v35 )
              goto LABEL_73;
            break;
          case 0xF:
            v40 = *(_DWORD *)v38;
            v41 = *(unsigned __int16 *)(**(_DWORD **)(v38 + 8) + 6);
            if ( (unsigned int)(v41 - 2) > 1 )
              goto LABEL_34;
            v42 = 512;
            goto LABEL_64;
          default:
            v40 = *(_DWORD *)v38;
            v43 = 1;
            goto LABEL_35;
        }
      }
    }
LABEL_126:
    v86 = v31 + 5;
    v31[3] = v7;
    v31[4] = a5;
    v31[2] = v31 + 5;
    goto LABEL_25;
  }
LABEL_6:
  v9 = (int *)&v79;
  v10 = (_DWORD **)((char *)&v79 + a1[4]);
  if ( v8 )
  {
LABEL_21:
    v11 = v10 + 5;
    v86 = v10 + 5;
    v10[3] = v7;
    v10[4] = a5;
    v10[2] = v10 + 5;
    goto LABEL_8;
  }
  v11 = v87;
  v10[2] = v87;
  v10[3] = v7;
  v10[4] = a5;
  v86 = v11;
LABEL_8:
  v12 = a1[1];
  if ( v7 == 6 )
    v11 = v86;
  v13 = (unsigned int *)&v79;
  if ( v7 == 6 )
  {
    v79 = v11;
    v13 = &v80;
  }
  v14 = a1[2];
  if ( v12 > 0 )
  {
    v98 = (int *)&v79;
    v15 = v14 - 4;
    v16 = v10;
    v17 = a4 - 4;
    v18 = 0;
    v19 = v12;
    while ( 2 )
    {
      v21 = *(_DWORD *)(v15 + 4);
      v15 += 4;
      v20 = (size_t *)v21;
      v22 = (unsigned int)v13 - 1;
      v23 = *(unsigned __int16 *)(v21 + 4);
      v24 = *(unsigned __int16 *)(v21 + 6);
      if ( v23 <= 3 )
        v25 = 3;
      else
        v25 = v23 - 1;
      v26 = v25 | v22;
      v27 = v26 + 1;
      v28 = *v20;
      v30 = *(_DWORD **)(v17 + 4);
      v17 += 4;
      v29 = v30;
      switch ( v24 )
      {
        case 1:
        case 2:
        case 9:
        case 10:
        case 14:
          *(_DWORD *)(v26 + 1) = *v29;
          goto LABEL_87;
        case 3:
        case 11:
        case 12:
          v71 = v29[1];
          *(_DWORD *)(v26 + 1) = *v29;
          *(_DWORD *)(v26 + 5) = v71;
          goto LABEL_87;
        case 5:
          *(_DWORD *)(v26 + 1) = *(unsigned __int8 *)v29;
          goto LABEL_87;
        case 6:
          *(_DWORD *)(v26 + 1) = *(char *)v29;
          goto LABEL_87;
        case 7:
          *(_DWORD *)(v26 + 1) = *(unsigned __int16 *)v29;
          goto LABEL_87;
        case 8:
          *(_DWORD *)(v26 + 1) = *(__int16 *)v29;
          goto LABEL_87;
        case 13:
        case 15:
          memcpy((void *)(v26 + 1), v29, v28);
LABEL_87:
          ++v18;
          v13 = (unsigned int *)(v27 + ((v28 - 1) | 3) + 1);
          if ( v19 != v18 )
            continue;
          v10 = v16;
          v9 = v98;
          break;
        default:
          goto LABEL_85;
      }
      break;
    }
  }
  result = (void *)sub_ECB0((int)v9, v10, v85);
LABEL_74:
  v69 = v87 == v86;
  if ( v87 != v86 )
    v69 = v87 == 0;
  if ( !v69 )
    result = memcpy(v87, v86, (size_t)*v84);
  return result;
}
// 4: using guessed type char byte_4;
// 20: using guessed type int;

//----- (0000E184) --------------------------------------------------------
int __fastcall sub_E184(int *a1)
{
  int v1; // r8
  _DWORD *v2; // r11
  int v3; // r4
  int v4; // r2
  int v5; // r3
  int v6; // r1
  unsigned int v7; // r9
  int result; // r0
  unsigned int v9; // r5
  int v10; // r10
  _DWORD *v11; // r12
  int v12; // r11
  unsigned int *v13; // r0
  int v14; // t1
  int v15; // r4
  int v16; // r9
  int v17; // r4
  int v18; // r9
  bool v19; // zf
  int v20; // r4
  __int16 v21; // r3
  int v22; // r0
  int v23; // r1
  int v24; // r7
  int v25; // lr
  int v26; // lr
  int v27; // r1
  unsigned int v28; // r9
  int v29; // r7
  int v30; // r4
  _DWORD *v31; // r4
  int *v32; // r5
  int v33; // t1
  int v34; // r0
  unsigned int v35; // r5
  int *v36; // r9
  unsigned int v37; // r3
  int v38; // r5
  _DWORD *v39; // r4
  int v40; // t1
  _BOOL4 v41; // r1
  __int64 v42; // r6
  _DWORD *v43; // r8
  int v44; // r9
  int v45; // r10
  unsigned int v46; // r3
  _DWORD *v47; // r6
  int v48; // t1
  int v49; // r0
  unsigned int v50; // r6
  int v51; // t1
  _BOOL4 v52; // r2
  int v53; // [sp+4h] [bp-3Ch]
  unsigned int v54; // [sp+4h] [bp-3Ch]
  int v55; // [sp+8h] [bp-38h]
  int v56; // [sp+Ch] [bp-34h]
  int *v57; // [sp+10h] [bp-30h]
  unsigned int v58; // [sp+10h] [bp-30h]

  v2 = a1;
  v56 = *a1;
  v55 = a1[4];
  if ( *a1 == 2 )
  {
    a1[6] = 0;
    *((_WORD *)a1 + 15) = 0;
    *((_WORD *)a1 + 14) = 0;
    memset(a1 + 8, -1, 0x10u);
    v53 = v2[1];
    if ( v53 )
    {
      v10 = v2[2] - 4;
      v11 = v2;
      v12 = 0;
      while ( 1 )
      {
        v14 = *(_DWORD *)(v10 + 4);
        v10 += 4;
        v13 = (unsigned int *)v14;
        v15 = *(unsigned __int16 *)(v14 + 6);
        switch ( *(_WORD *)(v14 + 6) )
        {
          case 2:
          case 3:
            v16 = 256;
            goto LABEL_30;
          case 0xD:
            v28 = *v13;
            if ( *v13 - 4 > 0x1C )
              goto LABEL_27;
            v57 = (int *)v13[2];
            v29 = *v57;
            v1 = *(unsigned __int16 *)(*v57 + 6);
            if ( (v1 & 0xFFFFFFFD) == 13 )
            {
              v31 = v11;
              v32 = v57 - 1;
              do
              {
                v33 = v32[1];
                ++v32;
                v34 = sub_D2B8(*(_DWORD **)(v33 + 8));
              }
              while ( v34 < 0 );
              v11 = v31;
              v30 = v34;
            }
            else
            {
              v30 = *(unsigned __int16 *)(*v57 + 6);
            }
            if ( v30 == 2 )
            {
              v35 = v28 >> 2;
              v41 = v28 != 4 * (v28 >> 2);
              if ( v28 >> 2 > 4 )
                v41 = 1;
              if ( v41 )
                goto LABEL_27;
            }
            else
            {
              if ( v30 != 3 )
                goto LABEL_27;
              v35 = v28 >> 3;
              if ( v28 != 8 * (v28 >> 3) )
                goto LABEL_27;
            }
            v36 = v57;
            v37 = v1 & 0xFFFFFFFD;
            v58 = v35;
            v38 = v30;
            v39 = v11;
            while ( 1 )
            {
              if ( v37 == 13 )
              {
                if ( !sub_D564(*(_DWORD **)(v29 + 8), v38) )
                {
LABEL_60:
                  v11 = v39;
                  goto LABEL_27;
                }
              }
              else if ( v38 != v1 )
              {
                goto LABEL_60;
              }
              v40 = v36[1];
              ++v36;
              v29 = v40;
              if ( !v40 )
                break;
              v1 = *(unsigned __int16 *)(v29 + 6);
              v37 = v1 & 0xFFFFFFFD;
            }
            v11 = v39;
            v15 = v38;
            v16 = v58 << 8;
LABEL_30:
            v17 = v15 | v16;
            if ( v17 )
            {
              v18 = *((unsigned __int16 *)v11 + 14);
              v19 = (unsigned __int8)v17 == 3;
              v20 = v17 >> 8;
              if ( v19 )
              {
                if ( (v18 & 1) != 0 )
                  v1 = (v18 + 1) << 16;
                v20 *= 2;
                if ( (v18 & 1) != 0 )
                  v1 = HIWORD(v1);
                else
                  v1 = *((unsigned __int16 *)v11 + 14);
                v21 = 2;
              }
              else
              {
                v1 = *((unsigned __int16 *)v11 + 14);
                v21 = 1;
              }
              v22 = v20 + v1;
              v23 = v1;
              if ( v20 + v1 > 16 )
              {
LABEL_62:
                v2 = v11;
                *((_WORD *)v11 + 14) = 16;
                v11[6] = (char *)&word_FFFE + 1;
                goto LABEL_2;
              }
              v24 = v11[6];
              while ( 1 )
              {
                if ( v1 >= v22 )
                {
                  v25 = 0;
                  goto LABEL_41;
                }
                v25 = 1 << v1;
                if ( ((v24 >> v1) & 1) == 0 )
                  break;
LABEL_61:
                v1 = (unsigned __int16)(v1 + v21);
                v22 = v20 + v1;
                v23 = v1;
                if ( v20 + v1 > 16 )
                  goto LABEL_62;
              }
              while ( ++v23 != v22 )
              {
                v25 |= 1 << v23;
                if ( ((v24 >> v23) & 1) != 0 )
                  goto LABEL_61;
              }
LABEL_41:
              v26 = v25 | v24;
              v27 = *((unsigned __int16 *)v11 + 15);
              v11[6] = v26;
              *((_WORD *)v11 + 15) = v27 + 1;
              *((_BYTE *)v11 + v27 + 32) = v1;
              if ( ((v26 >> v18) & 1) != 0 )
              {
                for ( ; ((v26 >> v22) & 1) != 0; LOWORD(v22) = v22 + 1 )
                  ;
                *((_WORD *)v11 + 14) = v22;
              }
            }
LABEL_27:
            if ( ++v12 == v53 )
            {
              v2 = v11;
              goto LABEL_2;
            }
            break;
          case 0xF:
            v15 = *(unsigned __int16 *)(*(_DWORD *)v13[2] + 6);
            if ( (unsigned int)(v15 - 2) > 1 )
              goto LABEL_27;
            v16 = 512;
            goto LABEL_30;
          default:
            goto LABEL_27;
        }
      }
    }
  }
LABEL_2:
  v3 = v2[3];
  v4 = *(unsigned __int16 *)(v3 + 6);
  switch ( *(_WORD *)(v3 + 6) )
  {
    case 0:
      v6 = 5;
      v5 = v55;
      goto LABEL_4;
    case 1:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xE:
      goto LABEL_3;
    case 2:
      if ( v56 == 2 )
        v6 = 0;
      else
        v6 = 4;
      v5 = v55;
      goto LABEL_4;
    case 3:
      if ( v56 == 2 )
        v6 = 1;
      else
        v6 = 3;
      v5 = v55;
      goto LABEL_4;
    case 0xB:
    case 0xC:
      v6 = 3;
      v5 = v55;
      goto LABEL_4;
    case 0xD:
    case 0xF:
      if ( v56 != 2 )
        goto LABEL_17;
      if ( v4 != 13 )
      {
        if ( v4 != 15
          || (HIDWORD(v42) = *(unsigned __int16 *)(**(_DWORD **)(v3 + 8) + 6), (unsigned int)(HIDWORD(v42) - 2) > 1) )
        {
LABEL_17:
          v9 = *(_DWORD *)v3;
          goto LABEL_18;
        }
        LODWORD(v42) = 512;
LABEL_79:
        if ( (HIDWORD(v42) | (unsigned int)v42) == 258 )
        {
          v6 = 0;
          v5 = v55;
          goto LABEL_4;
        }
        if ( (HIDWORD(v42) | (unsigned int)v42) == 259 )
        {
          v6 = 1;
          v5 = v55;
          goto LABEL_4;
        }
        if ( v42 )
        {
          v6 = 2;
          v5 = v55;
          goto LABEL_4;
        }
        goto LABEL_17;
      }
      v9 = *(_DWORD *)v3;
      if ( (unsigned int)(*(_DWORD *)v3 - 4) <= 0x1C )
      {
        v43 = *(_DWORD **)(v3 + 8);
        v44 = *v43;
        v45 = *(unsigned __int16 *)(*v43 + 6);
        v46 = v45 & 0xFFFFFFFD;
        if ( (v45 & 0xFFFFFFFD) == 13 )
        {
          v47 = v43 - 1;
          do
          {
            v48 = v47[1];
            ++v47;
            v54 = v46;
            v49 = sub_D2B8(*(_DWORD **)(v48 + 8));
            v46 = v54;
          }
          while ( v49 < 0 );
          HIDWORD(v42) = v49;
        }
        else
        {
          HIDWORD(v42) = *(unsigned __int16 *)(*v43 + 6);
        }
        if ( HIDWORD(v42) == 2 )
        {
          v50 = v9 >> 2;
          v52 = v9 != 4 * (v9 >> 2);
          if ( v9 >> 2 > 4 )
            v52 = 1;
          if ( !v52 )
          {
LABEL_99:
            while ( 1 )
            {
              if ( v46 == 13 )
              {
                if ( !sub_D564(*(_DWORD **)(v44 + 8), SHIDWORD(v42)) )
                  goto LABEL_18;
              }
              else if ( HIDWORD(v42) != v45 )
              {
                goto LABEL_18;
              }
              v51 = v43[1];
              ++v43;
              v44 = v51;
              if ( !v51 )
                break;
              v45 = *(unsigned __int16 *)(v44 + 6);
              v46 = v45 & 0xFFFFFFFD;
            }
            LODWORD(v42) = v50 << 8;
            goto LABEL_79;
          }
        }
        else if ( HIDWORD(v42) == 3 )
        {
          v50 = v9 >> 3;
          if ( v9 == 8 * (v9 >> 3) )
            goto LABEL_99;
        }
      }
LABEL_18:
      if ( v9 <= 4 )
      {
LABEL_3:
        v5 = v55;
        v6 = 4;
      }
      else
      {
        v6 = 6;
        v5 = v55 + 4;
      }
LABEL_4:
      v7 = ((v5 - 1) | 7) + 1;
      if ( v7 <= 0xF )
        v7 = 16;
      result = 0;
      v2[4] = v7;
      v2[5] = v6;
      return result;
    default:
      abort();
      return result;
  }
}
// E550: variable 'v1' is possibly undefined
// FFFE: using guessed type __int16 word_FFFE;

//----- (0000E6EC) --------------------------------------------------------
int __fastcall sub_E6EC(int *a1)
{
  if ( *a1 == 2 )
    *a1 = 1;
  return sub_E184(a1);
}

//----- (0000E720) --------------------------------------------------------
int __fastcall sub_E720(int a1, void (__fastcall *a2)(int, int, _DWORD *, int, _DWORD), int a3, int a4)
{
  int v4; // r7
  bool v6; // zf
  int v8; // r1
  int v9; // r0
  int **v10; // lr
  int **v11; // r7
  _DWORD *v12; // r6
  int *v13; // t1
  int v14; // r0
  unsigned int v15; // r12
  int v16; // r8
  int v17; // r12
  int v18; // r0
  _DWORD v20[7]; // [sp+0h] [bp-1Ch] BYREF

  v20[0] = a4;
  v4 = *(_DWORD *)(a1 + 4);
  v6 = *(_DWORD *)(a1 + 20) == 6;
  v8 = a4 + 64;
  v9 = a4 + 96;
  v10 = *(int ***)(a1 + 8);
  if ( v6 )
  {
    v8 = *(_DWORD *)(a4 + 96);
    v9 = a4 + 100;
  }
  else if ( (unsigned int)(**(_DWORD **)(a1 + 12) - 1) <= 2 )
  {
    *(_DWORD *)(a4 + 64) = 0;
    v4 = *(_DWORD *)(a1 + 4);
  }
  if ( v4 > 0 )
  {
    v11 = &v10[v4];
    v12 = &v20[-1];
    do
    {
      v13 = *v10++;
      v14 = v9 - 1;
      v15 = *((unsigned __int16 *)v13 + 2);
      v16 = *v13;
      if ( v15 <= 3 )
        v17 = 3;
      else
        v17 = v15 - 1;
      v18 = (v17 | v14) + 1;
      v12[1] = v18;
      ++v12;
      v9 = v18 + v16;
    }
    while ( v10 != v11 );
  }
  a2(a1, v8, v20, a3, v20[0]);
  return *(_DWORD *)(a1 + 20);
}

//----- (0000E7E8) --------------------------------------------------------
int __fastcall sub_E7E8(int a1, void (__fastcall *a2)(int, int, unsigned int *, int), int a3, int a4)
{
  int v4; // r9
  int v5; // r12
  int v6; // r0
  int v7; // r2
  int v8; // r3
  int v9; // r12
  int v10; // r7
  int v11; // r10
  int v12; // r9
  int v13; // r8
  int v14; // t1
  int v15; // r4
  unsigned int v16; // r5
  int v17; // r1
  _BOOL4 v18; // r4
  unsigned int v19; // r3
  int v20; // r0
  int v21; // r1
  int v22; // r0
  int v23; // r1
  unsigned int v24; // r2
  unsigned int v25; // lr
  unsigned int v27; // r3
  int v28; // r6
  int v29; // r5
  int v30; // t1
  int v31; // r0
  int v32; // r4
  unsigned int v33; // r2
  unsigned int v34; // r3
  int v35; // r4
  _BOOL4 v36; // r1
  int v37; // r3
  int v38; // r1
  _BOOL4 v39; // r1
  int v40; // r5
  int v41; // r1
  int v42; // r4
  int v43; // r3
  unsigned int v44; // r2
  int v45; // r5
  int v46; // t1
  unsigned int v47; // [sp+0h] [bp-64h] BYREF
  int v48; // [sp+4h] [bp-60h]
  int v49; // [sp+8h] [bp-5Ch]
  void (__fastcall *v50)(int, int, unsigned int *, int); // [sp+Ch] [bp-58h]
  int v51; // [sp+10h] [bp-54h]
  int v52; // [sp+14h] [bp-50h]
  int v53; // [sp+18h] [bp-4Ch]
  unsigned int v54; // [sp+1Ch] [bp-48h]
  unsigned int v55; // [sp+20h] [bp-44h]
  int v56; // [sp+24h] [bp-40h]
  unsigned int v57; // [sp+28h] [bp-3Ch]
  unsigned int *v58; // [sp+2Ch] [bp-38h]
  int v59; // [sp+30h] [bp-34h]
  int v60; // [sp+34h] [bp-30h]
  int v61; // [sp+38h] [bp-2Ch]
  int v62; // [sp+3Ch] [bp-28h]

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(a1 + 4);
  v49 = a3;
  v53 = a4;
  v59 = v6;
  v55 = a4 + 112;
  if ( v5 == 6 )
    v7 = *(_DWORD *)(a4 + 96);
  else
    v7 = a4 + 64;
  if ( v5 == 6 )
    v8 = a4 + 100;
  else
    v8 = a4 + 96;
  v56 = v8;
  v48 = v7;
  v50 = a2;
  v58 = &v47;
  v9 = *(_DWORD *)(v4 + 8);
  if ( v59 > 0 )
  {
    v60 = 0;
    v61 = 0;
    v10 = 0;
    v11 = 0;
    v62 = v4;
    v12 = v9 - 4;
    v57 = v55;
    while ( 1 )
    {
      v14 = *(_DWORD *)(v12 + 4);
      v12 += 4;
      v13 = v14;
      v15 = *(unsigned __int16 *)(v14 + 6);
      switch ( *(_WORD *)(v14 + 6) )
      {
        case 2:
        case 3:
          v16 = *(_DWORD *)v13;
          v17 = 256;
          goto LABEL_36;
        case 0xD:
          v27 = *(_DWORD *)v13;
          v54 = v27;
          if ( v27 - 4 > 0x1C )
          {
            v16 = v27;
            goto LABEL_12;
          }
          v52 = *(_DWORD *)(v13 + 8);
          v28 = *(_DWORD *)v52;
          v51 = *(unsigned __int16 *)(*(_DWORD *)v52 + 6);
          v47 = v51 & 0xFFFFFFFD;
          if ( (v51 & 0xFFFFFFFD) == 13 )
          {
            v29 = v52 - 4;
            do
            {
              v30 = *(_DWORD *)(v29 + 4);
              v29 += 4;
              v31 = sub_D2B8(*(_DWORD **)(v30 + 8));
            }
            while ( v31 < 0 );
            v32 = v31;
            if ( v31 != 2 )
            {
LABEL_32:
              if ( v32 != 3 )
              {
LABEL_62:
                v16 = v54;
                goto LABEL_12;
              }
              v33 = v54;
              v34 = v54 >> 3;
              if ( v54 != 8 * (v54 >> 3) )
                goto LABEL_34;
              goto LABEL_56;
            }
          }
          else
          {
            v32 = v51;
            if ( v51 != 2 )
              goto LABEL_32;
          }
          v33 = v54;
          v34 = v54 >> 2;
          v39 = v54 != 4 * (v54 >> 2);
          if ( v54 >> 2 > 4 )
            v39 = 1;
          if ( v39 )
          {
LABEL_34:
            v16 = v33;
LABEL_12:
            v18 = 1;
            goto LABEL_13;
          }
LABEL_56:
          v40 = v52;
          v41 = v32;
          v52 = v34;
          v42 = v40;
          v43 = v51;
          v44 = v47;
          v45 = v41;
          while ( 1 )
          {
            if ( v44 == 13 )
            {
              if ( !sub_D564(*(_DWORD **)(v28 + 8), v45) )
                goto LABEL_62;
            }
            else if ( v45 != v43 )
            {
              goto LABEL_62;
            }
            v46 = *(_DWORD *)(v42 + 4);
            v42 += 4;
            v28 = v46;
            if ( !v46 )
              break;
            v43 = *(unsigned __int16 *)(v28 + 6);
            v44 = v43 & 0xFFFFFFFD;
          }
          v15 = v45;
          v17 = v52 << 8;
          v16 = v54;
LABEL_36:
          v35 = v15 | v17;
          if ( *(unsigned __int16 *)(v62 + 30) > v10 )
            v36 = v35 != 0;
          else
            v36 = 0;
          if ( v36 )
          {
            v37 = *(char *)(v62 + v10++ + 32);
            v58[v11] = v53 + 4 * v37;
            goto LABEL_24;
          }
          v18 = v35 == 0;
LABEL_13:
          v19 = *(unsigned __int16 *)(v13 + 4);
          if ( (v18 & (v61 ^ 1)) == 0 )
            goto LABEL_43;
          if ( v19 <= 3 )
            v20 = 3;
          else
            v20 = v19 - 1;
          v21 = v20 | (v56 - 1);
          if ( v16 < 4 )
            v16 = 4;
          v22 = v60 ^ 1;
          v23 = v21 + 1;
          v24 = v55;
          v25 = v23 + v16;
          if ( v55 >= v23 + v16 )
            v22 |= 1u;
          if ( v22 )
          {
            v58[v11] = v23;
            if ( v24 >= v25 )
            {
              if ( v24 <= v25 )
              {
                v60 = 1;
                v56 = v23 + v16;
                v61 = 1;
              }
              else
              {
                v56 = v23 + v16;
                v61 = 0;
              }
            }
            else
            {
              v56 = v23 + v16;
              v60 = 1;
              v57 = v23 + v16;
              v61 = 1;
            }
          }
          else
          {
LABEL_43:
            if ( v19 > 3 )
              v13 = v19 - 1;
            if ( v19 <= 3 )
              v13 = 3;
            v38 = (v13 | (v57 - 1)) + 1;
            v58[v11] = v38;
            v57 = v38 + v16;
            v60 = 1;
          }
LABEL_24:
          if ( v59 == ++v11 )
          {
            v4 = v62;
            goto LABEL_26;
          }
          break;
        case 0xF:
          v16 = *(_DWORD *)v13;
          v15 = *(unsigned __int16 *)(**(_DWORD **)(v13 + 8) + 6);
          if ( (unsigned int)(v15 - 2) > 1 )
            goto LABEL_12;
          v17 = 512;
          goto LABEL_36;
        default:
          v16 = *(_DWORD *)v13;
          goto LABEL_12;
      }
    }
  }
LABEL_26:
  v50(v4, v48, v58, v49);
  return *(_DWORD *)(v4 + 20);
}

//----- (0000EB98) --------------------------------------------------------
char *__fastcall sub_EB98(_DWORD *a1, _DWORD *a2, int a3, int a4, int a5)
{
  void (__fastcall *v6)(int, int, int, int); // r8
  int v11; // r2
  void *v12; // r3
  int v13; // r2
  void *v14; // r3

  if ( *a2 == 2 )
  {
    v6 = sub_ED78;
    if ( !a2[6] )
      v6 = sub_ED30;
  }
  else
  {
    if ( *a2 != 1 )
      return (char *)&dword_0 + 2;
    v6 = sub_ED30;
  }
  memcpy(a1, dword_EDE8, 8u);
  sub_10904(a1, a1 + 2, v11, v12);
  sub_10904((void *)a5, (void *)(a5 + 8), v13, v14);
  a1[2] = v6;
  a1[3] = a2;
  a1[4] = a3;
  a1[5] = a4;
  return 0;
}
// EBF8: variable 'v11' is possibly undefined
// EBF8: variable 'v12' is possibly undefined
// EC04: variable 'v13' is possibly undefined
// EC04: variable 'v14' is possibly undefined
// 0: using guessed type int dword_0;
// EDE8: using guessed type int dword_EDE8[2];

//----- (0000ECA0) --------------------------------------------------------
int __fastcall sub_ECA0(int a1)
{
  return sub_ECB0(a1 + 64);
}
// ECB0: using guessed type int __fastcall sub_ECB0(_DWORD);

//----- (0000ECB0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __fastcall sub_ECB0(int a1, _DWORD *a2, __int64 (__fastcall *a3)())
{
  int v3; // r11
  int v4; // lr
  __int64 v6; // r0

  *a2 = v3;
  a2[1] = v4;
  v6 = a3();
  return ((int (__fastcall *)(_DWORD, _DWORD, _DWORD))((char *)sub_ECE0 + 8 * a2[3]))(v6, HIDWORD(v6), a2[2]);
}
// ECC8: positive sp value 10 has been found
// ECB0: variable 'v3' is possibly undefined
// ECB0: variable 'v4' is possibly undefined
// ECE0: using guessed type int sub_ECE0();

//----- (0000ED18) --------------------------------------------------------
void sub_ED18()
{
  JUMPOUT(0xED40);
}
// ED28: control flows out of bounds to ED40

//----- (0000ED30) --------------------------------------------------------
void __fastcall sub_ED30(int a1, int a2, int a3, int a4)
{
  int v4; // r12
  char *v5; // kr00_4
  char v6[64]; // [sp+8h] [bp-70h] BYREF
  int varg_r0; // [sp+68h] [bp-10h]
  int varg_r1; // [sp+6Ch] [bp-Ch]
  int varg_r2; // [sp+70h] [bp-8h]
  int varg_r3; // [sp+74h] [bp-4h]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  v5 = (char *)sub_EDB0
     + 8
     * sub_E720(
         *(_DWORD *)(v4 + 12),
         *(void (__fastcall **)(int, int, _DWORD *, int, _DWORD))(v4 + 16),
         *(_DWORD *)(v4 + 20),
         (int)v6);
  __asm { ADD             PC, R3, R0,LSL#3 }
}
// ED34: variable 'v4' is possibly undefined

//----- (0000ED60) --------------------------------------------------------
void sub_ED60()
{
  JUMPOUT(0xED88);
}
// ED70: control flows out of bounds to ED88

//----- (0000ED78) --------------------------------------------------------
void __fastcall sub_ED78(int a1, int a2, int a3, int a4)
{
  _DWORD *v4; // r12
  __int64 v5; // d0
  __int64 v6; // d1
  __int64 v7; // d2
  __int64 v8; // d3
  __int64 v9; // d4
  __int64 v10; // d5
  __int64 v11; // d6
  __int64 v12; // d7
  int v13; // r0
  void (__fastcall *v14)(int, int, unsigned int *, int); // r1
  int v15; // r2
  char *v16; // kr00_4
  __int64 v17; // [sp+8h] [bp-70h] BYREF
  __int64 v18; // [sp+10h] [bp-68h]
  __int64 v19; // [sp+18h] [bp-60h]
  __int64 v20; // [sp+20h] [bp-58h]
  __int64 v21; // [sp+28h] [bp-50h]
  __int64 v22; // [sp+30h] [bp-48h]
  __int64 v23; // [sp+38h] [bp-40h]
  __int64 v24; // [sp+40h] [bp-38h]
  int varg_r0; // [sp+68h] [bp-10h]
  int varg_r1; // [sp+6Ch] [bp-Ch]
  int varg_r2; // [sp+70h] [bp-8h]
  int varg_r3; // [sp+74h] [bp-4h]

  varg_r0 = a1;
  varg_r1 = a2;
  varg_r2 = a3;
  varg_r3 = a4;
  v13 = v4[3];
  v14 = (void (__fastcall *)(int, int, unsigned int *, int))v4[4];
  v15 = v4[5];
  v17 = v5;
  v18 = v6;
  v19 = v7;
  v20 = v8;
  v21 = v9;
  v22 = v10;
  v23 = v11;
  v24 = v12;
  v16 = (char *)sub_EDB0 + 8 * sub_E7E8(v13, v14, v15, (int)&v17);
  __asm { ADD             PC, R3, R0,LSL#3 }
}
// ED7C: variable 'v4' is possibly undefined
// ED90: variable 'v5' is possibly undefined
// ED90: variable 'v6' is possibly undefined
// ED90: variable 'v7' is possibly undefined
// ED90: variable 'v8' is possibly undefined
// ED90: variable 'v9' is possibly undefined
// ED90: variable 'v10' is possibly undefined
// ED90: variable 'v11' is possibly undefined
// ED90: variable 'v12' is possibly undefined

//----- (0000EDB0) --------------------------------------------------------
void __fastcall sub_EDB0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  __asm { LDMFD           SP, {SP,PC} }
}

//----- (0000EDF4) --------------------------------------------------------
unsigned int *__fastcall sub_EDF4(unsigned int *result, int *a2, int *a3)
{
  unsigned int v3; // r3
  unsigned int v4; // t1
  int v5; // r12
  bool v6; // zf
  int v7; // r3
  int v8; // r12

  v3 = *result;
  if ( (*result & 0x80000000) == 0 )
  {
    *a2 = 1;
    v4 = result[1];
    ++result;
    *a3 = 4 * HIBYTE(v4) + 4;
    return result;
  }
  v5 = HIBYTE(v3) & 0xF;
  if ( v5 )
  {
    v6 = v5 == 3;
    if ( v5 != 3 )
      v6 = v5 == 1;
    if ( !v6 )
      return 0;
    v7 = 4 * BYTE2(v3) + 4;
    v8 = 2;
  }
  else
  {
    v8 = 1;
    v7 = 4;
  }
  *a3 = v7;
  *a2 = v8;
  return result;
}

//----- (0000EE48) --------------------------------------------------------
int __fastcall sub_EE48(int a1, int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v6; // r11
  int v8; // r5
  unsigned int v9; // r6
  int v10; // r10
  int v11; // r2
  int v12; // r2
  unsigned int v13; // r3
  int v14; // r2
  int v15; // r0
  unsigned int v16; // r1
  int result; // r0
  int v18; // r2
  int v19; // r0
  unsigned int v20; // r1
  unsigned int v21; // r3
  int v22; // r10
  int v23; // r0
  int v24; // r5
  int v25; // r1
  int v26; // r0
  unsigned int v33; // r1
  unsigned int v34; // r0
  int v35; // r1
  unsigned int v36; // r1
  int v37; // [sp+4h] [bp-24h] BYREF

  v6 = a3;
  if ( a3 < a4 )
  {
    v8 = 0;
    do
    {
      v9 = v6 + 1;
      v10 = *(unsigned __int8 *)(a2 + (v6 ^ 3));
      if ( (v10 & 0x80) != 0 )
      {
        switch ( ((v10 & 0xF0u) - 128) >> 4 )
        {
          case 0u:
            if ( v9 >= a4 )
              return 9;
            v12 = (unsigned __int16)((_WORD)v10 << 12) | (16 * *(unsigned __int8 *)(a2 + (v9 ^ 3)));
            if ( !v12 )
              return 9;
            sub_F1E4(a1, 0, v12, 0);
            v6 += 2;
            v8 |= (unsigned __int16)(((_WORD)v10 << 12) & 0x8000) >> 15;
            continue;
          case 1u:
            if ( (((unsigned __int8)v10 | 2) & 0xF) == 15 )
              return 9;
            sub_F650(a1, v10 & 0xF, &v37);
            v11 = v37;
            goto LABEL_12;
          case 2u:
            v13 = 0;
            v14 = ((32 << (v10 & 7)) - 16) | (v10 << 11) & 0x4000;
            v15 = a1;
            v16 = 0;
            goto LABEL_26;
          case 3u:
            result = 9;
            switch ( *(_BYTE *)(a2 + (v6 ^ 3)) )
            {
              case 0xB0:
                goto LABEL_48;
              case 0xB1:
                if ( v9 >= a4 )
                  return 9;
                v18 = *(unsigned __int8 *)(a2 + (v9 ^ 3));
                result = 9;
                if ( !*(_BYTE *)(a2 + (v9 ^ 3)) || (v18 & 0xF0) != 0 )
                  return result;
                v19 = a1;
                v20 = 0;
                v21 = 0;
                goto LABEL_43;
              case 0xB2:
                v22 = v8;
                v23 = 0;
                v24 = 0;
                break;
              case 0xB3:
                v21 = 1;
                v26 = *(unsigned __int8 *)(a2 + (v9 ^ 3));
                _R1 = v26 << 12;
                __asm { UXTB16.W        R1, R1 }
                v18 = _R1 | ((v26 & 0xF) + 1);
                v19 = a1;
                v20 = 1;
                goto LABEL_43;
              case 0xB4:
              case 0xB5:
              case 0xB6:
              case 0xB7:
                return result;
              default:
                v16 = 1;
                v13 = 1;
                v14 = ((v10 & 7) + 1) | 0x80000;
                v15 = a1;
                goto LABEL_26;
            }
            break;
          case 4u:
            switch ( *(_BYTE *)(a2 + (v6 ^ 3)) )
            {
              case 0xC0:
              case 0xC1:
              case 0xC2:
              case 0xC3:
              case 0xC4:
              case 0xC5:
                v16 = 3;
                v14 = ((v10 & 7) + 1) | 0xA0000;
                goto LABEL_25;
              case 0xC6:
                v36 = *(unsigned __int8 *)(a2 + (v9 ^ 3));
                if ( (v36 & 0xF) + (v36 >> 4) > 0xF )
                  return 9;
                v18 = (unsigned __int8)((v36 & 0xF) + 1) | (*(_BYTE *)(a2 + (v9 ^ 3)) >> 4 << 16);
                v19 = a1;
                v20 = 3;
                goto LABEL_42;
              case 0xC7:
                if ( !*(_BYTE *)(a2 + (v9 ^ 3)) || *(unsigned __int8 *)(a2 + (v9 ^ 3)) >= 0x10u )
                  return 9;
                goto LABEL_44;
              case 0xC8:
              case 0xC9:
                v33 = *(unsigned __int8 *)(a2 + (v9 ^ 3));
                v34 = v33 >> 4;
                if ( v10 == 200 )
                  v34 = (v33 >> 4) | 0x10;
                v35 = v33 & 0xF;
                if ( v34 + v35 > 0x1F )
                  return 9;
                v18 = (v35 + 1) | (v34 << 16);
                v19 = a1;
                v20 = 1;
LABEL_42:
                v21 = 5;
LABEL_43:
                sub_F1E4(v19, v20, v18, v21);
LABEL_44:
                v6 += 2;
                break;
              default:
                return 9;
            }
            continue;
          case 5u:
            if ( (v10 & 8) != 0 )
              return 9;
            v16 = 1;
            v14 = ((v10 & 7) + 1) | 0x80000;
LABEL_25:
            v15 = a1;
            v13 = 5;
LABEL_26:
            sub_F1E4(v15, v16, v14, v13);
            goto LABEL_27;
          default:
            return 9;
        }
        while ( v9 < a4 )
        {
          v25 = v9++ ^ 3;
          LOBYTE(v25) = *(_BYTE *)(a2 + v25);
          v24 |= (v25 & 0x7F) << v23;
          v23 += 7;
          if ( (v25 & 0x80) == 0 )
          {
            sub_F650(a1, 13, &v37);
            v37 += 4 * v24 + 516;
            sub_F688(a1, 13, v37);
            v6 = v9;
            v8 = v22;
            goto LABEL_28;
          }
        }
        return 9;
      }
      sub_F650(a1, 13, &v37);
      if ( (v10 & 0x40) != 0 )
        v11 = -4 - (unsigned __int8)(4 * v10) + v37;
      else
        v11 = 4 * v10 + v37 + 4;
      v37 = v11;
LABEL_12:
      sub_F688(a1, 13, v11);
LABEL_27:
      ++v6;
LABEL_28:
      ;
    }
    while ( v6 < a4 );
LABEL_48:
    if ( v8 << 31 )
      return 8;
  }
  sub_F650(a1, 14, &v37);
  sub_F688(a1, 15, v37);
  return 8;
}

//----- (0000F104) --------------------------------------------------------
int __fastcall sub_F104(int a1, int a2, unsigned int a3, int a4, int *a5)
{
  int result; // r0
  int v8; // r2
  int v9; // r0
  int v10; // r1
  __int64 v11; // r2
  int v12; // r1

  switch ( a2 )
  {
    case 0:
      result = 2;
      if ( a3 > 0xF || a4 )
        return result;
      v8 = *a5;
      v9 = a1;
      v10 = a3;
      goto LABEL_11;
    case 1:
      if ( a4 == 5 )
      {
        if ( a3 <= 0x1F )
          goto LABEL_18;
        return 2;
      }
      if ( a4 != 1 || a3 > 0xF )
        return 2;
      sub_F74A(a1);
LABEL_18:
      v11 = *(_QWORD *)a5;
      v12 = a3 + 256;
LABEL_19:
      result = sub_F6D4(a1, v12, v11, SHIDWORD(v11));
LABEL_20:
      if ( result )
        result = 2;
      return result;
    case 3:
      result = 2;
      if ( a3 > 0x1F || a4 != 5 )
        return result;
      v11 = *(_QWORD *)a5;
      v12 = a3 + 112;
      goto LABEL_19;
    case 4:
      result = 2;
      if ( a3 > 3 || a4 )
        return result;
      v8 = *a5;
      v10 = a3 + 192;
      v9 = a1;
LABEL_11:
      result = sub_F688(v9, v10, v8);
      goto LABEL_20;
    default:
      fprintf(
        (FILE *)((char *)&_sF + 168),
        "libunwind: %s %s:%d - %s\n",
        "_Unwind_VRS_Set",
        "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Unwind-EHABI.cpp",
        837,
        "unsupported register class");
      fflush((FILE *)((char *)&_sF + 168));
      abort();
      return result;
  }
}

//----- (0000F1E4) --------------------------------------------------------
int __fastcall sub_F1E4(int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned __int64 v5; // r4
  int v7; // r6
  int *v8; // r0
  int result; // r0
  unsigned int v10; // r6
  unsigned int v11; // r9
  _DWORD *v12; // r0
  int v13; // r1
  int v14; // r0
  int v15; // r2
  int v16[3]; // [sp+8h] [bp-30h] BYREF
  _DWORD *v17; // [sp+14h] [bp-24h] BYREF

  v5 = __PAIR64__(a2, a4);
  switch ( a2 )
  {
    case 0u:
    case 4u:
      if ( a4 || sub_F650(a1, 13, v16) )
        return 2;
      v7 = 0;
      LODWORD(v5) = 0;
      do
      {
        if ( ((1 << v5) & a3) != 0 )
        {
          v8 = (int *)v16[0];
          v16[0] += 4;
          v17 = (_DWORD *)*v8;
          if ( sub_F104(a1, SHIDWORD(v5), v5, 0, (int *)&v17) )
            return 2;
          v7 |= v5 == 13;
        }
        LODWORD(v5) = v5 + 1;
      }
      while ( (unsigned int)v5 < 0x10 );
      if ( v7 << 31 )
        return 0;
      v15 = v16[0];
      goto LABEL_22;
    case 1u:
    case 3u:
      if ( (a4 | 4) != 5 || sub_F650(a1, 13, &v17) )
        return 2;
      if ( !(_WORD)a3 )
        goto LABEL_18;
      v10 = HIWORD(a3);
      v11 = HIWORD(a3) + (unsigned __int16)a3;
      break;
    default:
      fprintf(
        (FILE *)((char *)&_sF + 168),
        "libunwind: %s %s:%d - %s\n",
        "_Unwind_VRS_Pop",
        "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Unwind-EHABI.cpp",
        971,
        "unsupported register class");
      fflush((FILE *)((char *)&_sF + 168));
      abort();
      return result;
  }
  do
  {
    v12 = v17;
    v13 = *v17;
    v17 += 2;
    v14 = v12[1];
    v16[0] = v13;
    v16[1] = v14;
    if ( sub_F104(a1, SHIDWORD(v5), v10, v5, v16) )
      return 2;
    ++v10;
  }
  while ( v10 < v11 );
LABEL_18:
  if ( (_DWORD)v5 == 1 )
    v15 = (int)++v17;
  else
    v15 = (int)v17;
LABEL_22:
  result = sub_F688(a1, 13, v15);
  if ( result )
    result = 2;
  return result;
}

//----- (0000F3C8) --------------------------------------------------------
int __fastcall sub_F3C8(const void *a1, int *a2, char a3)
{
  int i; // r5
  int v6; // r6
  int (__fastcall *v7)(int, int *, char *); // r3
  int v8; // r1
  int v9; // r2
  int v10; // r0
  int v12; // [sp+8h] [bp-4B0h] BYREF
  int v13[3]; // [sp+Ch] [bp-4ACh] BYREF
  int (__fastcall *v14)(int, int *, char *); // [sp+18h] [bp-4A0h]
  int v15; // [sp+20h] [bp-498h]
  int v16; // [sp+2Ch] [bp-48Ch]
  int v17; // [sp+34h] [bp-484h] BYREF
  char v18[1120]; // [sp+38h] [bp-480h] BYREF
  int v19; // [sp+498h] [bp-20h]

  sub_F608((int)v18, a1);
  for ( i = 1; ; --i )
  {
    v6 = 1;
    if ( (a3 & 1) != 0 )
    {
      v6 = 2;
      if ( !i )
      {
        sub_F688((int)v18, -1, a2[4]);
        a3 = 0;
      }
    }
    sub_F650((int)v18, -2, &v17);
    if ( sub_F716((int)v18, (int)v13) )
      break;
    v7 = v14;
    if ( v14 )
    {
      v8 = v16;
      v9 = v15;
      a2[18] = v13[0];
      a2[19] = v8;
      a2[20] = v9;
      v10 = v7(v6, a2, v18);
      if ( v10 == 7 )
      {
        sub_F650((int)v18, -1, &v12);
        a2[4] = v12;
        sub_F736((int)v18);
        return _stack_chk_guard - v19;
      }
      if ( v10 != 8 )
      {
        if ( v10 == 9 )
          abort();
        return _stack_chk_guard - v19;
      }
      if ( v17 == a2[8] )
      {
        fprintf(
          (FILE *)((char *)&_sF + 168),
          "libunwind: %s %s:%d - %s\n",
          "unwind_phase2",
          "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Unwind-EHABI.cpp",
          653,
          "during phase1 personality function said it would stop here, but now in phase2 it did not stop here");
        fflush((FILE *)((char *)&_sF + 168));
        abort();
      }
    }
  }
  return _stack_chk_guard - v19;
}

//----- (0000F4F8) --------------------------------------------------------
void __fastcall __noreturn sub_F4F8(int *a1, int a2, int a3, int a4)
{
  int v5; // [sp+0h] [bp-410h]
  _DWORD v6[258]; // [sp+8h] [bp-408h] BYREF

  sub_F580(v6, a2, a3, a4, v5);
  sub_F3C8(v6, a1, 1);
  fprintf(
    (FILE *)((char *)&_sF + 168),
    "libunwind: %s %s:%d - %s\n",
    "_Unwind_Resume",
    "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Unwind-EHABI.cpp",
    753,
    "_Unwind_Resume() can't return");
  fflush((FILE *)((char *)&_sF + 168));
  abort();
}
// F506: variable 'v5' is possibly undefined

//----- (0000F580) --------------------------------------------------------
int __fastcall sub_F580(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int v5; // r4
  int v6; // r5
  int v7; // r6
  int v8; // r7
  int v9; // r8
  int v10; // r9
  int v11; // r10
  int v12; // r11
  int v13; // r12
  int v14; // lr

  *a1 = a1;
  a1[1] = a2;
  a1[2] = a3;
  a1[3] = a4;
  a1[4] = v5;
  a1[5] = v6;
  a1[6] = v7;
  a1[7] = v8;
  a1[8] = v9;
  a1[9] = v10;
  a1[10] = v11;
  a1[11] = v12;
  a1[12] = v13;
  a1[13] = &a5;
  a1[14] = v14;
  a1[15] = v14;
  return 0;
}
// F580: variable 'v5' is possibly undefined
// F580: variable 'v6' is possibly undefined
// F580: variable 'v7' is possibly undefined
// F580: variable 'v8' is possibly undefined
// F580: variable 'v9' is possibly undefined
// F580: variable 'v10' is possibly undefined
// F580: variable 'v11' is possibly undefined
// F580: variable 'v12' is possibly undefined
// F580: variable 'v13' is possibly undefined
// F588: variable 'v14' is possibly undefined

//----- (0000F598) --------------------------------------------------------
_QWORD *__fastcall sub_F598(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// F598: variable 'v1' is possibly undefined
// F598: variable 'v2' is possibly undefined
// F598: variable 'v3' is possibly undefined
// F598: variable 'v4' is possibly undefined
// F598: variable 'v5' is possibly undefined
// F598: variable 'v6' is possibly undefined
// F598: variable 'v7' is possibly undefined
// F598: variable 'v8' is possibly undefined
// F598: variable 'v9' is possibly undefined
// F598: variable 'v10' is possibly undefined
// F598: variable 'v11' is possibly undefined
// F598: variable 'v12' is possibly undefined
// F598: variable 'v13' is possibly undefined
// F598: variable 'v14' is possibly undefined
// F598: variable 'v15' is possibly undefined
// F598: variable 'v16' is possibly undefined

//----- (0000F5A0) --------------------------------------------------------
_QWORD *__fastcall sub_F5A0(_QWORD *result)
{
  __int64 v1; // d0
  __int64 v2; // d1
  __int64 v3; // d2
  __int64 v4; // d3
  __int64 v5; // d4
  __int64 v6; // d5
  __int64 v7; // d6
  __int64 v8; // d7
  __int64 v9; // d8
  __int64 v10; // d9
  __int64 v11; // d10
  __int64 v12; // d11
  __int64 v13; // d12
  __int64 v14; // d13
  __int64 v15; // d14
  __int64 v16; // d15

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// F5A0: variable 'v1' is possibly undefined
// F5A0: variable 'v2' is possibly undefined
// F5A0: variable 'v3' is possibly undefined
// F5A0: variable 'v4' is possibly undefined
// F5A0: variable 'v5' is possibly undefined
// F5A0: variable 'v6' is possibly undefined
// F5A0: variable 'v7' is possibly undefined
// F5A0: variable 'v8' is possibly undefined
// F5A0: variable 'v9' is possibly undefined
// F5A0: variable 'v10' is possibly undefined
// F5A0: variable 'v11' is possibly undefined
// F5A0: variable 'v12' is possibly undefined
// F5A0: variable 'v13' is possibly undefined
// F5A0: variable 'v14' is possibly undefined
// F5A0: variable 'v15' is possibly undefined
// F5A0: variable 'v16' is possibly undefined

//----- (0000F5A8) --------------------------------------------------------
_QWORD *__fastcall sub_F5A8(_QWORD *result)
{
  __int64 v1; // d16
  __int64 v2; // d17
  __int64 v3; // d18
  __int64 v4; // d19
  __int64 v5; // d20
  __int64 v6; // d21
  __int64 v7; // d22
  __int64 v8; // d23
  __int64 v9; // d24
  __int64 v10; // d25
  __int64 v11; // d26
  __int64 v12; // d27
  __int64 v13; // d28
  __int64 v14; // d29
  __int64 v15; // d30
  __int64 v16; // d31

  *result = v1;
  result[1] = v2;
  result[2] = v3;
  result[3] = v4;
  result[4] = v5;
  result[5] = v6;
  result[6] = v7;
  result[7] = v8;
  result[8] = v9;
  result[9] = v10;
  result[10] = v11;
  result[11] = v12;
  result[12] = v13;
  result[13] = v14;
  result[14] = v15;
  result[15] = v16;
  return result;
}
// F5A8: variable 'v1' is possibly undefined
// F5A8: variable 'v2' is possibly undefined
// F5A8: variable 'v3' is possibly undefined
// F5A8: variable 'v4' is possibly undefined
// F5A8: variable 'v5' is possibly undefined
// F5A8: variable 'v6' is possibly undefined
// F5A8: variable 'v7' is possibly undefined
// F5A8: variable 'v8' is possibly undefined
// F5A8: variable 'v9' is possibly undefined
// F5A8: variable 'v10' is possibly undefined
// F5A8: variable 'v11' is possibly undefined
// F5A8: variable 'v12' is possibly undefined
// F5A8: variable 'v13' is possibly undefined
// F5A8: variable 'v14' is possibly undefined
// F5A8: variable 'v15' is possibly undefined
// F5A8: variable 'v16' is possibly undefined

//----- (0000F5B0) --------------------------------------------------------
void sub_F5B0()
{
  __asm
  {
    STCL            p1, c0, [R0],#8
    STCL            p1, c1, [R0],#8
    STCL            p1, c2, [R0],#8
    STCL            p1, c3, [R0],#8
    STCL            p1, c4, [R0],#8
    STCL            p1, c5, [R0],#8
    STCL            p1, c6, [R0],#8
    STCL            p1, c7, [R0],#8
    STCL            p1, c8, [R0],#8
    STCL            p1, c9, [R0],#8
    STCL            p1, c10, [R0],#8
    STCL            p1, c11, [R0],#8
    STCL            p1, c12, [R0],#8
    STCL            p1, c13, [R0],#8
    STCL            p1, c14, [R0],#8
    STCL            p1, c15, [R0],#8
  }
}

//----- (0000F5F4) --------------------------------------------------------
void sub_F5F4()
{
  __asm
  {
    STC2            p1, c8, [R0],#4
    STC2            p1, c9, [R0],#4
    STC2            p1, c10, [R0],#4
    STC2            p1, c11, [R0],#4
  }
}

//----- (0000F608) --------------------------------------------------------
int __fastcall sub_F608(int a1, const void *a2)
{
  *(_BYTE *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)a1 = &off_13D60;
  *(_DWORD *)(a1 + 4) = &unk_14250;
  qmemcpy((void *)(a1 + 8), a2, 0x40u);
  memset((void *)(a1 + 80), 0, 0x1C2u);
  sub_FA14((int *)a1, 0);
  return 0;
}
// 13D60: using guessed type void *;

//----- (0000F650) --------------------------------------------------------
int __fastcall sub_F650(int a1, int a2, _DWORD *a3)
{
  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1 )
    return -6542;
  *a3 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, a2);
  return 0;
}

//----- (0000F688) --------------------------------------------------------
int __fastcall sub_F688(int a1, int a2, int a3)
{
  int v6; // r5

  if ( (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 8))(a1) != 1 )
    return -6542;
  (*(void (__fastcall **)(int, int, int))(*(_DWORD *)a1 + 16))(a1, a2, a3);
  if ( a2 != -1 )
    return 0;
  v6 = 0;
  (*(void (__fastcall **)(int, _DWORD))(*(_DWORD *)a1 + 52))(a1, 0);
  return v6;
}

//----- (0000F6D4) --------------------------------------------------------
int __fastcall sub_F6D4(int a1, int a2, int a3, int a4)
{
  if ( !(*(int (__fastcall **)(int))(*(_DWORD *)a1 + 20))(a1) )
    return -6542;
  (*(void (__fastcall **)(int, int, int, int))(*(_DWORD *)a1 + 28))(a1, a2, a3, a4);
  return 0;
}

//----- (0000F710) --------------------------------------------------------
int __fastcall sub_F710(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 32))(a1);
}

//----- (0000F716) --------------------------------------------------------
int __fastcall sub_F716(int a1, int a2)
{
  int result; // r0

  (*(void (__fastcall **)(int, int))(*(_DWORD *)a1 + 36))(a1, a2);
  result = 0;
  if ( !*(_DWORD *)(a2 + 4) )
    result = -6549;
  return result;
}

//----- (0000F736) --------------------------------------------------------
int __fastcall sub_F736(int a1)
{
  (*(void (__fastcall **)(int))(*(_DWORD *)a1 + 40))(a1);
  return -6540;
}

//----- (0000F74A) --------------------------------------------------------
int __fastcall sub_F74A(int a1)
{
  return (*(int (__fastcall **)(int))(*(_DWORD *)a1 + 60))(a1);
}

//----- (0000F754) --------------------------------------------------------
int __fastcall sub_F754(int a1, int a2)
{
  int v2; // r2
  bool v3; // zf
  int v4; // r0
  unsigned int v5; // r1

  v2 = 0;
  v3 = (a2 & 0xFFFFFFFC) == 192;
  v4 = 0;
  v5 = a2 - 16;
  if ( v3 )
    v4 = 1;
  if ( v5 > 0xFFFFFFED )
    v2 = 1;
  return v4 | v2;
}

//----- (0000F774) --------------------------------------------------------
int __fastcall sub_F774(int a1, int a2)
{
  int v4; // r0

  if ( a2 > 12 )
  {
    if ( a2 != 15 )
    {
      if ( a2 == 14 )
      {
        v4 = a1 + 64;
        return *(_DWORD *)v4;
      }
      if ( a2 != 13 )
        goto LABEL_11;
LABEL_9:
      v4 = a1 + 60;
      return *(_DWORD *)v4;
    }
    goto LABEL_8;
  }
  if ( a2 == -2 )
    goto LABEL_9;
  if ( a2 == -1 )
  {
LABEL_8:
    v4 = a1 + 68;
    return *(_DWORD *)v4;
  }
LABEL_11:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
    {
      fprintf(
        (FILE *)((char *)&_sF + 168),
        "libunwind: %s %s:%d - %s\n",
        "getRegister",
        "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Registers.hpp",
        1460,
        "unsupported arm register");
      fflush((FILE *)((char *)&_sF + 168));
      abort();
    }
    if ( !*(_BYTE *)(a1 + 76) )
    {
      *(_BYTE *)(a1 + 76) = 1;
      sub_F5F4();
    }
    v4 = a1 + 4 * a2 - 296;
  }
  else
  {
    v4 = a1 + 4 * a2 + 8;
  }
  return *(_DWORD *)v4;
}

//----- (0000F82C) --------------------------------------------------------
int __fastcall sub_F82C(int result, int a2, int a3)
{
  int v5; // r5

  v5 = result;
  if ( a2 <= 12 )
  {
    result = a2 + 2;
    if ( a2 == -2 )
      goto LABEL_9;
    result = a2 + 1;
    if ( a2 != -1 )
      goto LABEL_11;
LABEL_8:
    *(_DWORD *)(v5 + 68) = a3;
    return result;
  }
  switch ( a2 )
  {
    case 15:
      goto LABEL_8;
    case 14:
      *(_DWORD *)(result + 64) = a3;
      return result;
    case 13:
LABEL_9:
      *(_DWORD *)(v5 + 60) = a3;
      return result;
  }
LABEL_11:
  if ( (unsigned int)a2 > 0xC )
  {
    if ( (a2 & 0xFFFFFFFC) != 192 )
    {
      fprintf(
        (FILE *)((char *)&_sF + 168),
        "libunwind: %s %s:%d - %s\n",
        "setRegister",
        "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Registers.hpp",
        1479,
        "unsupported arm register");
      fflush((FILE *)((char *)&_sF + 168));
      abort();
    }
    if ( !*(_BYTE *)(v5 + 76) )
    {
      *(_BYTE *)(v5 + 76) = 1;
      sub_F5F4();
    }
    result = v5 + 4 * a2;
    *(_DWORD *)(result - 296) = a3;
  }
  else
  {
    result = v5 + 4 * a2;
    *(_DWORD *)(result + 8) = a3;
  }
  return result;
}

//----- (0000F8EC) --------------------------------------------------------
int __fastcall sub_F8EC(int a1, int a2)
{
  int v2; // r2
  bool v3; // zf
  int v4; // r0
  unsigned int v5; // r1

  v2 = 0;
  v3 = (a2 & 0xFFFFFFF0) == 112;
  v4 = 0;
  v5 = a2 & 0xFFFFFFE0;
  if ( v3 )
    v4 = 1;
  if ( v5 == 256 )
    v2 = 1;
  return v4 | v2;
}

//----- (0000F90C) --------------------------------------------------------
__int64 __fastcall sub_F90C(int a1, int a2)
{
  return sub_FA94(a1 + 8, a2);
}

//----- (0000F912) --------------------------------------------------------
_DWORD *__fastcall sub_F912(int a1, int a2, int a3, int a4)
{
  return sub_FB74(a1 + 8, a2, a3, a4);
}

//----- (0000F918) --------------------------------------------------------
int __fastcall sub_F918(_DWORD *a1)
{
  int result; // r0
  __int64 v3; // kr00_8
  int v4; // r0

  if ( *((_BYTE *)a1 + 528) )
    return 0;
  result = sub_FC60((int)a1);
  if ( result != 1 )
    return result;
  (*(void (__fastcall **)(_DWORD *, int))(*a1 + 52))(a1, 1);
  if ( *((_BYTE *)a1 + 528) )
    return 0;
  if ( a1[126] )
  {
    v3 = *(_QWORD *)(*a1 + 12);
    v4 = ((int (__fastcall *)(_DWORD *, int))v3)(a1, -2);
    ((void (__fastcall *)(_DWORD *, int, int))HIDWORD(v3))(a1, -2, a1[126] + v4);
  }
  return 1;
}

//----- (0000F96A) --------------------------------------------------------
_DWORD *__fastcall sub_F96A(int a1, _DWORD *a2)
{
  int *v2; // r0
  _DWORD *result; // r0
  int v4; // r2
  int v5; // r3
  int v6; // r4
  int v7; // r12
  int v8; // lr
  _DWORD *v9; // r1
  int v10; // r3
  int v11; // r4
  int v12; // r12
  int v13; // lr

  v2 = (int *)(a1 + 488);
  v4 = *v2;
  v5 = v2[1];
  v6 = v2[2];
  v7 = v2[3];
  v8 = v2[4];
  result = v2 + 5;
  *a2 = v4;
  a2[1] = v5;
  a2[2] = v6;
  a2[3] = v7;
  a2[4] = v8;
  v9 = a2 + 5;
  v10 = result[1];
  v11 = result[2];
  v12 = result[3];
  v13 = result[4];
  *v9 = *result;
  v9[1] = v10;
  v9[2] = v11;
  v9[3] = v12;
  v9[4] = v13;
  return result;
}

//----- (0000F984) --------------------------------------------------------
int __fastcall sub_F984(int a1)
{
  int v1; // r4

  v1 = a1 + 8;
  sub_FCB8(a1 + 8);
  return sub_11094(v1);
}

//----- (0000F99C) --------------------------------------------------------
int __fastcall sub_F99C(int a1)
{
  return *(unsigned __int8 *)(a1 + 529);
}

//----- (0000F9A4) --------------------------------------------------------
int __fastcall sub_F9A4(int a1, char *a2, size_t a3, _DWORD *a4)
{
  int v7; // r4
  char v9[8]; // [sp+4h] [bp-24h] BYREF
  int v10; // [sp+Ch] [bp-1Ch]
  int v11; // [sp+10h] [bp-18h]

  v7 = (*(int (__fastcall **)(int, int))(*(_DWORD *)a1 + 12))(a1, -1);
  if ( !dladdr(v7, v9) || !v10 )
    return 0;
  snprintf(a2, a3, (const char *)&dword_FA0C);
  *a4 = v7 - v11;
  return 1;
}
// 1674: using guessed type int __fastcall dladdr(_DWORD, _DWORD);
// FA0C: using guessed type int dword_FA0C;

//----- (0000FA14) --------------------------------------------------------
int __fastcall sub_FA14(int *a1, int a2)
{
  int v3; // r5
  int v5[2]; // [sp+0h] [bp-18h] BYREF
  int v6[4]; // [sp+8h] [bp-10h] BYREF

  v3 = ((*(int (__fastcall **)(int *, int))(*a1 + 12))(a1, -1) & 0xFFFFFFFE) - a2;
  v6[0] = 0;
  v5[0] = _gnu_Unwind_Find_exidx(v3, v6);
  v5[1] = v6[0];
  if ( !v5[0] || !v6[0] || !sub_FD08(a1, v3, v5) )
    *((_BYTE *)a1 + 528) = 1;
  return _stack_chk_guard - v6[1];
}
// 168C: using guessed type int __fastcall _gnu_Unwind_Find_exidx(_DWORD, _DWORD);

//----- (0000FA84) --------------------------------------------------------
int *__fastcall sub_FA84(int a1, int a2)
{
  int *result; // r0

  result = &dword_101A0;
  switch ( a2 )
  {
    case -2:
    case 13:
      result = &dword_102D8;
      break;
    case -1:
    case 15:
      return result;
    case 0:
      result = &dword_102D4;
      break;
    case 1:
      result = &dword_102D0;
      break;
    case 2:
      result = &dword_102CC;
      break;
    case 3:
      result = &dword_102C8;
      break;
    case 4:
      result = &dword_102C4;
      break;
    case 5:
      result = &dword_102C0;
      break;
    case 6:
      result = &dword_102BC;
      break;
    case 7:
      result = &dword_102B8;
      break;
    case 8:
      result = &dword_102B4;
      break;
    case 9:
      result = &dword_102B0;
      break;
    case 10:
      result = &dword_102AC;
      break;
    case 11:
      result = &dword_102A8;
      break;
    case 12:
      result = &dword_102A4;
      break;
    case 14:
      result = &dword_102DC;
      break;
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
LABEL_5:
      result = (int *)"unknown register";
      break;
    case 64:
      result = &dword_102A0;
      break;
    case 65:
      result = &dword_1029C;
      break;
    case 66:
      result = &dword_10298;
      break;
    case 67:
      result = &dword_10294;
      break;
    case 68:
      result = &dword_10290;
      break;
    case 69:
      result = &dword_1028C;
      break;
    case 70:
      result = &dword_10288;
      break;
    case 71:
      result = &dword_10284;
      break;
    case 72:
      result = &dword_10280;
      break;
    case 73:
      result = &dword_1027C;
      break;
    case 74:
      result = &dword_10278;
      break;
    case 75:
      result = &dword_10274;
      break;
    case 76:
      result = &dword_10270;
      break;
    case 77:
      result = &dword_1026C;
      break;
    case 78:
      result = &dword_10268;
      break;
    case 79:
      result = &dword_10264;
      break;
    case 80:
      result = &dword_10260;
      break;
    case 81:
      result = &dword_1025C;
      break;
    case 82:
      result = &dword_10258;
      break;
    case 83:
      result = &dword_10254;
      break;
    case 84:
      result = &dword_10250;
      break;
    case 85:
      result = &dword_1024C;
      break;
    case 86:
      result = &dword_10248;
      break;
    case 87:
      result = &dword_10244;
      break;
    case 88:
      result = &dword_10240;
      break;
    case 89:
      result = &dword_1023C;
      break;
    case 90:
      result = &dword_10238;
      break;
    case 91:
      result = &dword_10234;
      break;
    case 92:
      result = &dword_10230;
      break;
    case 93:
      result = &dword_1022C;
      break;
    case 94:
      result = &dword_10228;
      break;
    case 95:
      result = &dword_10224;
      break;
    default:
      switch ( a2 )
      {
        case 256:
          result = &dword_10220;
          break;
        case 257:
          result = &dword_1021C;
          break;
        case 258:
          result = &dword_10218;
          break;
        case 259:
          result = &dword_10214;
          break;
        case 260:
          result = &dword_10210;
          break;
        case 261:
          result = &dword_1020C;
          break;
        case 262:
          result = &dword_10208;
          break;
        case 263:
          result = &dword_10204;
          break;
        case 264:
          result = &dword_10200;
          break;
        case 265:
          result = &dword_101FC;
          break;
        case 266:
          result = &dword_101F8;
          break;
        case 267:
          result = &dword_101F4;
          break;
        case 268:
          result = &dword_101F0;
          break;
        case 269:
          result = &dword_101EC;
          break;
        case 270:
          result = &dword_101E8;
          break;
        case 271:
          result = &dword_101E4;
          break;
        case 272:
          result = &dword_101E0;
          break;
        case 273:
          result = &dword_101DC;
          break;
        case 274:
          result = &dword_101D8;
          break;
        case 275:
          result = &dword_101D4;
          break;
        case 276:
          result = &dword_101D0;
          break;
        case 277:
          result = &dword_101CC;
          break;
        case 278:
          result = &dword_101C8;
          break;
        case 279:
          result = &dword_101C4;
          break;
        case 280:
          result = &dword_101C0;
          break;
        case 281:
          result = &dword_101BC;
          break;
        case 282:
          result = &dword_101B8;
          break;
        case 283:
          result = &dword_101B4;
          break;
        case 284:
          result = &dword_101B0;
          break;
        case 285:
          result = &dword_101AC;
          break;
        case 286:
          result = &dword_101A8;
          break;
        case 287:
          result = &dword_101A4;
          break;
        default:
          goto LABEL_5;
      }
      break;
  }
  return result;
}
// 101A0: using guessed type int dword_101A0;
// 101A4: using guessed type int dword_101A4;
// 101A8: using guessed type int dword_101A8;
// 101AC: using guessed type int dword_101AC;
// 101B0: using guessed type int dword_101B0;
// 101B4: using guessed type int dword_101B4;
// 101B8: using guessed type int dword_101B8;
// 101BC: using guessed type int dword_101BC;
// 101C0: using guessed type int dword_101C0;
// 101C4: using guessed type int dword_101C4;
// 101C8: using guessed type int dword_101C8;
// 101CC: using guessed type int dword_101CC;
// 101D0: using guessed type int dword_101D0;
// 101D4: using guessed type int dword_101D4;
// 101D8: using guessed type int dword_101D8;
// 101DC: using guessed type int dword_101DC;
// 101E0: using guessed type int dword_101E0;
// 101E4: using guessed type int dword_101E4;
// 101E8: using guessed type int dword_101E8;
// 101EC: using guessed type int dword_101EC;
// 101F0: using guessed type int dword_101F0;
// 101F4: using guessed type int dword_101F4;
// 101F8: using guessed type int dword_101F8;
// 101FC: using guessed type int dword_101FC;
// 10200: using guessed type int dword_10200;
// 10204: using guessed type int dword_10204;
// 10208: using guessed type int dword_10208;
// 1020C: using guessed type int dword_1020C;
// 10210: using guessed type int dword_10210;
// 10214: using guessed type int dword_10214;
// 10218: using guessed type int dword_10218;
// 1021C: using guessed type int dword_1021C;
// 10220: using guessed type int dword_10220;
// 10224: using guessed type int dword_10224;
// 10228: using guessed type int dword_10228;
// 1022C: using guessed type int dword_1022C;
// 10230: using guessed type int dword_10230;
// 10234: using guessed type int dword_10234;
// 10238: using guessed type int dword_10238;
// 1023C: using guessed type int dword_1023C;
// 10240: using guessed type int dword_10240;
// 10244: using guessed type int dword_10244;
// 10248: using guessed type int dword_10248;
// 1024C: using guessed type int dword_1024C;
// 10250: using guessed type int dword_10250;
// 10254: using guessed type int dword_10254;
// 10258: using guessed type int dword_10258;
// 1025C: using guessed type int dword_1025C;
// 10260: using guessed type int dword_10260;
// 10264: using guessed type int dword_10264;
// 10268: using guessed type int dword_10268;
// 1026C: using guessed type int dword_1026C;
// 10270: using guessed type int dword_10270;
// 10274: using guessed type int dword_10274;
// 10278: using guessed type int dword_10278;
// 1027C: using guessed type int dword_1027C;
// 10280: using guessed type int dword_10280;
// 10284: using guessed type int dword_10284;
// 10288: using guessed type int dword_10288;
// 1028C: using guessed type int dword_1028C;
// 10290: using guessed type int dword_10290;
// 10294: using guessed type int dword_10294;
// 10298: using guessed type int dword_10298;
// 1029C: using guessed type int dword_1029C;
// 102A0: using guessed type int dword_102A0;
// 102A4: using guessed type int dword_102A4;
// 102A8: using guessed type int dword_102A8;
// 102AC: using guessed type int dword_102AC;
// 102B0: using guessed type int dword_102B0;
// 102B4: using guessed type int dword_102B4;
// 102B8: using guessed type int dword_102B8;
// 102BC: using guessed type int dword_102BC;
// 102C0: using guessed type int dword_102C0;
// 102C4: using guessed type int dword_102C4;
// 102C8: using guessed type int dword_102C8;
// 102CC: using guessed type int dword_102CC;
// 102D0: using guessed type int dword_102D0;
// 102D4: using guessed type int dword_102D4;
// 102D8: using guessed type int dword_102D8;
// 102DC: using guessed type int dword_102DC;

//----- (0000FA8A) --------------------------------------------------------
int __fastcall sub_FA8A(int result)
{
  *(_BYTE *)(result + 72) = 1;
  return result;
}

//----- (0000FA94) --------------------------------------------------------
__int64 __fastcall sub_FA94(int a1, int a2)
{
  unsigned int v4; // r0
  _QWORD *v5; // r0
  int v6; // r0

  v4 = a2 & 0xFFFFFFF0;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(a1 + 67) )
    {
      *(_BYTE *)(a1 + 67) = 1;
      sub_F5B0();
    }
    v6 = a1 + 8 * a2 - 560;
  }
  else if ( v4 == 272 )
  {
    if ( !*(_BYTE *)(a1 + 66) )
    {
      *(_BYTE *)(a1 + 66) = 1;
      sub_F5A8((_QWORD *)(a1 + 208));
    }
    v6 = a1 + 8 * a2 - 1968;
  }
  else
  {
    if ( v4 != 256 )
    {
      fprintf(
        (FILE *)((char *)&_sF + 168),
        "libunwind: %s %s:%d - %s\n",
        "getFloatRegister",
        "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Registers.hpp",
        1681,
        "Unknown ARM float register");
      fflush((FILE *)((char *)&_sF + 168));
      abort();
    }
    if ( !*(_BYTE *)(a1 + 65) )
    {
      *(_BYTE *)(a1 + 65) = 1;
      v5 = (_QWORD *)(a1 + 72);
      if ( *(_BYTE *)(a1 + 64) )
        sub_F5A0(v5);
      else
        sub_F598(v5);
    }
    v6 = a1 + 8 * a2 - 1976;
  }
  return *(_QWORD *)v6;
}

//----- (0000FB74) --------------------------------------------------------
_DWORD *__fastcall sub_FB74(int a1, int a2, int a3, int a4)
{
  unsigned int v6; // r0
  _QWORD *v9; // r0
  _DWORD *result; // r0

  v6 = a2 & 0xFFFFFFF0;
  if ( (a2 & 0xFFFFFFF0) == 112 )
  {
    if ( !*(_BYTE *)(a1 + 67) )
    {
      *(_BYTE *)(a1 + 67) = 1;
      sub_F5B0();
    }
    result = (_DWORD *)(a1 + 8 * a2 - 560);
  }
  else if ( v6 == 272 )
  {
    if ( !*(_BYTE *)(a1 + 66) )
    {
      *(_BYTE *)(a1 + 66) = 1;
      sub_F5A8((_QWORD *)(a1 + 208));
    }
    result = (_DWORD *)(a1 + 8 * a2 - 1968);
  }
  else
  {
    if ( v6 != 256 )
    {
      fprintf(
        (FILE *)((char *)&_sF + 168),
        "libunwind: %s %s:%d - %s\n",
        "setFloatRegister",
        "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/Registers.hpp",
        1708,
        "Unknown ARM float register");
      fflush((FILE *)((char *)&_sF + 168));
      abort();
    }
    if ( !*(_BYTE *)(a1 + 65) )
    {
      *(_BYTE *)(a1 + 65) = 1;
      v9 = (_QWORD *)(a1 + 72);
      if ( *(_BYTE *)(a1 + 64) )
        sub_F5A0(v9);
      else
        sub_F598(v9);
    }
    result = (_DWORD *)(a1 + 8 * a2 - 1976);
  }
  *result = a3;
  result[1] = a4;
  return result;
}

//----- (0000FC60) --------------------------------------------------------
int __fastcall sub_FC60(int a1)
{
  int v2; // r4
  unsigned int *v3; // r0
  unsigned int v5; // [sp+4h] [bp-14h] BYREF
  unsigned int v6; // [sp+8h] [bp-10h] BYREF

  v2 = 0;
  v5 = 0;
  v6 = 0;
  v3 = sub_EDF4(*(unsigned int **)(a1 + 520), (int *)&v5, (int *)&v6);
  if ( sub_EE48(a1, (int)v3, v5, v6) == 8 )
    v2 = 1;
  return v2;
}
// 4240: using guessed type int (*off_4240)();

//----- (0000FCB8) --------------------------------------------------------
_DWORD *__fastcall sub_FCB8(int a1)
{
  _DWORD *result; // r0

  if ( *(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(a1 + 64) )
      sub_10310();
    else
      sub_10308();
  }
  if ( *(_BYTE *)(a1 + 66) )
    sub_10318();
  if ( *(_BYTE *)(a1 + 67) )
    sub_10320((int *)(a1 + 336));
  result = (_DWORD *)*(unsigned __int8 *)(a1 + 68);
  if ( *(_BYTE *)(a1 + 68) )
    result = sub_110A4((int *)(a1 + 464));
  return result;
}

//----- (0000FD08) --------------------------------------------------------
int __fastcall sub_FD08(int *a1, int a2, _DWORD *a3)
{
  int v4; // r5
  int v5; // r6
  int v6; // r3
  char *v7; // r5
  int *v8; // r0
  int v9; // r1
  bool v10; // zf
  int *v11; // r6
  int (*v12)(); // lr
  int v13; // r12
  int v14; // r10
  int v15; // r6
  int v16; // r6
  unsigned int v17; // r2
  int v19; // r2
  const char *v20; // [sp+4h] [bp-44h]
  int v21[3]; // [sp+18h] [bp-30h] BYREF
  int v22; // [sp+24h] [bp-24h] BYREF

  v4 = 0;
  v22 = a2;
  v5 = a3[1];
  sub_FF10(v21, 0, a1[1], a3, v5, a1[1], (int)a3, &v22);
  if ( !v21[0] || v21[0] == v5 )
    return v4;
  v7 = (char *)(*(_DWORD *)v21[2] + 8 * v21[0]);
  v8 = (int *)(v7 - 4);
  v9 = *(_DWORD *)v7;
  v10 = v7 == &byte_4;
  if ( v7 != &byte_4 )
  {
    v6 = *v8;
    v10 = *v8 == 1;
  }
  if ( v10 )
    return 0;
  if ( v6 < 0 )
  {
    v13 = 1;
    goto LABEL_13;
  }
  v11 = (int *)((char *)v8 + (v6 | (2 * v6) & 0x80000000));
  v6 = *v11;
  if ( *v11 <= -1 )
  {
    v13 = 0;
    v8 = v11;
LABEL_13:
    v15 = HIBYTE(v6) & 0xF;
    if ( v15 == 2 )
    {
      v12 = sub_F3C0;
      v16 = 1;
    }
    else
    {
      if ( v15 != 1 )
      {
        if ( !v15 )
        {
          v14 = (int)(v8 + 1);
          if ( v13 )
            v14 = 0;
          v12 = sub_F354;
          goto LABEL_19;
        }
        v20 = "unknown personality routine";
        v19 = 808;
LABEL_32:
        fprintf(
          (FILE *)((char *)&_sF + 168),
          "libunwind: %s %s:%d - %s\n",
          "getInfoFromEHABISection",
          "/usr/local/google/buildbot/src/android/ndk-release-r16/external/libcxx/../../external/libunwind_llvm/src/UnwindCursor.hpp",
          v19,
          v20);
        fflush((FILE *)((char *)&_sF + 168));
        abort();
      }
      v12 = sub_F3B8;
      v16 = 0;
    }
    if ( ((BYTE2(v6) != 0) & (unsigned __int8)v13) != 1 )
    {
      v14 = (int)&v8[BYTE2(v6) + 1];
      goto LABEL_24;
    }
    v20 = "index inlined table detected but pr function requires extra words";
    v19 = 815;
    goto LABEL_32;
  }
  v12 = (int (*)())((char *)v11 + ((2 * v6) & 0x80000000 | v6));
  v13 = 0;
  v14 = (int)&v11[HIBYTE(v11[1]) + 2];
  v8 = v11;
LABEL_19:
  v16 = 0;
LABEL_24:
  v17 = (unsigned int)&v7[((2 * *((_DWORD *)v7 - 2)) & 0x80000000 | *((_DWORD *)v7 - 2)) - 8];
  a1[130] = (int)v8;
  a1[122] = v17;
  a1[123] = (int)&v7[v9 | (2 * v9) & 0x80000000];
  a1[124] = v14;
  a1[125] = (int)v12;
  if ( v16 )
    v16 = 2;
  if ( v13 )
    v16 = 1;
  v4 = 1;
  a1[127] = v16;
  return v4;
}
// FD6E: variable 'v6' is possibly undefined
// 4: using guessed type char byte_4;
// F354: using guessed type int sub_F354();
// F3B8: using guessed type int sub_F3B8();
// F3C0: using guessed type int sub_F3C0();

//----- (0000FF10) --------------------------------------------------------
_DWORD *__fastcall sub_FF10(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5, int a6, int a7, _DWORD *a8)
{
  unsigned int v8; // r4
  int v9; // r6
  unsigned int v10; // r5

  v8 = a5 - a2;
  while ( 1 )
  {
    v10 = v8;
    if ( !v8 )
      break;
    v9 = a2 + (v8 >> 1);
    v8 >>= 1;
    if ( *a8 >= (*(_DWORD *)(*a4 + 8 * v9) | (2 * *(_DWORD *)(*a4 + 8 * v9)) & 0x80000000) + *a4 + 8 * v9 )
    {
      v8 = v10 - 1 - v8;
      a2 = v9 + 1;
    }
  }
  *a1 = a2;
  a1[1] = a3;
  a1[2] = a4;
  return a1 + 3;
}

//----- (000102F4) --------------------------------------------------------
int __fastcall sub_102F4(int a1)
{
  return (*(int (__fastcall **)(_DWORD, _DWORD, _DWORD, _DWORD))(a1 + 60))(
           *(_DWORD *)a1,
           *(_DWORD *)(a1 + 4),
           *(_DWORD *)(a1 + 8),
           *(_DWORD *)(a1 + 12));
}

//----- (00010308) --------------------------------------------------------
void sub_10308()
{
  ;
}

//----- (00010310) --------------------------------------------------------
void sub_10310()
{
  ;
}

//----- (00010318) --------------------------------------------------------
void sub_10318()
{
  ;
}

//----- (00010320) --------------------------------------------------------
_DWORD *__fastcall sub_10320(int *a1)
{
  int *v5; // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 2;
  __asm { LDCL            p1, c0, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c1, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c2, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c3, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c4, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c5, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c6, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c7, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c8, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c9, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c10, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c11, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c12, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c13, [R0],#8 }
  _T1 = *v5;
  v5 += 2;
  __asm { LDCL            p1, c14, [R0],#8 }
  _T1 = *v5;
  result = v5 + 2;
  __asm { LDCL            p1, c15, [R0],#8 }
  return result;
}

//----- (00010364) --------------------------------------------------------
_DWORD *__fastcall sub_10364(int *a1)
{
  int *v5; // r0
  _DWORD *result; // r0

  _T1 = *a1;
  v5 = a1 + 1;
  __asm { LDC2            p1, c8, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c9, [R0],#4 }
  _T1 = *v5++;
  __asm { LDC2            p1, c10, [R0],#4 }
  _T1 = *v5;
  result = v5 + 1;
  __asm { LDC2            p1, c11, [R0],#4 }
  return result;
}

//----- (00010380) --------------------------------------------------------
int __fastcall sub_10380(__int64 a1, __int64 a2)
{
  int v2; // r4
  int v3; // r5
  bool v4; // zf
  int v5; // r4
  bool v6; // vf
  char v7; // cc
  int v8; // r5
  __int64 v9; // r2
  int v10; // r4
  char v11; // lr
  unsigned int v12; // r12
  __int64 v13; // r0
  bool v14; // nf
  char v15; // r5
  int v16; // r3
  _BOOL1 v17; // off
  _BOOL1 v18; // cf
  int v19; // off
  int v20; // r4
  bool v21; // zf
  unsigned int v22; // r3
  int v23; // r3
  bool v24; // cc
  int v25; // r2
  unsigned int v26; // r12
  int v27; // r4
  int v28; // r4
  char v29; // r4
  bool v30; // zf
  bool v31; // zf

  HIDWORD(a2) ^= 0x80000000;
  v2 = 2 * HIDWORD(a1);
  v3 = 2 * HIDWORD(a2);
  v4 = 2 * HIDWORD(a1) == 2 * HIDWORD(a2);
  if ( 2 * HIDWORD(a1) == 2 * HIDWORD(a2) )
    v4 = (unsigned int)a1 == (unsigned int)a2;
  if ( !v4 )
  {
    v4 = (v2 | (unsigned int)a1) == 0;
    if ( v2 | (unsigned int)a1 )
    {
      v4 = (v3 | (unsigned int)a2) == 0;
      if ( v3 | (unsigned int)a2 )
      {
        v4 = v2 >> 21 == -1;
        if ( v2 >> 21 != -1 )
          v4 = v3 >> 21 == -1;
      }
    }
  }
  if ( v4 )
  {
    v30 = v2 >> 21 == -1;
    if ( v2 >> 21 != -1 )
      v30 = v3 >> 21 == -1;
    if ( v30 )
    {
      if ( v2 >> 21 != -1 )
        a1 = a2;
    }
    else
    {
      v31 = v2 == v3;
      if ( v2 == v3 )
        v31 = (unsigned int)a1 == (unsigned int)a2;
      if ( v31 )
      {
        if ( HIDWORD(a1) != HIDWORD(a2) )
        {
          LODWORD(a1) = 0;
          return a1;
        }
        if ( !((unsigned int)v2 >> 21) )
        {
          LODWORD(a1) = 2 * a1;
          return a1;
        }
        if ( (unsigned int)v2 < 0xFFC00000 )
          return a1;
        goto LABEL_68;
      }
      if ( !(v2 | (unsigned int)a1) )
        LODWORD(a1) = a2;
    }
  }
  else
  {
    v5 = (unsigned int)v2 >> 21;
    v6 = __OFSUB__((unsigned int)v3 >> 21, v5);
    v8 = ((unsigned int)v3 >> 21) - v5;
    v7 = (v8 < 0) ^ v6 | (v8 == 0);
    if ( v8 < 0 != v6 )
      v8 = -v8;
    if ( !v7 )
    {
      v5 += v8;
      v9 = a1 ^ a2;
      a1 ^= v9;
      a2 = a1 ^ v9;
    }
    if ( (unsigned int)v8 <= 0x36 )
    {
      v4 = a1 >= 0;
      HIDWORD(a1) = HIDWORD(a1) & 0xFFFFF | 0x100000;
      if ( !v4 )
      {
        v18 = (_DWORD)a1 == 0;
        LODWORD(a1) = -(int)a1;
        HIDWORD(a1) -= 2 * HIDWORD(a1) + !v18;
      }
      v4 = a2 >= 0;
      HIDWORD(a2) = HIDWORD(a2) & 0xFFFFF | 0x100000;
      if ( !v4 )
      {
        v18 = (_DWORD)a2 == 0;
        LODWORD(a2) = -(int)a2;
        HIDWORD(a2) -= 2 * HIDWORD(a2) + !v18;
      }
      if ( v5 == v8 )
      {
        HIDWORD(a2) ^= 0x100000u;
        if ( v5 )
        {
          --v8;
        }
        else
        {
          HIDWORD(a1) ^= 0x100000u;
          v5 = 1;
        }
      }
      v10 = v5 - 1;
      v11 = 32 - v8;
      if ( v8 > 32 )
      {
        v15 = v8 - 32;
        v12 = HIDWORD(a2) << (v11 + 32);
        if ( (_DWORD)a2 )
          v12 |= 2u;
        v16 = SHIDWORD(a2) >> v15;
        LODWORD(a1) = a1 + v16;
        HIDWORD(a1) += (v16 >> 31) + __CFSHR__(v16, 31);
        v14 = a1 < 0;
      }
      else
      {
        v12 = (_DWORD)a2 << v11;
        v13 = a1 + ((unsigned int)a2 >> v8);
        LODWORD(a2) = HIDWORD(a2) << v11;
        SHIDWORD(a2) >>= v8;
        a1 = v13 + a2;
        v14 = a1 < 0;
      }
      if ( v14 )
      {
        v18 = v12 == 0;
        v12 = -v12;
        v17 = v18;
        v18 = __CFSUB__(0, (_DWORD)a1, v18);
        LODWORD(a1) = -(a1 + !v17);
        HIDWORD(a1) = -(HIDWORD(a1) + !v18);
      }
      if ( HIDWORD(a1) >= 0x100000 )
      {
        if ( HIDWORD(a1) < 0x200000 )
          goto LABEL_30;
        v18 = a1 & 1;
        LODWORD(a1) = a1 >> 1;
        v12 = (v12 >> 1) | (v18 << 31);
        if ( (unsigned int)((v10 + 1) << 21) < 0xFFC00000 )
          goto LABEL_30;
LABEL_68:
        JUMPOUT(0x105C4);
      }
      v18 = __CFSHL__(v12, 1);
      v12 *= 2;
      v19 = v18 + (_DWORD)a1;
      v18 = __CFADD__(v18, (_DWORD)a1) | __CFADD__((_DWORD)a1, v19);
      LODWORD(a1) = a1 + v19;
      HIDWORD(a1) += v18 + HIDWORD(a1);
      v20 = v10 - 1;
      if ( (a1 & 0x10000000000000LL) != 0 )
      {
LABEL_30:
        v18 = v12 >= 0x80000000;
        if ( v12 == 0x80000000 )
          v18 = a1 & 1;
        LODWORD(a1) = v18 + (_DWORD)a1;
        return a1;
      }
      v21 = HIDWORD(a1) == 0;
      if ( !HIDWORD(a1) )
      {
        HIDWORD(a1) = a1;
        LODWORD(a1) = 0;
      }
      v22 = __clz(HIDWORD(a1));
      if ( v21 )
        v22 += 32;
      v23 = v22 - 11;
      v25 = v23 - 32;
      v24 = v23 <= 32;
      if ( v23 < 32 )
      {
        v24 = v25 <= -12;
        if ( v25 > -12 )
        {
          LODWORD(a1) = HIDWORD(a1) << v23;
          HIDWORD(a1) >>= 32 - v23;
LABEL_46:
          v7 = v20 < v23;
          v27 = v20 - v23;
          if ( v7 )
          {
            v28 = ~v27;
            v7 = v28 < 31;
            v29 = v28 - 31;
            if ( v7 )
              LODWORD(a1) = ((unsigned int)a1 >> (v29 + 32)) | (HIDWORD(a1) << -v29);
            else
              LODWORD(a1) = HIDWORD(a1) >> v29;
          }
          return a1;
        }
        LOBYTE(v25) = v23;
      }
      if ( v24 )
        LOBYTE(v12) = 32 - v25;
      HIDWORD(a1) <<= v25;
      v26 = (unsigned int)a1 >> v12;
      if ( v24 )
      {
        HIDWORD(a1) |= v26;
        LODWORD(a1) = (_DWORD)a1 << v25;
      }
      goto LABEL_46;
    }
  }
  return a1;
}
// 105C0: control flows out of bounds to 105C4

//----- (000105FC) --------------------------------------------------------
int __fastcall sub_105FC(int result)
{
  if ( result )
    JUMPOUT(0x104BC);
  return result;
}
// 10618: control flows out of bounds to 104BC

//----- (00010640) --------------------------------------------------------
int __fastcall sub_10640(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // r2
  int result; // r0
  bool v6; // zf

  v4 = 2 * a1;
  v6 = 2 * a1 == 0;
  result = a1 << 29;
  if ( v6 || (a4 = v4 & 0xFF000000, (v4 & 0xFF000000) == 0) || a4 == 0xFF000000 )
  {
    v6 = v4 == 0;
    if ( v4 )
      v6 = a4 == 0xFF000000;
    if ( !v6 )
      JUMPOUT(0x104BC);
  }
  return result;
}
// 10678: control flows out of bounds to 104BC

//----- (0001068C) --------------------------------------------------------
int __fastcall sub_1068C(__int64 a1)
{
  bool v1; // cf
  int v2; // off
  int v3; // r4
  bool v4; // zf
  unsigned int v5; // r3
  int v6; // r3
  bool v7; // cc
  int v8; // r2
  unsigned int v9; // r12
  int v10; // r4
  int v11; // r4
  char v12; // r4
  int v13; // r4
  unsigned int v14; // r12
  int v15; // r2
  int v16; // r2

  if ( !a1 )
    return a1;
  if ( a1 < 0 )
  {
    v1 = (_DWORD)a1 == 0;
    LODWORD(a1) = -(int)a1;
    HIDWORD(a1) -= 2 * HIDWORD(a1) + !v1;
  }
  v13 = 1074;
  v14 = HIDWORD(a1) >> 22;
  if ( HIDWORD(a1) >> 22 )
  {
    v15 = 3;
    if ( HIDWORD(a1) >> 25 )
      v15 = 6;
    if ( HIDWORD(a1) >> 28 )
      v15 += 3;
    v16 = v15 + (HIDWORD(a1) >> 31);
    v14 = (_DWORD)a1 << (32 - v16);
    LODWORD(a1) = ((unsigned int)a1 >> v16) | (HIDWORD(a1) << (32 - v16));
    HIDWORD(a1) >>= v16;
    v13 = v16 + 1074;
  }
  if ( HIDWORD(a1) >= 0x100000 )
  {
    if ( HIDWORD(a1) >= 0x200000 )
    {
      v1 = a1 & 1;
      LODWORD(a1) = a1 >> 1;
      v14 = (v14 >> 1) | (v1 << 31);
      if ( (unsigned int)((v13 + 1) << 21) >= 0xFFC00000 )
      {
        LODWORD(a1) = 0;
        return a1;
      }
    }
    goto LABEL_13;
  }
  v1 = __CFSHL__(v14, 1);
  v14 *= 2;
  v2 = v1 + (_DWORD)a1;
  v1 = __CFADD__(v1, (_DWORD)a1) | __CFADD__((_DWORD)a1, v2);
  LODWORD(a1) = a1 + v2;
  HIDWORD(a1) += v1 + HIDWORD(a1);
  v3 = v13 - 1;
  if ( (a1 & 0x10000000000000LL) != 0 )
  {
LABEL_13:
    v1 = v14 >= 0x80000000;
    if ( v14 == 0x80000000 )
      v1 = a1 & 1;
    LODWORD(a1) = v1 + (_DWORD)a1;
    return a1;
  }
  v4 = HIDWORD(a1) == 0;
  if ( !HIDWORD(a1) )
  {
    HIDWORD(a1) = a1;
    LODWORD(a1) = 0;
  }
  v5 = __clz(HIDWORD(a1));
  if ( v4 )
    v5 += 32;
  v6 = v5 - 11;
  v8 = v6 - 32;
  v7 = v6 <= 32;
  if ( v6 >= 32 )
    goto LABEL_25;
  v7 = v8 <= -12;
  if ( v8 <= -12 )
  {
    LOBYTE(v8) = v6;
LABEL_25:
    if ( v7 )
      LOBYTE(v14) = 32 - v8;
    HIDWORD(a1) <<= v8;
    v9 = (unsigned int)a1 >> v14;
    if ( v7 )
    {
      HIDWORD(a1) |= v9;
      LODWORD(a1) = (_DWORD)a1 << v8;
    }
    goto LABEL_29;
  }
  LODWORD(a1) = HIDWORD(a1) << v6;
  HIDWORD(a1) >>= 32 - v6;
LABEL_29:
  v7 = v3 < v6;
  v10 = v3 - v6;
  if ( v7 )
  {
    v11 = ~v10;
    v7 = v11 < 31;
    v12 = v11 - 31;
    if ( v7 )
      LODWORD(a1) = ((unsigned int)a1 >> (v12 + 32)) | (HIDWORD(a1) << -v12);
    else
      LODWORD(a1) = HIDWORD(a1) >> v12;
  }
  return a1;
}

//----- (00010888) --------------------------------------------------------
int __fastcall sub_10888(__int64 a1)
{
  unsigned int v1; // r3
  bool v2; // cf
  bool v3; // zf
  unsigned int v4; // r12
  int v5; // r3
  signed int v6; // r2
  bool v7; // cc
  int v8; // r2
  int v9; // r3
  int v10; // r12
  char v11; // r2

  if ( a1 )
  {
    v1 = HIDWORD(a1) & 0x80000000;
    if ( a1 < 0 )
    {
      v2 = (_DWORD)a1 == 0;
      LODWORD(a1) = -(int)a1;
      HIDWORD(a1) -= 2 * HIDWORD(a1) + !v2;
    }
    v4 = HIDWORD(a1);
    v3 = HIDWORD(a1) == 0;
    if ( !HIDWORD(a1) )
    {
      v4 = a1;
      HIDWORD(a1) = a1;
      LODWORD(a1) = 0;
    }
    v5 = v1 | 0x5B000000;
    if ( v3 )
      v5 -= 0x10000000;
    v6 = __clz(v4);
    v7 = v6 < 8;
    v8 = v6 - 8;
    v9 = v5 - 0x800000 - (v8 << 23);
    if ( v7 )
    {
      v11 = v8 + 32;
      v3 = ((unsigned int)a1 | (2 * (HIDWORD(a1) << v11))) == 0;
      LODWORD(a1) = (HIDWORD(a1) >> (32 - v11)) + __CFSHL__(HIDWORD(a1) << v11, 1) + v9;
      if ( v3 )
        LODWORD(a1) = a1 & ~(HIDWORD(a1) << v11 >> 31);
    }
    else
    {
      v10 = (_DWORD)a1 << v8;
      LODWORD(a1) = ((unsigned int)a1 >> (32 - v8)) + ((_DWORD)a1 << v8 >= 0x80000000) + v9 + (HIDWORD(a1) << v8);
      if ( v10 == 0x80000000 )
        LODWORD(a1) = a1 & 0xFFFFFFFE;
    }
  }
  return a1;
}

//----- (00010904) --------------------------------------------------------
int __fastcall sub_10904(void *a1, void *a2, int a3, void *a4)
{
  void *v4; // r4
  void *v5; // r5
  void *v6; // r6

  return linux_eabi_syscall(983042, a1, a2, 0, a4, v4, v5, v6);
}
// 10912: variable 'v4' is possibly undefined
// 10912: variable 'v5' is possibly undefined
// 10912: variable 'v6' is possibly undefined

//----- (00010918) --------------------------------------------------------
unsigned int __fastcall sub_10918(int a1)
{
  int v2; // r1
  int v3; // r2
  unsigned int v4; // r3
  unsigned int result; // r0

  if ( sub_11014(a1, 0) )
    result = -sub_10970(a1 + 0x80000000, v2, v3, v4);
  else
    result = sub_10970(a1, v2, v3, v4);
  return result;
}
// 1092A: variable 'v2' is possibly undefined
// 1092A: variable 'v3' is possibly undefined
// 1092A: variable 'v4' is possibly undefined

//----- (0001093E) --------------------------------------------------------
unsigned int __fastcall sub_1093E(unsigned int a1, unsigned int a2)
{
  __int64 v5; // r0

  if ( !sub_10EE8(a1, a2, 0, 0) )
    return sub_109BC(__SPAIR64__(a2, a1));
  LODWORD(v5) = a1;
  HIDWORD(v5) = a2 + 0x80000000;
  return -sub_109BC(v5);
}

//----- (00010970) --------------------------------------------------------
unsigned int __fastcall sub_10970(int a1, int a2, int a3, unsigned int a4)
{
  __int64 v4; // r0
  __int64 v5; // r6
  unsigned int v6; // r0
  int v7; // r1
  int v8; // r4
  __int64 v9; // r0
  __int64 v10; // r0
  int v11; // r0
  int v12; // r1

  LODWORD(v4) = sub_10640(a1, a2, a3, a4);
  v5 = v4;
  v6 = sub_10A04(v4, 0, 0x3DF00000u);
  v8 = sub_10F38(v6, v7);
  LODWORD(v9) = sub_105FC(v8);
  LODWORD(v10) = sub_10A04(v9, 0, 0x41F00000u);
  v11 = sub_10380(v5, v10);
  return sub_10F38(v11, v12);
}
// 1097A: variable 'v4' is possibly undefined
// 10982: variable 'v7' is possibly undefined
// 10990: variable 'v9' is possibly undefined
// 1099C: variable 'v10' is possibly undefined
// 109A0: variable 'v12' is possibly undefined

//----- (000109BC) --------------------------------------------------------
unsigned int __fastcall sub_109BC(__int64 a1)
{
  unsigned int v2; // r0
  int v3; // r1
  int v4; // r4
  __int64 v5; // r0
  __int64 v6; // r0
  int v7; // r0
  int v8; // r1

  v2 = sub_10A04(a1, 0, 0x3DF00000u);
  v4 = sub_10F38(v2, v3);
  LODWORD(v5) = sub_105FC(v4);
  LODWORD(v6) = sub_10A04(v5, 0, 0x41F00000u);
  v7 = sub_10380(a1, v6);
  return sub_10F38(v7, v8);
}
// 109CA: variable 'v3' is possibly undefined
// 109D8: variable 'v5' is possibly undefined
// 109E4: variable 'v6' is possibly undefined
// 109E8: variable 'v8' is possibly undefined

//----- (00010A04) --------------------------------------------------------
unsigned int __fastcall sub_10A04(__int64 a1, int a2, unsigned int a3)
{
  int v3; // r5
  unsigned int v4; // r12
  bool v5; // zf
  int v6; // r4
  int v7; // r4
  int v8; // r6
  int v9; // r1
  int v10; // r3
  bool v11; // zf
  int v12; // r3
  int v13; // r12
  unsigned int v14; // r5
  unsigned int v15; // lr
  unsigned int v16; // r2
  unsigned int v17; // lr
  unsigned __int64 v18; // kr10_8
  unsigned int v19; // r5
  unsigned int v20; // r6
  int v21; // r4
  unsigned int v22; // off
  unsigned int v23; // r1
  unsigned int result; // r0
  unsigned int v25; // lr
  bool v26; // cc
  bool v27; // cf
  unsigned int v28; // r1
  int v29; // r4
  int v30; // r4
  int v31; // r4
  char v32; // r4
  char v33; // r4
  unsigned int v34; // r3
  char v35; // r4
  unsigned int v36; // r3
  int v37; // lr
  unsigned int v38; // r3
  int v39; // [sp+0h] [bp-10h]
  int v40; // [sp+4h] [bp-Ch]
  int v41; // [sp+8h] [bp-8h]
  int v42; // [sp+Ch] [bp-4h]

  v4 = 2047;
  v6 = (HIDWORD(a1) >> 20) & 0x7FF;
  v5 = v6 == 0;
  if ( v6 )
  {
    v3 = (a3 >> 20) & 0x7FF;
    v5 = v3 == 0;
  }
  if ( !v5 )
  {
    v5 = v6 == 0x7FF;
    if ( v6 != 0x7FF )
      v5 = v3 == 0x7FF;
  }
  if ( v5 )
    LODWORD(a1) = sub_10BE0(a1, HIDWORD(a1), a2, a3, v39, v40, v41, v42);
  v7 = v6 + v3;
  v8 = HIDWORD(a1) ^ a3;
  v9 = HIDWORD(a1) & ~(v4 << 21);
  v10 = a3 & ~(v4 << 21);
  v11 = ((unsigned int)a1 | (v9 << 12)) == 0;
  if ( (unsigned int)a1 | (v9 << 12) )
    v11 = (a2 | (v10 << 12)) == 0;
  HIDWORD(a1) = v9 | 0x100000;
  v12 = v10 | 0x100000;
  if ( v11 )
  {
    LODWORD(a1) = a1 | a2;
    v28 = (v8 & 0x80000000 | HIDWORD(a1)) ^ v12;
    v26 = v7 <= (int)(v4 >> 1);
    v29 = v7 - (v4 >> 1);
    if ( !v26 && (int)v4 > v29 )
      return result;
    v23 = v28 | 0x100000;
    v25 = 0;
    v26 = v29 <= 1;
    v21 = v29 - 1;
  }
  else
  {
    v13 = a1 * a2;
    v14 = (HIDWORD(a1) * (unsigned __int64)(unsigned int)a2
         + (((unsigned int)a1 * (unsigned __int64)(unsigned int)a2) >> 32)) >> 32;
    v15 = (a1 * (unsigned __int64)(unsigned int)a2) >> 32;
    v16 = v8 & 0x80000000;
    v18 = (unsigned int)a1 * (unsigned __int64)(unsigned int)v12 + __PAIR64__(v14, v15);
    v17 = v18;
    v20 = (HIDWORD(a1) * (unsigned __int64)(unsigned int)v12 + HIDWORD(v18)) >> 32;
    v19 = HIDWORD(a1) * v12 + HIDWORD(v18);
    if ( v13 )
      v17 = v18 | 1;
    v21 = (__PAIR64__(v7 - 255, v20) - 0x30000000200LL) >> 32;
    if ( v20 < 0x200 )
    {
      v27 = __CFSHL__(v17, 1);
      v17 *= 2;
      v22 = v27 + v19;
      v27 = __CFADD__(v27, v19) | __CFADD__(v19, v22);
      v19 += v22;
      v20 += v27 + v20;
    }
    v23 = v16 | (v20 << 11) | (v19 >> 21);
    result = (v19 << 11) | (v17 >> 21);
    v25 = v17 << 11;
    v26 = v21 <= 253;
    if ( (unsigned int)v21 > 0xFD )
      v26 = v21 - 253 <= 1792;
    if ( !v26 )
    {
      v27 = v25 >= 0x80000000;
      if ( v25 == 0x80000000 )
        v27 = result & 1;
      result += v27;
      return result;
    }
  }
  if ( !v26 )
    JUMPOUT(0x10C3C);
  if ( v21 <= -54 )
    return 0;
  v30 = -v21;
  v26 = v30 < 32;
  v31 = v30 - 32;
  if ( v26 )
  {
    v26 = v31 <= -12;
    v32 = v31 + 12;
    if ( v26 )
    {
      v33 = v32 + 20;
      v34 = result << (32 - v33);
      result = ((result >> v33) | (v23 << (32 - v33))) + (v34 >> 31);
      if ( !(v25 | (2 * v34)) )
        result &= ~(v34 >> 31);
    }
    else
    {
      v35 = 12 - v32;
      v36 = result << v35;
      result = ((result >> (32 - v35)) | (v23 << v35)) + (result << v35 >> 31);
      if ( !(v25 | (2 * v36)) )
        result &= ~(v36 >> 31);
    }
  }
  else
  {
    v37 = v25 | (result << (32 - v31));
    v38 = (result >> v31) | (v23 << (32 - v31));
    result = ((v23 >> v31) & ~((v23 & 0x80000000) >> v31)) + (v38 >> 31);
    if ( !(v37 | (2 * v38)) )
      result &= ~(v38 >> 31);
  }
  return result;
}
// 10AE2: control flows out of bounds to 10C3C
// 10A1C: variable 'v3' is possibly undefined
// 10A20: variable 'v39' is possibly undefined
// 10A20: variable 'v40' is possibly undefined
// 10A20: variable 'v41' is possibly undefined
// 10A20: variable 'v42' is possibly undefined
// 10A26: variable 'a1' is possibly undefined
// 10A26: variable 'a3' is possibly undefined
// 10A2A: variable 'v4' is possibly undefined
// 10A38: variable 'a2' is possibly undefined

//----- (00010BE0) --------------------------------------------------------
int __fastcall sub_10BE0(int result, unsigned int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8)
{
  bool v8; // cf
  int v9; // r4
  int v10; // r12
  bool v11; // zf
  int v12; // r5
  bool v13; // zf
  bool v14; // zf
  int (__fastcall *v15)(_DWORD, unsigned int); // [sp-4h] [bp-4h]

  v11 = v9 == v10;
  v12 = v10 & (a4 >> 20);
  if ( v9 != v10 )
    v11 = v12 == v10;
  if ( v11 )
  {
    v14 = (result | (2 * a2)) == 0;
    if ( result | (2 * a2) )
    {
      v14 = (a3 | (2 * a4)) == 0;
    }
    else
    {
      result = a3;
      a2 = a4;
    }
    if ( v14 || v9 == v10 && result | (a2 << 12) || v12 == v10 && a3 | (a4 << 12) )
      __asm { POP             {R4-R6,PC} }
    result = v15(0, (a2 ^ a4) & 0x80000000 | 0x7FF00000);
  }
  else
  {
    v13 = (result | (2 * a2)) == 0;
    if ( result | (2 * a2) )
      v13 = (a3 | (2 * a4)) == 0;
    if ( v13 )
      __asm { POP             {R4-R6,PC} }
    if ( v9 )
      goto LABEL_27;
    while ( 1 )
    {
      v8 = __CFSHL__(result, 1);
      result *= 2;
      a2 += v8 + a2;
      if ( (a2 & 0x100000) != 0 )
        break;
      --v9;
    }
    if ( !v12 )
    {
LABEL_27:
      while ( 1 )
      {
        v8 = __CFSHL__(a3, 1);
        a3 *= 2;
        a4 += v8 + a4;
        if ( (a4 & 0x100000) != 0 )
          break;
        --v12;
      }
    }
  }
  return result;
}
// 10BE0: variable 'v9' is possibly undefined
// 10BE0: variable 'v10' is possibly undefined
// 10C4C: variable 'v15' is possibly undefined

//----- (00010DC6) --------------------------------------------------------
int __fastcall sub_10DC6(int result, int a2, int a3, unsigned int a4)
{
  bool v4; // cf
  int v5; // r4
  int v6; // r12
  int v7; // r5
  bool v8; // zf
  bool v9; // zf

  v7 = v6 & (a4 >> 20);
  v8 = v5 == v6;
  if ( v5 == v6 )
    v8 = v7 == v6;
  if ( v8 )
LABEL_25:
    JUMPOUT(0x10C4E);
  if ( v5 == v6 )
  {
    if ( result | (a2 << 12) || v7 == v6 )
      goto LABEL_25;
LABEL_26:
    JUMPOUT(0x10C38);
  }
  if ( v7 == v6 )
  {
    if ( a3 | (a4 << 12) )
      goto LABEL_25;
    goto LABEL_27;
  }
  v9 = (result | (2 * a2)) == 0;
  if ( result | (2 * a2) )
    v9 = (a3 | (2 * a4)) == 0;
  if ( v9 )
  {
    if ( result | (2 * a2) )
      goto LABEL_26;
    if ( !(a3 | (2 * a4)) )
      goto LABEL_25;
LABEL_27:
    JUMPOUT(0x10BFC);
  }
  if ( v5 )
    goto LABEL_30;
  while ( 1 )
  {
    v4 = __CFSHL__(result, 1);
    result *= 2;
    a2 += v4 + a2;
    if ( (a2 & 0x100000) != 0 )
      break;
    --v5;
  }
  if ( !v7 )
  {
LABEL_30:
    while ( 1 )
    {
      v4 = __CFSHL__(a3, 1);
      a3 *= 2;
      a4 += v4 + a4;
      if ( (a4 & 0x100000) != 0 )
        break;
      --v7;
    }
  }
  return result;
}
// 10DD4: control flows out of bounds to 10C4E
// 10DEA: control flows out of bounds to 10C38
// 10DFE: control flows out of bounds to 10BFC
// 10DC6: variable 'v6' is possibly undefined
// 10DCA: variable 'v5' is possibly undefined

//----- (00010E38) --------------------------------------------------------
int __fastcall sub_10E38(unsigned int a1, unsigned int a2, unsigned int a3, int a4)
{
  bool v4; // zf
  bool v5; // zf
  bool v7; // cf
  bool v8; // zf
  int v9; // r0

  v4 = (int)(2 * a2) >> 21 == -1;
  if ( (int)(2 * a2) >> 21 != -1 )
    v4 = (2 * a4) >> 21 == -1;
  if ( v4 && ((int)(2 * a2) >> 21 == -1 && a1 | (a2 << 12) || (2 * a4) >> 21 == -1 && a3 | (a4 << 12)) )
    return 1;
  v5 = (a1 | (2 * a2)) == 0;
  if ( !(a1 | (2 * a2)) )
    v5 = (a3 | (2 * a4)) == 0;
  if ( !v5 )
    v5 = a2 == a4;
  if ( v5 && a1 == a3 )
    return 0;
  v7 = 0;
  v8 = a2 == a4;
  if ( ((a2 ^ a4) & 0x80000000) == 0 )
  {
    v7 = a2 >= a4;
    v8 = a2 == a4;
  }
  if ( v8 )
    v7 = a1 >= a3;
  if ( v7 )
    v9 = a4 >> 31;
  else
    v9 = ~(a4 >> 31);
  return v9 | 1;
}

//----- (00010EB4) --------------------------------------------------------
unsigned int __fastcall sub_10EB4(unsigned int a1, int a2, unsigned int a3, unsigned int a4)
{
  return sub_10EC4(a3, a4, a1, a2);
}

//----- (00010EC4) --------------------------------------------------------
unsigned int __fastcall sub_10EC4(unsigned int a1, unsigned int a2, unsigned int a3, int a4)
{
  sub_10E38(a1, a2, a3, a4);
  return a1;
}

//----- (00010EE8) --------------------------------------------------------
int __fastcall sub_10EE8(unsigned int a1, unsigned int a2, unsigned int a3, int a4)
{
  char v4; // cf
  int result; // r0

  sub_10EC4(a1, a2, a3, a4);
  if ( v4 )
    result = 0;
  else
    result = 1;
  return result;
}
// 10EF0: variable 'v4' is possibly undefined

//----- (00010F38) --------------------------------------------------------
unsigned int __fastcall sub_10F38(unsigned int a1, int a2)
{
  int v2; // r2
  bool v3; // cf
  int v4; // r2
  int v5; // r2

  v2 = 2 * a2;
  if ( __CFSHL__(a2, 1) )
    return 0;
  v3 = __CFADD__(v2, 0x200000);
  v4 = v2 + 0x200000;
  if ( !v3 )
  {
    if ( v4 < 0 )
    {
      v5 = -993 - (v4 >> 21);
      if ( v5 >= 0 )
        return ((a2 << 11) | 0x80000000 | (a1 >> 21)) >> v5;
      return -1;
    }
    return 0;
  }
  if ( !(a1 | (a2 << 12)) )
    return -1;
  return 0;
}

//----- (00010F88) --------------------------------------------------------
int __fastcall sub_10F88(int result, int a2)
{
  int v2; // r2
  unsigned int v3; // r3
  bool v4; // zf
  bool v5; // cf
  bool v6; // zf
  bool v7; // nf
  bool v8; // cc

  v2 = 2 * result;
  v3 = 2 * a2;
  v4 = (2 * result) >> 24 == -1;
  if ( (2 * result) >> 24 != -1 )
    v4 = (int)v3 >> 24 == -1;
  if ( v4 && (v2 >> 24 == -1 && result << 9 || (int)v3 >> 24 == -1 && a2 << 9) )
    return 1;
  v5 = 0;
  v6 = (v2 | (v3 >> 1)) == 0;
  v8 = 0;
  v7 = ((v2 | (v3 >> 1)) & 0x80000000) != 0;
  if ( v2 | (v3 >> 1) )
  {
    v6 = result == a2;
    v8 = 0;
    v7 = (result ^ a2) < 0;
  }
  if ( !v7 )
  {
    v5 = v2 >= v3;
    result = v2 - v3;
    v6 = v2 == v3;
    v8 = v2 > v3;
  }
  if ( v8 )
    result = a2 >> 31;
  if ( !v5 )
    result = ~(a2 >> 31);
  if ( !v6 )
    result |= 1u;
  return result;
}

//----- (00010FE8) --------------------------------------------------------
int __fastcall sub_10FE8(int a1, int a2)
{
  int result; // r0

  result = a2;
  sub_10FF0(a2, a1);
  return result;
}

//----- (00010FF0) --------------------------------------------------------
void __fastcall __spoils<R2,R3,R12> sub_10FF0(int a1, int a2)
{
  sub_10F88(a1, a2);
}

//----- (00011014) --------------------------------------------------------
int __fastcall sub_11014(int a1, int a2)
{
  char v2; // cf
  int result; // r0

  sub_10FF0(a1, a2);
  if ( v2 )
    result = 0;
  else
    result = 1;
  return result;
}
// 1101C: variable 'v2' is possibly undefined

//----- (00011064) --------------------------------------------------------
// attributes: thunk
void j_free(void *p)
{
  free(p);
}

//----- (00011074) --------------------------------------------------------
// attributes: thunk
int __fastcall j_pthread_mutex_unlock(pthread_mutex_t *mutex)
{
  return pthread_mutex_unlock(mutex);
}

//----- (00011084) --------------------------------------------------------
// attributes: thunk
void __fastcall operator delete(void *a1)
{
  _ZdlPv(a1);
}

//----- (00011094) --------------------------------------------------------
// attributes: thunk
int __fastcall sub_11094(int a1)
{
  return sub_102F4(a1);
}

//----- (000110A4) --------------------------------------------------------
// attributes: thunk
_DWORD *__fastcall sub_110A4(int *a1)
{
  return sub_10364(a1);
}

// nfuncs=385 queued=221 decompiled=221 lumina nreq=0 worse=0 better=0
// ALL OK, 221 function(s) have been successfully decompiled
